# unitv3 简介

## 1. 产品信息介绍

## 2. 支持主流的AI框架

## 3. unitv3 配套软件资料

### 3.1 unitv3 软件组件

### 3.2 unitv3 软件组件快速上手

### 3.3 商用算法适配

### 3.4 用户自定义AI算法教程

### 3.5 应用笔记与开发实例

### 3.6 嵌入式系统开发资料


## 4. EASY EAI Nano硬件资料

## 5. EASY EAI Nano vs Jetson Nano

## 6. 产品资料及技术支持

## 7. 内部测试报告

## 8. 认证报告





















# unitv3 能做什么

## 1. 人脸识别门禁解决方案

## 2. 边缘AI盒子解决方案

## 3. 手部检测遥控

## 4. 安全帽检测

## 5. 仓库起火检测

## 6. 车辆检测

## 7. 行人检测

## 8. 铁路软枕检测

## 9. 移动监测

## 10. 人脸98关键点检测

## 11. 二维码识别














# 导读

## 1. 硬件开发

## 2.  嵌入式底层开发

## 3. 嵌入式应用开发

## 4. AI算法开发



# 开发套件与选购配件

## 开发套件介绍

## 硬件主板

## 摄像头

## 显示屏配件

## 通讯配件

## 开发调试配件

## 功能配件（树莓派配件)

## 其他配件













# 入门指南


## 开发套件组装上电

### 1. 开发套件开箱

### 2. 上电下电操作

## 开发环境准备

## 开发板调试方式介绍

### 1. ADB调试
### 2. 串口调试
### 3. 网络调试


## 开发板上运行第一个程序


### 1.运行第一个程序


### 1.1 运行门禁机

## 开发（编译）方式说明

### 1. 交叉编译（推荐）

#### 1.1 优缺点

优点：

       采用x86架构的CPU进行编译，编译速度快。

       源码编辑方便，开发环境支持各种如vsCode、qtCreator等IDE。

缺点：

       编译环境需要进行安装部署。

       程序的调试运行操作相对本地编译不那么直接。

#### 1.2 EASY-EAI编译环境简介


##### 1.2.1 安装部署方式
##### 1.2.2 映射关系介绍

#### 1.3 常规编译手段示例

#### 1.4 常规编译手段说明

### 2. 本地编译

#### 2.1 优缺点

优点：

       把开发板直接当成一台卡片电脑使用，无须进行繁琐的应用部署。

缺点：

       采用rv1126的CPU进行编译，性能较弱，编译速度慢。

       源码编辑困难，仅有源生的vi编辑器可使用，无法使用各种IDE

#### 2.2 使用方法

       可以利用：adb、调试串口、ssh三种方式进入开发板后台，然后直接把开发板当做一台装有ubuntu系统的电脑使用。



## 应用程序开机自启动



### 1. 简要介绍
#### 1.1 系统默认自带：
#### 1.2 用户自定义创建：
#### 1.3 调用顺序及关系：

### 2. 操作指导：

#### 2.1 创建并编辑/userdata/apps/run.sh脚本

#### 2.2 重启验证

#### 2.3 注意事项说明：

### 3. 详细说明：

#### 3.1 /etc/init.d/S99_userapp

#### 3.2 /userdata/start_app.sh

#### 3.3 /userdata/stop_app.sh



# 外设体验


## 1. 概述
本章主要讲述使用命令行就能体验的EASY EAI Nano一些功能，如存储扩展、录音及播放、摄像头实时预览、人脸识别，以及屏幕背光控制等。


## 2. USB接口说明


### 2.1 USB简介
       USB：Universal Serial Bus（通用串行总线）。是一种常用于电子设备间通讯的通用标准接口。USB 总线作为一种高速串行总线，其极高的传输速度可以满足高速数据传输的应用环境要求。

       具有供电简单（可总线供电）、安装配置便捷（支持即插即用和热插拔）、 扩展端口简易（通过集线器最多可扩展127 个外设）、传输方式多样化（4 种传输模式），以及兼容良好（产品升级后向下兼容）等优点。

### 2.2 EASY EAI Nano USB资源介绍


## 3. USB-MASS-STORAGE（U盘）


## 4. TF卡

## 5. 集成声卡

## 6. 人脸识别

## 7. 屏幕背光控制





# 固件烧录与更新

## 1. 固件下载


## 2. 硬件接线讲解


## 3. 烧录工具操作


## 4. 异常情况排查


### 4.1 驱动识别异常汇总


#### 4.1.1 没有发现设备

#### 4.1.2 板卡接线连接不稳定


#### 4.2 烧录失败情况汇总

##### 4.2.1 测试失败

##### 4.2.2 烧录到一半失败。


## 5. 手动进入Loader模式



## 6. 手动进入MASKROM模式（救砖）


# EASY-EAI-Toolkit

## 硬件外设组件

### 摄像头

#### MIPI-IR摄像头

##### 1. MIPI摄像头简介

###### 1.1 MIPI CSI2 接口简介
         MIPI (Mobile Industry Processor Interface)：ARM, Nokia, ST ,TI等公司在2003年成立的一个联盟所定的接口。目的是把手机等移动设备内部的接口如：摄像头、显示屏接口、射频/基带接口等标准化，从而减少手机等移动设备设计的复杂程度和增加设计灵活性。

       工作组(Work Group)：MIPI联盟下有许多的工作组，不同的工作组负责定义对应设备的标准。其中包括有：Camera工作组、Display工作组、高速多端链接工作组等十几个工作组。

       MIPI CSI-2接口是由MIPI联盟下的Camera工作组指定的CSI(Camera Serial Interface)的第2版接口标准。硬件层面：最大支持4个虚拟通道（Lane）传输数据，1个Lane在硬件上体现就是一对差分信号线(见下方原理图)，每个Lane的最大通讯速率为2.0Gbps。软件层面：MIPI CSI-2协议栈主要由应用层、协议层、物理层组成，其中协议层又可以分为：像素/字节组包/解包层、底层协议层、通道管理层。


###### 1.2 硬件接口介绍


###### 1.3 查看设备情况

##### 2. 快速上手

###### 2.1 开发环境准备

###### 2.2 源码下载以及例程编译

###### 2.3 例程运行

###### 2.4 运行效果

##### 3. RGB摄像头API介绍

###### 3.1 引用方式
###### 3.2 RGB摄像头初始化函数
###### 3.3 RGB摄像头释放函数
###### 3.4 RGB摄像头获取图片函数
###### 3.5 RGB摄像头设置输出图片格式函数
##### 4. 测试RGB摄像头API案例
###### 4.1 打开摄像头
###### 4.2 获取图片操作
###### 4.3 保存图片操作
###### 4.4 释放摄像头操作








### 显示屏
#### 1. 概述
##### 1.1 显示技术简介
       在传统的Linux内核中一般使用fbdev(Frame Buffer)驱动框架管理图形适配器的帧缓冲器，但最初的fb应用层表现得好像单个程序占用了整个显示屏设备，当两个或多个程序试图同时控制相同的硬件时，大多数时候会灾难性地结束。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/231g6pmc81kaod3x0jhd.png)
      使用DRM驱动后，所有应用层通过libdrm或其他库函数来使用显示设备，在内核底层，DRM通过管理Buffer队列渲染图形界面，此时处于用户空间的各个应用层均没有fbdev的概念，也不会争抢显存资源。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/gzy7w7k74w15ayxpsnue.png)

##### 1.2 Nano显示控制库
#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Display简易API使用说明
##### 3.1 引用方式
##### 3.2 Display初始化函数
##### 3.3 Display 释放函数
##### 3.4 Display 提交函数



### 背光控制
#### 1. Backlight概述
EASY EAI nano的屏幕支持背光调整，设备信息如下所示。
|文件或路径|描述|
|---|---|
|/sys/class/backlight/backlight|此目录下存放系统默认的背光设备相关的设置节点|
|max_brightness|最大背光设置值，为255|
|brightness|当前的背光值，设置范围为0~255|

#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Backlight操作介绍
       EASY EAI nano封装了Backlight的操作，如下所示。
##### 3.1 引用方式
##### 3.2 设置背光函数
##### 3.3 背光设置案例
Backlight的应用案例代码为Toolkit-C-Demo/peripheral-backlight/test_bl_ctl.c，代码如下所示。
```bash
#define	BACKLIGHT	"/sys/class/backlight/backlight/brightness"
#define	LOW_LEVEL	30
int main(int argc, char *argv[])
{
	int c = 100;
	static uint16_t level = LOW_LEVEL;

	while(c--) {
		level += 10;
		if (level >= 255) {
			level = LOW_LEVEL;
		}
		printf("setting bl level:%d\n", level);
		set_backlight(BACKLIGHT, level);
		usleep(100*1000);
	}

	return 0;
}
```





### 音频输入输出
#### 1. 音频简介
#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明



### 网络配置
#### 1. 网络通讯简介
       本文档讲介绍一些最基础的网络知识，以便用户对网络通讯有一个简单的感性认知。另外为了方便用户的操作，我们也提供了一些封装好的接口，以便用户进行网络参数的配置。
##### 1.1 网络结构
 最简单的网络结构：计算机设备直连。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/fsr14njjs6b9ht3rebl1.jpg)

简单的局域网结构：
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/hfwp82kfh5fvwi3f8kyt.png)

##### 1.2 IP地址
IP（Internet Protocol，网际协议）是一种重要且主要的网络通讯协议，任务是在源地址和和目的地址之间传输数据。

IP地址（Internet Protocol Address）是给网络中每一台计算机设备分配的一个标识，以便在网络通讯时，作为数据的发出地与目的地依据。IP地址的分配有两种方式，一种是DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），该方式的IP地址分配是由提供DHCP服务的计算机设备统一管理并向启用DHCP客户机的计算机设备分配IP地址。好处是即插即用，可以不用手动分配。另外一种是静态IP地址，即IP地址需要手动分配，这种方式的好处是可通过主从IP地址技术配置多个从IP地址。情况如下图所示。(值得注意的是：一般不建议DHCP与静态IP地址混用。若非得混用的话，静态IP须作为备用IP使用，且不允许与DHCP处于同一网段。)
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/amccgb7x9a70m586cosy.png)

        IPv4地址通常的标识方式为点分十进制。就是用点把4组范围是0~255的数字分隔开，来表示一个IP地址，比如192.168.1.101。

       特殊的IP地址：xxx.xxx.xxx.1和xxx.xxx.xxx.255

xxx.xxx.xxx.1：此IP地址通常是给网关设备使用。不建议分配给普通的网络设备

xxx.xxx.xxx.255：此IP地址用作数据广播。不能分配给普通的网络设备。

       一些不在此文章展开描述的概念：

       MAC地址：此地址与网络设备(通常是网卡)一对一绑定，并且是世界唯一。

       IPv6：IPv6是英文“Internet Protocol Version 6”（互联网协议第6版）的缩写，是互联网工程任务组（IETF）设计的用于替代IPv4的下一代IP协议。


##### 1.3 网段与子网掩码
       网段（network segment），硬件层面一般指一个计算机网络中使用同一物理层设备（传输介质，中继器，集线器等）能够直接通讯的那一部分。简单地说就是计算机设备之间的硬件连接处于同一个局域网内。但仅满足这个硬件条件的两台计算机设备依然无法确保可以直接通讯，因此还需满足一个软件层面的条件：就是这两台计算机设备的IP地址，分别和各自的子网掩码作“按位与”运算，得出的值相等，如下图所示。
       ![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/rxc5v0nopweehpykkwea.png)
       处于同一网段下的计算机设备，能够直接相互ping通(没有防火墙拦截的情况下)。

       子网掩码的另一种表示法：192.168.1.202/24，192.168.205/16。这个“/24”或者“/16”就表示子网掩码。“/24”代表24位子网掩码，即255.255.255.0；“/16”代表16位子网掩码，即255.255.0.0。

##### 1.4 网关

       网关(Gateway)又称网间连接器、协议转换器。顾名思义就是“某网络结构A(如局域网)”与“互联网”之间的“关口”，这个角色通常是由路由器来充当。例如，若某台计算机设备1处于网络结构A，它想访问处于互联网中的百度知道服务器（公网IP为202.108.22.5），那么计算机设备1的网关就要填上网络结构A路由器的IP地址。如下图所示。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/de1qy8r6oyl1i8gkkf95.png)

##### 1.5 网络端口
       网络端口分为物理端口与逻辑端口两种类型。

       物理端口就是指网络设备上可以插入网络连接线的端口，如下方交换机图片所示的端口。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/7sxv7hbi49po36u3i0p5.jpg)


       逻辑端口：一种用于TCP协议或UDP协议，以及由这两种协议拓展出来的如HTTP、FTP、RTP等协议抽象出来的概念。端口号的范围是0~65535，是一个操作系统的资源，被本系统所有的IP地址共用。一旦某个端口(如80)被一个“服务”(HTTP)占用，那么另外一个服务则不能使用该端口(80)。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/5ns44onp8h55t98rpcb0.png)
       逻辑端口的划分：端口号0~65535通常被分成3大类。

       公认端口(Well Konwn Port)：从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯。

       注册端口( Registered Ports)从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的。

       动态或私有端口( Dynamic and/or Private Ports)，即私人端口号（private port numbers），是可用于任意软件与任何其他的软件通信的端口数，使用因特网的传输控制协议，或用户传输协议。动态端口一般从49152到65535。

##### 1.6 服务
       一个可以提供某种网络服务的应用进程。而且一个服务仅可以与一个IP地址和一个端口绑定。

       客户机/服务器模型：网络上进行通讯的各端点，很多时候是遵循客户机/服务器模型的。

       客户机或服务器并不是绝对地指某台计算机，而是相对而言的概念。如下图所示，计算机1能提供HTTP服务与RTSP服务；计算机2能提供HTTP服务。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/da20vjar5jp9vldtpj2y.png)

若计算机4向计算机1请求RTSP服务，那么：计算机4是客户机；计算机1是服务器。

若计算机4向计算机1请求HTTP服务，那么：计算机4是客户机；计算机1是服务器。

若计算机4向计算机2请求HTTP服务，那么：计算机4是客户机；计算机2是服务器。

若计算机2向计算机1请求RTSP服务，那么：计算机2是客户机；计算机1是服务器。

       一般来说，服务器端具有这些特征：被动通信；始终等待来自客户端的请求；自己参与通信的网络接口和端口必须确定；处理客户端的请求后将结果（响应）返回给客户端。

       而客户机：主动通信；需要发起请求；自己参与通信的网络接口和端口可以不确定；发起请求后需要等待服务器回应结果。

##### 1.7 OSI模型


       为了实现网络通讯，在操作系统层面设计了OSI模型(Open System Interconnection model，开放系统互联模型)，这是一个由国际标准化组织提出概念模型，试图提供一个使各种不同的计算机和网络在世界范围内实现互联的标准框架。

       它将计算机网络体系结构划分为七层，每层都可以提供抽象良好的接口。OSI模型各层间关系和通讯时的数据流向如下图所示。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/1tlfzagr2t2zjrhq280x.png)
       OSI模型是一个理想化的模型，实际上的网络通讯协议比如TCP/IP并不是严格按照此模型来设计。

       此处仅对OSI模型作一个简单介绍，更多的信息可从互联网自行搜索并查阅。



#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明






### TCP通讯
#### 1. TCP/IP简介
       TCP是一种可靠的，面向连接的网络传输协议，它的传输数据大小无限制。传输的是一个顺序的无差错的数据流。

       优点：能确保接收方完全正确地获取发送方所发送的全部数据。

       缺点：对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，系统也需要对每一个链接上来的客户机进行(socket)资源管理。

       常用场景：邮件通信，文件共享，下载等。
##### 1.1 层级模型
       OSI模型所分的七层，在实际应用中，往往有一些层被整合，或者功能分散到其他层去。TCP/IP协议是现在互联网络事实上的协议标准。

       TCP/IP并没有照搬OSI模型，也没有一个公认的TCP/IP层级模型。我们这里采用的是最通用的一个四层的模型，每一层都和OSI模型有较强的相关性但是又可能会有交叉。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/s6atrhxu1qu6ulsfuq16.png)

##### 1.2 通信流程

![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/fvpxchrllggt7y6h8axn.png)


#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明



### UDP通讯
#### 1. UDP/IP简介


       UDP是一种不可靠的，无连接的网络传输协议，它的每个被传输的数据报必须限定在64KB之内。传输的是一个个独立的数据报文，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。

       优点：操作简单，每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接，因此仅需要较少的监护，没有复杂的连接状态；传输速度相对TCP较快。

       缺点：必然发生数据丢包，不保证数据报的到达时间以及内容的正确。

       常用场景：音频、视频传输。
##### 1.1 层级模型
       OSI模型所分的七层，在实际应用中，往往有一些层被整合，或者功能分散到其他层去。UDP/IP协议是现在互联网络事实上的协议标准。

       UDP/IP并没有照搬OSI模型，也没有一个公认的UDP/IP层级模型。我们这里采用的是最通用的一个四层的模型，每一层都和OSI模型有较强的相关性但是又可能会有交叉。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/ge8ks1n1jbwui2u8rwxi.png)

##### 1.2 通信流程

![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/4n5ovytat9sc0wj1qo28.png)


#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明






### WIFI通讯
#### 1. WiFi通讯简介


       UDP是一种不可靠的，无连接的网络传输协议，它的每个被传输的数据报必须限定在64KB之内。传输的是一个个独立的数据报文，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。

       优点：操作简单，每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接，因此仅需要较少的监护，没有复杂的连接状态；传输速度相对TCP较快。

       缺点：必然发生数据丢包，不保证数据报的到达时间以及内容的正确。

       常用场景：音频、视频传输。
##### 1.1 工作模式
       WI-FI通常会有以下几种工作模式：Station模式(STA模式)、AccessPoint模式(AP模式)、Monitor模式、Ad-hoc模式、WDS模式、Mesh模式。
###### 1.1.1 STA模式
       STA模式，全称Station模式。任何一种无线网卡都可以运行在此模式下，这种模式也可以称为默认模式。

       在此模式下，无线网卡作为从设备，发送连接与认证消息(SSID和Password)给热点(主设备)，热点接收到后完成认证后，发回成功认证消息，此网卡就接入热点对应的无线网络。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/wh0peg9fc6jot1lqsrzk.png)

> 注：若热点设备被关闭，接入该热点的终端设备则无法相互通信。


###### 1.1.2 AP模式
       AP模式，全称：接入点（AccessPoint）模式，又称为热点模式。在一个无线网络环境中，无线热点是作为一个主设备。通过管理控制可控制的STA，从而组成无线网络。由AP形成的网络，由AP的MAC地址唯一识别。

       热点完成创建后，会由热点创建一个被别的设备可识别的名称，称为SSID。在Linux系统下，若要使用AP模式，系统必须首先支持hostapd服务，用作AP认证。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/j7xg4tlni8tegbmx7uvp.png)

###### 1.1.3 Monitor模式
       是一种类似AP模式的模式。这种模式下，所有的数据包无过滤地传输到主机，主要用于查看网络中出了哪些故障。

       在支持MAC80211的一般设备中，工作于Monitor模式下，可以有效地对整个网络进行监控；可以实现数据包的注入。

       在用户模式下，想要在应用程序中部署MLME（Media Access Control (MAC) Sublayer Management Entity）非常有用。
###### 1.1.4 Ad-hoc模式
       Ad-hoc又称为独立基本业务集，用以创建一个不需要热点（AP）的无线网络。此网络中的每个节点的地位都是对等的，就和以前的直连双绞线概念一样，是P2P的连接。此模式用以连接几个不能通过基站（AP）进行通信的电脑。一般无线终端设备像PMP、PSP、DMA等用的就是ad-hoc模式。

       由于省去了无线AP，Ad-Hoc无线局域网的网络架设过程十分简单，并且任何一台设备被关闭也不会影响其它设备之间的通讯。不过一般的无线网卡在室内环境下传输距离通常为40m左右，当超过此有效传输距离，就不能实现彼此之间的通讯；因此该种模式非常适合一些简单甚至是临时性的无线互联需求。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/woupucw8cwviyehxei5k.png)


###### 1.1.5 WDS模式
       WDS全名为无线分布式系统。以往在无线应用领域中它都是帮助无线基站与无线基站之间进行联系通讯的系统。WDS的功能是充当无线网络的中继器，通过在无线路由器上开启WDS功能，让其可以延伸扩展无线信号，从而覆盖更广更大的范围。

       WDS可以让无线AP或者无线路由器之间通过无线进行桥接（中继），而在中继的过程中并不影响其无线设备覆盖效果的功能。这样我们就可以用两个无线设备，让其之间建立WDS信任和通讯关系，从而将无线网络覆盖范围扩展到原来的一倍以上，大大方便了我们无线上网。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/cbari1yzd90vjog8zcaz.png)

###### 1.1.6 Mesh模式
       Mesh接口使设备之间动态建立路由，从而实现通信。无线Mesh网络中，任何无线设备节点都可以同时作为AP和路由器，网络中的每个节点都可以发送和接收信号，每个节点都可以与一个或者多个对等节点进行直接通信。

       这种结构的最大好处在于：如果最近的AP由于流量过大而导致拥塞的话，那么数据可以自动重新路由到一个通信流量较小的邻近节点进行传输。依此类推，数据包还可以根据网络的情况，继续路由到与之最近的下一个节点进行传输，直到到达最终目的地为止。这样的访问方式就是多跳访问。

##### 1.2 认证方式
       WI-FI的最基本的工作模式为：STA模式和AP模式。而认证动作在STA设备向AP设备建立连接时发生。认证方式通常有以下三种：无密钥认证、WEP认证以及WPA-PSK/WPA2-PSK认证，具体采用哪一种，是由工作在AP模式的设备指定。

###### 1.2.1 无密钥认证AP
       无须任何的认证动作，STA设备就能与AP设备建立连接，当然这种方式容易被非法用户窃听与入侵。
###### 1.2.2 WEP认证AP
       WEP是Wired Equivalent Privacy的简称，有线等效保密（WEP）协议是对在两台设备间无线传输的数据进行加密的方式，用以防止非法用户窃听或侵入无线网络。不过密码分析学家已经找出 WEP 好几个弱点，因此在2003年被 Wi-Fi Protected Access (WPA) 淘汰，又在2004年由完整的 IEEE 802.11i 标准（又称为 WPA2）所取代。
###### 1.2.3 WPA-PSK/WPA2-PSK认证AP
       一种比WEP更安全，目前用户WI-FI主流的加密认证方式。WPA-PSK/WPA2-PSK安全类型其实是WPA/WPA2的一种简化版别，它是依据同享密钥的WPA形式,安全性很高，设置也对比简单，合适普通家庭用户和小型企业运用。

#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明





### UART
#### 1. UART介绍
##### 1.1 EASY EAI Nano板卡的串口资源介绍
#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明


### SPI
#### 1. SPI简介
       SPI是串行外设接口(Serial Peripheral Interface)的缩写，是 Motorola 公司推出的一种同步串行接口技术，是一种高速、全双工、同步的通信总线在用户空间的应用程序中，完全可以不必理会SPI协议的详细规定。只需要按照驱动层提供给我们的操作SPI外设的操作接口函数就可以像操作linux中其他普通设备文件那样轻松的操作SPI外设了。
##### 1.1 SPI参数配置解析
       设备文件格式：/dev/spidev(bus.select)
bus：代表SPI总线号，即一组SCLK、MOSI、MISO
select：代表SPI设备号，同一条总线上用不同的片选信号区分：CS0、CS1等
       以NANO板默认SPI资源为例：启用SPI功能后，会出现下面4个设备节点（即有两条总线，四个设备）。

       /dev/spidev0.0
       /dev/spidev0.1
       /dev/spidev1.0
       /dev/spidev1.1

 

SPI通信有4种不同的模式，不同的从设备在出厂时配置模式已经固定，这是不能改变的，但通信双方设备必须工作在同一模式下，所以可以对主设备的SPI模式进行配置，通过CPOL（时钟极性）和CPHA（时钟相位）来控制主设备的通信模式。
|模式 	| CPOL |	CPHA|
|---|---|---|
|Mode0|  	0 |	0|
|Mode1|  	0 |	1|
|Mode2|  	1 |	0|
|Mode3|  	1 |	1|
时钟极性CPOL是用来配置SCLK电平的有效态的;

时钟相位CPHA是用来配置数据采样是发生在第几个边沿的。

CPOL=0表示当SCLK=0时处于空闲态，所以SCLK处于高电平时有效；

CPOL=1表示当SCLK=1时处于空闲态，所以SCLK处于低电平时有效；

CPHA=0表示数据采样是在第1个边沿，数据发送在第2个边沿；

CPHA=1表示数据采样是在第2个边沿，数据发送在第1个边沿；

【*】SPI主模块和与之通信的外设通信时，两者的时钟相位和极性应该保持一致。

 

（3）其余的参数如：speed：通信的比特率，delay：设置通信的时间延迟，bits通信所占的位数。



#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明






### I2C
#### 1. IIC简介
       IIC又简写成I2C，是一种串行通信总线，使用多主从架构。

       最初设计目的为了让主板、嵌入式系统或手机用来连接低速周边设备。多用于小数据量的场合，有传输距离短，任意时刻只能有一个主机等特性。

       在Linux嵌入式应用开发的情景下，完全可以不必理会IIC协议的详细规定。只需要按照驱动层提供给我们的操作IIC外设的操作接口函数就可以像操作linux中其他普通设备文件那样轻松的操作IIC外设了。

##### 1.1 EASY EAI nano开发的IIC资源
#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明




### GPIO
#### 1. GPIO简介
##### 1.1 EASY EAI Nano硬件资源分布介绍
##### 1.2 gpiod 简介
       在Linux 4.8开始，加入了libgpiod的支持，而原有基于sysfs的访问方式，将被逐步放弃。因此本文对应的demo主要采用了gpiod方式控制GPIO。gpiod库通过操作chip对象以及line对象，来达到控制GPIO引脚输出电平，或者读取GPIO引脚电平的目的。

       Chip对象名：在调用gpiod_chip_open_by_name获取chip对象时，作为传入参数使用。

       Line偏移量：在调用gpiod_chip_get_line获取line对象时，作为传入参数使用

       以GPIO3_B2为例，【引脚名称】【Chip对象名】【Line偏移量】三者之间的关系如下方公式所示。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/tbf253yyvma2gyut8bgu.png)
       而EASY EAI Nano的GPIO库对libgpiod采取了更进一步的封装，省去了偏移量的计算，以及使接口变得更加易用。若用户有阅读或修改源代码的需要，可以克隆以下仓库，查阅对应的位置：


##### 1.3 sysfs访问方式简介
       sysfs控制gpio的方式主要基于内核提供的gpio控制接口文件。也就是通过读写/sys/class/gpio目录下的文件来控制对应的gpio接口。

       pin脚编号：sysfs访问方式均以pin脚编号作为操作依据。

       GPIO系统节点路径：具体的GPIO引脚所对应的节点路径。

       以GPIO3_B2为例，【引脚名称】【GPIO系统节点路径】两者之间的关系如下方公式所示。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/80icypua6c6f87q46yd0.png)

```bash
# 引脚的导出申请：某一引脚在使用前，需要手动向gpio管理器申请导出该引脚资源。
echo 106 > /sys/class/gpio/export       ## gpio_request         申请导出相应的gpio

# 设置该引脚的工作模式：输入或者输出。
echo in > /sys/class/gpio/gpio106/direction        ## gpio_direction_output 设置相应gpio为输入方向
## 或者
echo out > /sys/class/gpio/gpio106/direction      ## gpio_direction_output 设置相应gpio为输出方向

# 根据引脚的工作模式，做相应的控制：写入电平或读取电平。
cat /sys/class/gpio/gpio106/value                        ## gpio_get_value       获取gpio当前状态值
## 或者
echo 0 > /sys/class/gpio/gpio106/value               ## gpio_set_value       设置输出低电平
echo 1 > /sys/class/gpio/gpio106/value               ## gpio_set_value       设置输出高电平

# 引脚的释放申请：引脚使用完毕后，需要手动向gpio管理器申请释放该引脚资源。
echo 106 > /sys/class/gpio/unexport   ## gpio_free              释放申请的gpio


```

#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明




### PWM
#### 1. PWM简介
       pwm驱动加载成功后，在/sys/class/pwm/下会产生pwmchip1目录，向export文件写入0，就会打开pwm定时器，会产生一个pwm0目录。相反往unexport文件写入0，就会关

       闭pwm定时器，同时pwm0目录会被删除。

##### 1.1 EASY EAI nano的PWM资源
#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明





### CAN
#### 1. CAN简介
       使用Socket CAN的主要目的就是为用户空间的应用程序提供基于Linux网络层的套接字接口。与广为人知的TCP/IP协议以及以太网不同，CAN总线没有类似以太网的MAC层地址，只能用于广播。CAN ID仅仅用来进行总线的仲裁。因此CAN ID在总线上必须是唯一的。当设计一个CAN-ECU(Electronic Control Unit 电子控制单元）网络的时候，CAN报文ID可以映射到具体的ECU。因此CAN报文ID可以当作发送源的地址来使用。

##### 1.1 EASY EAI nano的CAN资源
#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明



### 看门狗
#### 1. 看门狗简介
       硬件看门狗是利用一个定时器电路，其定时输出连接到电路的复位端，程序在一定时间范围内对定时器清零(俗称“喂狗”)，因此程序正常工作时，定时器总不能溢出，也就不能产生复位信号。如果程序出现故障，不在定时周期内复位看门狗，就使得看门狗定时器溢出产生复位信号并重启系统。

##### 1.1 EASY EAI nano的CAN资源
#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明




## 多媒体组件

### 编解码-流媒体解码器
#### 1. 流媒体解码器简介
       流媒体(Streaming Media)技术是指将一连串的媒体数据压缩后，以流的方式在网络中分段传送，实现在网络上实时传输影音以供观赏的一种技术。

       流媒体实际指的是一种新的媒体传送方式，有音频流、视频流、文本流、图像流、动画流等。每一种流媒体，都有其独特的编码格式。多媒体文件，则是一个把多种流媒体组装起来的文件，这种组装多种不同流媒体编码的格式则被称为封装格式。比如：

       封装格式：avi、rmvb、mp4、mp3、flv、mkv、wmv等。

       编码格式：视频编码格式（H.264、H.265等），音频格式（AAC、mp3等）。

##### 1.1 视频编解码器原理
       视频解码器就是把视频编码格式的文件数据，解码成工程师更容易操作的图像数据，视频编解码的工作原理如下所示：
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/o2thmkpf2dhvtusr5del.png)
       EASYEAI-Nano的解码器可以初始化出多个解码通道，每个通道都能独立工作，将NAL数据推进解码通道中，每个通道最后都能独立输出YUV图像。

       解码器输入数据的两种方式：

       方式①：在同一进程内采集原始数据，送入解码器。

       方式②：在一个进程内实现解码，在另一进程进行数据采集，通过共享内存（流媒体环形队列）进行数据传输。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/n135ddbh2luaihyvg684.png)

EASYEAI-Nano的流媒体解码器，性能如下所示：

|组成 |	参数 |	描述 |
| ---| --- | --- |
|输入内容 |	支持格式 |	VDEC_CHN_FORMAT_H264 |
| |	 |	 VDEC_CHN_FORMAT_H265|
|        | 输入数据形式 | 数据流形式(读文件)传入或NALU形式(网络摄像头)传入 |
|视频解码性能|常用解码分辨率|4路1920 x 1080@30 fps|
||最大解码分辨率| 	3840 x 2160|
||最大解码能力|3480 x 2160@30 fps|
||最大解码通道数量|最大不超过16路同时解码|
|输出内容| 	YUV格式|VFRAME_TYPE_NV12|



##### 1.2 输入数据：H.264简介

       H.264文件，或者H.264流数据，是由一个个NAL单元组成，NAL单元结构如下图所示。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/icrn5czlwruua0q09onq.png)
       NAL头为0x00 0x00 0x00 0x01 0x??：第5个字节0x??，用于表示该NAL单元类型，有SPS、PPS、IDR等。例如：

       0x67(SPS)：序列参数集。里面的data携带了各种因子、宏块切片宽度、高度和标志位等信息，可间接用于计算分辨率，帧率等。

       0x68(PPS)：图像参数集。里面的data标记了图像编码具体应用了什么算法、指明亮度分量、SP和SI的量化参数初始值等信息。

       0x65(IDR)：即时解码刷新帧。里面的data是一个完整的I帧数据，单凭该NAL单元即可解码出一帧完整的YUV图像。同时，该帧为即时刷新帧，该帧数据被送入解码器后。解码器会自动丢弃前面的参考帧数据，并且会即时输出该帧解出来的YUV数据。

       0x41：非IDR参考帧。普通的参考帧。

……

       以下使用我们的toolkit包内的示例文件来查看H.264的文件格式。示例文件为：EASY-EAI-Toolkit-C-Demo/media-endeCode_api/tc10.264。


##### 1.3 输出数据：YUV简介
       当前解码器输出的图片格式为YUV420SP_NV12，YUV数据格式由三种数据构成：灰度值数据(Y)、蓝色分量数据(U)，红色分量数据(V)。数据内容如下所示。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/wieimp4rr88zhdypnjvt.png)

#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明




### 编解码-流媒体编码器
#### 1. 流媒体编码器简介
       流媒体(Streaming Media)技术是指将一连串的媒体数据压缩后，以流的方式在网络中分段传送，实现在网络上实时传输影音以供观赏的一种技术。

       流媒体实际指的是一种新的媒体传送方式，有音频流、视频流、文本流、图像流、动画流等。每一种流媒体，都有其独特的编码格式。多媒体文件，则是一个把多种流媒体组装起来的文件，这种组装多种不同流媒体编码的格式则被称为封装格式。比如：

       封装格式：avi、rmvb、mp4、mp3、flv、mkv、wmv等。

       编码格式：视频编码格式（H.264、H.265等），音频格式（AAC、mp3等）。

##### 1.1 视频编编码器原理
       视频编码器就是把能直接操作显示的图像，编码成体积更小的视频编码格式数据，以便在网络传输节省带宽资源，或在存储时节省存储空间，视频编码的工作原理如下所示：
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/pab5sv79jcgid2zyu08r.png)
       EASYEAI-Nano的编码器可以初始化出多个编码通道，每个通道都能独立工作，将YUV格式的一帧帧图像推进编码通道中，每个通道最后都能独立输出NAL单元。

       EASYEAI-Nano的流媒体编码器，性能如下所示：

|组成| 	参数| 	描述|
| ---| ---| ---|
|输入内容| 	YUV格式| 	VFRAME_TYPE_NV12|
|视频编码器 	|最大编码能力| 	3480 x 2160@30 fps|
| |最大编码分辨率| 	3840 x 2160|
| |最大编码通道数量| 	不超过16路同时编码|
|输出内容 	|支持格式| 	VDEC_CHN_FORMAT_H264|
|||VDEC_CHN_FORMAT_H265|

##### 1.2 输入数据：YUV简介
       当前解码器输出的图片格式为YUV420SP_NV12，YUV数据格式由三种数据构成：灰度值数据(Y)、蓝色分量数据(U)，红色分量数据(V)。数据内容如下所示。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/wieimp4rr88zhdypnjvt.png)

##### 1.3 输出数据：H.264简介

       H.264文件，或者H.264流数据，是由一个个NAL单元组成，NAL单元结构如下图所示。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/icrn5czlwruua0q09onq.png)
       NAL头为0x00 0x00 0x00 0x01 0x??：第5个字节0x??，用于表示该NAL单元类型，有SPS、PPS、IDR等。例如：

       0x67(SPS)：序列参数集。里面的data携带了各种因子、宏块切片宽度、高度和标志位等信息，可间接用于计算分辨率，帧率等。

       0x68(PPS)：图像参数集。里面的data标记了图像编码具体应用了什么算法、指明亮度分量、SP和SI的量化参数初始值等信息。

       0x65(IDR)：即时解码刷新帧。里面的data是一个完整的I帧数据，单凭该NAL单元即可解码出一帧完整的YUV图像。同时，该帧为即时刷新帧，该帧数据被送入解码器后。解码器会自动丢弃前面的参考帧数据，并且会即时输出该帧解出来的YUV数据。

       0x41：非IDR参考帧。普通的参考帧。

……

       以下使用我们的toolkit包内的示例文件来查看H.264的文件格式。示例文件为：EASY-EAI-Toolkit-C-Demo/media-endeCode_api/tc10.264。


#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明



### 流媒体环形队列
#### 1. 流媒体环形队列简介
        本队列为一条专用于进程间传输流媒体数据（具体为视频流、音频流）的环形队列，特此进行详细说明。

        流媒体环形队列工作原理：
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/gw7zfzdeynysg8g4caqp.png)
       流媒体环形队列特性：

         1. 环形队列可被本api创建多条，每条队列由一片连续的共享内存构成。

         2. 共享内存不会因进程结束而释放

         3. 无论处于哪一条进程，只需要队列ID相同则是同一条队列。

         4. 本队列仅适用于写入H264、H265、AAC格式数据。

       该组件为编/解码器的辅助组件，此文档用于辅助说明编/解码器的跨进程用法。因此本组没有单独的应用实例。


#### 2. 流媒体队列API说明
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明



## 网络协议组件

### http/https
#### 1. HTTP/HTTPS简介
       HTTP（全称：Hyper Text Transfer Protocol，超文本传输协议）是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器请求和应答标准，用于从WWW服务器传输超文本到本地的传输协议。

       而HTTPS（全称：Hyper Text Transfer Protocol over SecureSocket Layer）是以安全为目标的HTTP通道，在原有HTTP的基础上通过传输加密和身份认证（即增加SSL/TSL安全访问协议）保证了传输过程的安全性。

##### 1.1 HTTP和HTTPS的区别
      HTTP和HTTPS的区别如下所示。
|协议 |	HTTP |	HTTPS |
| --- | --- | ---- |
|CA证书 |	不需要 | 	需要 |
|传输加密方式 |	明文传输，无加密  |	SSL/TSL加密传输 |
|连接方式 |	端口号使用80 |	端口号使用443 |
|连接方式 |	无状态的 |	由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议|



##### 1.2 请求和响应

       典型的HTTP/HTTPS通讯就是应用在浏览器与网页服务器之间，浏览器即为客户端，负责发出请求，接收报文，渲染显示效果。网页服务器即为服务器，负责应答请求，管理服务器文件、处理具体业务。而在某些情况中，HTTP可以作为信息交换的通讯规则。

       客户端需要资源时发送出来的即为请求报文，服务器接收到请求后向客户端返回的就是响应报文，HTTP规定了请求报文和响应报文的格式。

       请求报文格式如下所示。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/pqpfo6fcczy53migq9ks.png)
对于本文而言，我们主要关注请求方法和URL即可。


||请求行|
|---|---|
|报文元素| 	描述|
|请求方法 |	常见的方法有：
GET：用于检索和获取服务器的资源，请求内容会在URL上显示；
POST：用于创建或更新服务器的内容，请求内容不会在URL上显示，而是在显示在主体内。|
|URL |	服务器的虚拟文件路径，将在下面章节重点介绍。|

响应报文示例如下所示，主要组成部分有：

    状态行（包含协议版本、状态值、状态短语）；
    响应消息头（以键值对的形式存在，例如时间、数据类型、数据长度等）；
    空行（用于区分报文头和响应正文）；
    响应正文（对于网页而言，常见的是html代码，也可以是音视频文件、图片，通常是消息报头的Content-Type指定）。

![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/hbihsfa4s2zh7o7nxc9h.png)













##### 1.3 URL
       假设我们搭建了一个环境检测服务器系统，用于采集、记录全市各个观测点的环境数据，假定服务器的存放结构如下所示，此服务器在公网上的域名为www.huanjin.com，里面有两个设备，每个设备存放了不同日子的气温数据，当客户端需要调取具体设备具体数据时，则需要提交一个唯一的路径给服务器查找，这个唯一路径就是URL。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/olup7qq010j1wt7djd4l.jpg)

       URL（Uniform Resource Locator，统一资源定位符），存放在请求报文的请求行内，充当路标作用。当我们浏览网页时，点击进入不同的组件，浏览器就会自动的帮我们填充不同的URL，地址的构成如下所示。完整的URL包含：协议部分、网址部分、文件地址
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/y21bvqqiun4uir12xn15.jpg)
具体内容如下所示。

|组成部分 |	描述|
| --- | --- |
| 协议 |	以“//”分割，常见的有http和https；|
| 网址 |	是公网上独一无二的域名，即人们常见的www.baidu.com等 |
| 文件地址 |	从域名后的第一个“/”到最后一个“/”前的内容，被称为虚拟目录
从最后一个“/”后到“#”前，即为文件名 |


       例我们想获取环境检测服务器中设备1的12月25号数据，填写的请求报文就是，GET请求，URL为“http://www.huanjin.com/Device-1/日期数据/2021122”。

       URL还可以携带变量信息，名称为URL查询字符串，形式为：
```
https://www.Adblock.com/s?a=123&b=234
```
       变量存放在URL结尾处，以“？”开头，以“参数名=值”的键值对形式存放，多个参数用“&”分割。

##### 1.4 HTTPS使用要点
       通过以上叙述可知，使用HTTPS需要时刻围绕以下几点：

- CA证书，HTTPS协议用SSL/TSL；  
- 发送数据使用POST请求，服务器地址使用URL格式表示；  
- 接收数据、文件使用GET请求，服务器地址使用URL格式表示；  

       我司的easyeai-api软件开源库将复杂的报文格式、收发操作做了统一的封装，为客户提供简单便捷的调用方式实现HTTP/HTTPS通讯功能。



#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明













### mqtt
#### 1. MQTT简介
MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的“轻量级”通讯协议。MQTT最大优点在于，用极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。

##### 1.1 发布和订阅
       MQTT使用的发布/订阅消息模式，它提供了一对多的消息分发机制，从而实现与应用程序的解耦。这是一种消息传递模式，消息不是直接从发送器发送到接收器（即点对点），而是由MQTT server（或称为 MQTT Broker）分发的。

- 在MQTT通讯过程中，有三种身份，分别是发布者（publisher）、代理（broker）、和订阅者（subscriber）。  
- MQTT传输的消息分为：主题（topic）和负载（payload）两部分。  
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/2j5de5zkuyil7o9hutdr.png)

       发布者向代理（MQTT Broker）发布topic的消息，代理将该消息推送到所有订阅该topic的订阅者。

   * 发布消息的客户端就是发布者，订阅topic消息的客户端就是订阅者


##### 1.2 服务质量QoS（Quality of Service levels）

       服务质量是 MQTT 的一个重要特性。当我们使用 TCP/IP 时，连接已经在一定程度上受到保护。但是在无线网络中，中断和干扰很频繁，MQTT 在这里帮助避免信息丢失及其服务质量水平。
###### 1.2.1 QoS 0
       至多一次，消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/f1sr0x8dg9121o5rwqix.png)

###### 1.2.2 QoS 1
       至少一次，确保消息到达，但消息重复可能会发生。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/5xvrx5bex13u425l1rsi.png)

###### 1.2.3 QoS 2
       只有一次，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/w1rm8u9oyzuwy5udd3pt.png)
* 带有唯一消息 ID 的消息会存储两次，首先来自发送者，然后是接收者。QoS 级别 2 在网络中具有最高的开销，因为在发送方和接收方之间需要两个流.


##### 1.3 环境搭建
       介绍完基础理论部分，下面在Windows平台上搭建一个MQTT Server代理程序，板卡做为发布者和订阅者做为进行简单的数据收发验证，整体架构如下图所示。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/7g4ifq6rajhhdt56uaeq.png)

* 本例程使用EMQX代理服务器进行演示，部署过程参考https://www.emqx.io/zh


#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明




### rtsp
#### 1. RTSP协议简介


         RTSP（Real Time Streaming Protocol），实时流传输协议，RTSP对流媒体提供了诸如暂停，快进等控制，而它本身并不传输数据，RTSP的作用相当于流媒体服务器的远程控制。它的语法和运作跟HTTP 1.1类似，但并不特别强调时间同步，所以比较能容忍网络延迟。但它与HTTP不同的一点是，RTSP需要保持链接。

       【流媒体服务器】：提供流数据的一端，为发送端。
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/rph5j7802zb2e38oy0gh.png)
       【流媒体客户端】：向服务器拉取流数据的一端，为接收端。

          由于本例程用于网络摄像头的实时取流，因此不具备对流媒体服务器远程控制的能力，本文档不讨论控制功能。

         本例程简要流程图：
![](http://easy-eai-official-website.oss-cn-shenzhen.aliyuncs.com/sjv00mm9dcnmv4k8teg8.png)


#### 2. 快速上手
##### 2.1 开发环境准备
##### 2.2 源码下载以及例程编译
##### 2.3 例程运行
##### 2.4 运行效果
#### 3. Audio函数库使用说明





## 通用组件
### BASE64编解码
### INI文件操作
### JSON格式处理
### 二维码生成
### 数据校验
### 系统操作-时间参数
### 系统操作-线进程操作
### 进程间通信
### 字符串操作
### 字库引擎



## AI算法组件
### 人脸检测
### 人脸识别
### 人脸98点关键点
### 人员检测
### OCR文字识别
### 火焰检测
### 人手检测
### 安全帽检测
### 吸烟检测
### 打电话检测
### 车辆检测
### 人脸姿态估计
### 二维码识别
### 口罩识别





# 开发实例
## 人脸检测方案
## 人脸识别方案
## 人员检测方案
## 驾驶员行为检测方案
## 安全帽检测方案
## 自学习图像分类方案
## 二维码识别方案
## 多路网络摄像头取流方案
## 网络摄像头方案


# GUI开发实例
## 最简单的UI方案
## 人脸识别门禁系统解决方案
## 人员检测方案
## 驾驶员行为检测方案
## 安全帽检测方案
## 自学习图像分类方案
## 二维码识别方案
## 多路网络摄像头取流方案
## 网络摄像头方案



# 应用笔记
## 虚拟机扩容
## 虚拟机Ubuntu操作介绍
## 启动logo更换方法
## 开发板网络配置方法
## 用户应用程序保护方案
## 系统温度获取
## 按键测试方法与例程
## 板卡Docker环境部署方法
## webEnging部署方式
## 百度飞桨PaddlePaddle部署方案





# 在EASY EAI Nano运行自定义的AI算法
## AI算法开发流程
## 模型转换环境搭建
## 模型转换示例
## 模型转换API说明
## 模型部署示例
## 模型部署API说明


# 第三方商用算法适配

## 人脸识别算法
### 虹软
### 旷视

## 文字识别算法
### 薪火


# 硬件设计
## 最小系统
## 开关机电路
## MIPI CSI
## MIPI DSI
## 以太网
## WiFi+蓝牙
## TF卡
## 音频电路
## USB电路
## 电源电路



# 嵌入式底层开发

## 开发简介

### 1. 嵌入式底层开发介绍
       嵌入式底层开发通常指的是：uboot、kernel、rootfs开发。

       Uboot：（Universal Boot Loader，通用引导加载器）是一个主要用于嵌入式系统(Kernel，内核)的引导加载程序，可以支持多种不同的计算机系统结构，包括ARM、AVR32、x86与Nios等。是遵循GPL条款的开放源码项目。

       Kernel：Linux内核，它是一个用C语言写成，符合POSIX标准的类Unix操作系统。通过对CPU资源进行时分复用，实现了多进程管理和调度；通过各种子模块，实现了对内存、磁盘等资源的管理和调度；通过给各种外设编写设备驱动，以及修改设备树，实现了外设与Linux系统的交互。其实嵌入式内核开发的大部分工作，就是对外设资源的增、删、改，通常就是通过“开发设备驱动”和“修改设备树”完成。

       Rootfs：（Root file system，根文件系统）是内核启动时所mount的第一个文件系统。文件系统是对一个存储设备上的数据和元数据进行组织的机制。这种机制有利于用户和操作系统的交互。

## 内核驱动

### 内核开发流程说明

#### 1. 内核开发环境准备
    内核编译无须进入EASY-EAI编译环境。但首先要确保开发环境为Ubuntu为18.04以上的版本。

       然后，对apt-get进行更新

```bash
sudo apt-get upgrade
```
最后，执行以下命令：
```bash
sudo apt-get install repo git-core gitk git-gui u-boot-tools \
device-tree-compiler gcc-aarch64-linux-gnu mtools parted libudev-dev \
libusb-1.0-0-dev python-linaro-image-tools linaro-image-tools autoconf \
autotools-dev libsigsegv2 m4 intltool libdrm-dev curl sed make binutils build-essential \
gcc g++ bash patch gzip gawk bzip2 perl tar cpio python unzip rsync \
file bc wget libncurses5 libqt4-dev libglib2.0-dev libgtk2.0-dev libglade2-dev \
cvs git mercurial rsync openssh-client subversion asciidoc w3m dblatex graphviz \
python-matplotlib libc6:i386 libssl-dev expect fakeroot cmake lib32gcc-7-dev \
g++-7 libstdc++-7-dev liblz4-tool flex bison

```
注1：不同版本的ubuntu包名字可能不同，要根据实际情况来更换对应包名字。

注2：ubuntu-20.04没有repo包，可以改用其它方式安装或不安装。

注3：后面的所有操作，建议均在家目录内操作，否则会因为权限原因导致各种问题。

#### 2. 编译出内核

##### 2.1 下载内核源码和编译脚本
首先，在虚拟机后台终端，执行以下命令，创建外设单例源码管理目录：
```bash
mkdir -p ~/EASY-EAI-kernel
```
##### 2.2 放置解压内核源码

##### 2.3 编译操作

##### 2.4 编译结果

#### 3. 烧录内核文件到板卡


##### 3.1 初始镜像问题

##### 3.2 烧录工具下载

##### 3.3 烧录工具部署

##### 3.4 利用烧录工具烧录镜像


### LCD
### RTC
### PWM
### UART
### CAN
### Ethernet
### ADC
### GPIO
### 导出内核镜像

## 文件系统依赖库安装



# 量产指导

## 硬件量产指导
## 软件量产指导
### 导出文件系统镜像
### 固件批量烧录

# AI教程
## yolov5训练部署教程
## ncnn移植
## labelimg安装与使用
## resnet50训练部署教程








<!-- [EASY EAI nano](https://www.easy-eai.com/document_details/3/143) -->