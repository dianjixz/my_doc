<center>嵌入式 Linux 软件值南</center>

# 序言

# 目录



# 第一章：Linux 概论

## 1. Linux 操作系统历史

### (1)、创世纪的 UNIX

描述历史就是追溯鸡生蛋，蛋生鸡的过程。追溯 Linux 的历史，公认的开始是 UNIX 的诞生。

UNIX 操作系统是由肯•汤普森（Ken Thompson）和丹尼斯•里奇（Dennis Ritchie）合作创造的。关于 UNIX 的部分技术思路则是来源于当时的大型机 Multics 工程计划，该计划是由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是取代当时的批处理操作系统，拥有多道程序的分时处理能力，能够同时为多个机构和公司提供计算支持。这个愿望是非常美好的，美好到以至于目标太过于庞大与空洞，导致 Multics 的开发人员都不知道该做成什么样子才能满足公司对这个工程的要求，所以计划失败了。Multics 虽然失败了，肯•汤普森的故事还在继续。

肯•汤普森出于自己的需求在 Multics 失败后，决定编写一个较小的操作系统来替代 Mutics。肯参考了 Mutics 中的一些功能设计，编写出了一个能够满足基本功能的分时操作系统。同组人员为了调侃这个只支持两个用户的系统便称这个系统为 UNICS（Uniplexed Information and Computing System）。后来，随着 UNICS 这个名字的传播，谐音的 UNIX 明显更受大家欢迎，于是这个分时系统被正式命名为 UNIX 。

UNIX 最初是由汇编编写的，运行在上面的一些应用则是由 B 语言和汇编语言混合编写而成。由于 B 语言在进行系统编程时总是处处受挫，所以汤普逊和里奇对其进行了改造和扩展，完成后的语言和原来的 B 语言差异较大，所以被命名为 C 语言。C 语言的高效和强大使得编写操作系统变成了可能。汤普逊和里奇在 1973 年中用 C 语言重写了 Unix ，这个首次不是用汇编编写的操作系统成为了当时操作系统届最大胆的创新，也非常具有革命意义。C 语言的简洁紧凑、易移植、易读、易修改的特性赋予了 UNIX 强大的生命力，为 UNIX 的发展奠定了坚实的基础。

1974 年，汤普逊和里奇合作在 《ACM通信》上发表了一篇关于 UNIX 的文章《The UNIX Time-Sharing System》。这篇文章系统的介绍了 UNIX 的目标与实现，UNIX 特性：采用 C 高级语言编写、简单的用户交互 Shell 、高效便捷的树形文件系统、文件，设备，设备的统一处理、内核和核外程序的有机组合、丰富的系统程序。当时计算机大多还处于批处理阶段，所以这样的系统迅速的在计算机存在的地方运行了起来。

UNIX 的流行和发展并没有给诞生它的 AT&T 公司带来多少利益，但是 AT&T 却在 UNIX 中做了不少的投入。为了取得回报，1982年，AT&T 基于版本 7 开发了UNIX System Ⅲ 的第一个版本，这是一个商业版本仅供出售。同时这个新的 UNIX 商业发布版本不再包含源代码。

UNIX 的哲学 KISS（keep it simple, stupid）成为了程序开发的基础哲学之一。

### (2)、UNIX 与 MINIX

20世纪80年代，由于 AT&T 所有的 UNIX 版权的限制和闭源的操作，荷兰的 Andrew S. Tanenbaum 教授在 1987 年决定写一个不包含任何 AT&T 源代码的 UNIX 系统，名为 MINIX（即小型的 UNIX ），并开放全部源代码给大学教学和研究工作，Minix 于 2000 年重新改为BSD授权，成为自由和开放源码软件，为全球注册商标。

MINIX 属于微内核，对于宏内核的 UNIX 来说，它的内核更小，提供的功能也仅限于线程管理，内存管理和进程间通信。其余的如文件系统，设备驱动等，都是由多进程的组件提供。这种驱动由进程隔离的方式使得系统的各种服务不会相互的影响，同时缺点也是致命致命的，频繁的系统调用会造成频繁的进程切换，而系统切换带来的性能损失也是不不可忽略的。

MINIX 的设计目标就是用于大学的教学和研究，所以作为它的开发者 Andrew S. Tanenbaum 教授不愿意在这个系统上添加过多的功能。由此也被称为 MINIX 的独裁者。 MINIX 的诞生在计算机历史上并没有掀起多大的波浪，但是它为计算机的教育事业作出的贡献确实巨大的。MINIX 之父 Andrew S. Tanenbaum 的经典之作《操作系统设计与实现》，给 Linux 操作系统的创造者 Linus Torvalds 带来了很大的启发，而 Linux 给世界带来了巨大的改变。

### (3)、LINUX

#### 背景

在同一时刻，操作系统届有着百花切放，百家争鸣的现状。MINIX 虽然也开源，但是其教育系统的特性不愿意添加太多的代码，使其一直停留不前。同为微内核 GNU Hurd 内核由于设计的激进也是迟迟的难产。由 UNIX 衍生出的各种 UNIX 系操作系统大多是闭源的，BSD 虽然为开源系统，但其和 UNIX 的司法官司一直打到了 1994 年 1 月。这桩法律诉讼将BSD后裔的开发，特别是自由软件，延迟了两年，这导致没有法律问题的 Linux 内核获得了极大的支持。Linux 跟 386BSD 的开发几乎同时起步，Linus 说，当时如果有自由的基于 386 的 Unix-like 操作系统，他就可能不会创造 Linux 。

#### 诞生

Linux 内核最初是由林纳斯•托瓦兹（Linus Torvalds）在赫尔辛基大学读书时出于个人爱好而编写的，当时他只是觉得教学用的迷你版 UNIX 操作系统 Minix 太难用了，也可能是出于实用主义。于是决定自己开发一个操作系统。第 1 版本于 1991 年 9 月在 MINIX 的新闻组论坛上发布，当时仅有 10000 行代码。刚开始只有很少的操作系统爱好者在讨论这个系统，并为这个操作系统编写补丁和更多的支持。随着 Linux 在爱好者的支持下，系统越发的完善，论坛上讨论 Linux 的声音也越来越多。渐渐最初的 MINIX 论坛上只剩下讨论 Linux 的声音了。Linux 最初的名字叫 FreaX ,寓意“自由”以及“奇特”,最后带上了一个常用字母X作为结尾,类似与 Unix 之类的系统一样。但是后来以为管理员觉得 FreaX 不好听,而且难念,所以就改成了 Linux ,前面直接取自开发者 linus ,加上 X 后缀就成了 。

#### 特性

继承于 UNIX 的传统，标准的 POSIX 操作系统接口，开源的特性以及合适的操作系统空窗期让 Linux 在全世界快速的流行起来。随着全世界的工程师的参与，Linux 具备了一个现代操作系统所有的属性：多用户、多任务、多线程、多 CPU、硬件管理、网络链接、可移植。而在其之上的各种应用软件生态覆盖了各行各业。Linux 运行在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。

严格来讲，Linux这个词本身只表示 Linux 内核，但实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统。

Linux 是一个开源系统，开源也是 Linux 最大的优势。林纳斯•托瓦兹没有保留 Linux 源代码的版权，在公开源码的同时欢迎任何人给 Linux 提供修改代码。同时 Linux 也是免费的，意味着你可以不花一分钱就可以使用到 Linux 强大的操作系统和完善的软件生态。为了更好的管理和协作，Linux 加入了自由软件基金会，有自由的 GPL 许可证。

- 性能稳定
- 免费使用
- 自由传播
- 多用户
- 多任务
- 支持多线程
- 多CPU
- 多用户网络
- 基于POSIX和Unix
- 支持32位和64位硬件
- 继承了Unix以网络为核心的设计思想
- 能运行主要的Unix工具软件、应用程序和网络协议

#### 官方吉祥物

1996年，Torvalds 为 Linux 选定了企鹅作为它的吉祥物。Larry Ewing 提供了吉祥物的初稿。为什么是一只企鹅，据说是因为 Linus 小时候被企鹅咬过，也有解释是企鹅是南极洲的标志性动物，根据国际公约，南极洲为全人类共同所有，不属于世界上的任何国家，任何国家都无权将南极洲纳入其版图。Linux 选择企鹅图案作为 Logo，其含义是：开放源代码的 Linux 为全人类共同所有，可公司无权将其私有。

![](https://pic4.zhimg.com/80/v2-936b11fb628712db171781e13babe647_720w.webp)


#### 社区

Linux 拥有庞大的社区和社区人员，在社区人员只上有相对于 Linux 各个组件的管理员，管理员上是 Linux 的裁定者 Linus。如同 Linux 的树形文化一样，Linux 社区也呈现出完全树型的结构。层层的管理级别并没有拖乱 Linux 的发展进度，Linux 内核可以让所有人参与进来，非常严谨，只要有错误，任何人都可以修改它。在 Linux git 仓库中的 commit 号为 690b0543a813b0ecfc51b0374c0ce6c8275435f0 的补丁就是一位小女孩提出的。

![](https://www.linuxprobe.com/wp-content/uploads/2020/01/four-years-linux-01.png)

虽然只是添加了一个字符，但是更改的理由是补丁作者的女儿发现那个 「 s 」字母很孤单，用她的话说是不开心，加上「 - 」后就显得开心了。最终 Linus 同意了这个补丁的合并请求，因为 Linux 是严谨的，人人可参与的。

Linux 的社区非常的活跃，全世界的开发者都在为 Linux 的驱动做着贡献。Linux 的可移植性使得 Linux 往往会被很快的移植到新的 CPU 设备中。就这样硬件成就着软件，软件也在成就着硬件。
#### 历史

- 1983年：Richard Stallman创建了以创建一个自由的操作系统为目标的GNU计划。

- 1989年：Richard Stallman撰写了第一版的GNU GPL。

- 1991年：第一个版本0.0.2发布，代码只有约一万行
- 1992年：Linux0.96拥有4万行代码，大约1000人使用且大部分是黑客
- 1993年：Linux0.99发布，代码量10万行，用户约2万，采用GUN的GPL协议
- 1994: 3月, Torvalds认为内核的所有组件已经完全成熟，他放出了Linux的1.0版本。XFree86项目组提供了一个图形化用户界面（GUI）.同年Red Hat公司 和SUSE 发行了他们各自的Linux 1.0分发版本。
- 1995: Linux被移植到DEC Alpha和Sun公司的SPARC平台上，而在接下来的几年里它又被广泛地移植到更多的平台上。
- 1996: Linux内核2.0版本发布。此时内核已经支持多处理器，因而成为各大公司的绝佳选择。
- 1998：很多大公司，诸如IBM, Compaq ，Oracle表示支持Linux系统。另外，一部分程序员开始了图形化用户界面KDE的开发。
- 1999：一些程序员开始致力于开发图形化环境GNOME，它可以替代依靠Qt工具包才能工作的KDE。在这一年里IBM宣布了一项支持Linux的浩大的工程。
- 2004: XFree86小组分裂，同现有的X Windows标准组织 共同成立[http://X.Org](https://link.zhihu.com/?target=http%3A//X.Org)基金会，促使了X Window ServerLinux版本极其快速而迅猛的发展。

![](https://pic3.zhimg.com/80/v2-0f9b725e91a49106a6b55bb4ebd91d8a_720w.webp)

![](https://pic4.zhimg.com/80/v2-f3da4e95700ef4eb7d0cea8d003f7f17_720w.webp)

![](https://pic3.zhimg.com/80/v2-b6f0db275df13e21d5a3fbd84a263802_720w.webp)


#### 关于Linux的争论

Linux 的历史也不是一片平坦，在其刚发布的时候就引来了“Linux 已经过时的言论”。

1992 年，MINIX 的作者 Andrew S. Tanenbaum，在新闻组 comp.os.minix 上发表了一篇 [《LINUX is obsolete》](https://www.oreilly.com/openbook/opensources/book/appa.html)的文章，批判了在 1991 年写一个宏内核系统真是一个糟糕的主意。Linus 也有力的回击了 Andrew 的评论，如果微内核当前已经成熟可用的话，他也不用大费周章的编写 Linux 操作系统了。但在21世纪的现在来看，Linux 系统经受住了历史的考验，我们的 Linux 系统依然稳健的运行在各类硬件上。

自由与商业的竞争。苹果曾聘请过 Torvalds ，因为理念不和而分道扬镳。微软和 Linux 阵营在 1997 年到 2001 年间还是有着很多敌对的情况。这种情况在 1998 年 Eric S. Raymond 发表《万圣节文件》的时候变得明显起来。这里由一位微软工程师写的关于寻求解决自由软件对微软的威胁的策略的文章。

SCO-Linux 争议。2003 年 3 月，SCO  Group 指责 IBM 把 UNIX 的代码移植到 Linux 侵犯了他们的版权。SCO 声称它们拥有代码的版权并 IBM 提起了诉讼。Red  Hat 又提起了反诉讼，因此 SCO 又提起了其他相关的诉讼。在这些诉讼进行的同时，SCO 开始把 Linux 的许可权卖给那些不愿意冒受 SCO 投诉的险的用户。因为 Novell 也声称拥有 UNIX 的版权，所以它又对 SCO 提起了诉讼。接着 SCO 便声明破产了。

#### 商标权

Linux 诞生的时候并没有多么注意商标，虽然一直使用 Linux 的名称。直到从 1994 年开始，越来越多不同国家的人想要将 Linux 注册成自己的商标然后收取金。Linux 的开发人员非常反感这种做法，后来，Torvalds 在 Linux 国际的帮助下得到了 Linux 这个商标，随后他把这个商标转让给了 Linux 国际。目前这个商标的保护由一个专门的基金会——非营利性的Linux标识协会——来管理。






## 4. linux 操作系统和常用命令

### （1）、认识 Linux

Linux 是一个现代操作系统内核，它提供的主要功能是管理好计算机中的硬件，尽可能的屏蔽好各类硬件的差异，为计算机中的软件提供一个标准的统一调用接口。为什么要拥有一个这样的内核呢，这涉及到软件和硬件的协调了。软件是运行在硬件之上的，更具体的说是 CPU 中央处理器提供了基本的动作，这些动作被称为指令集，我们编排好一条条指令，这些指令按照规则组合起来后，就可以称之为软件，软便是松软可变动的意思，意味这软件是随时可变的。但是硬件不一样，硬件在制造好之后，就不会再改变了。在今天，我们研发出了各种个样的硬件，就比如组成计算机的几大件：CPU、内存、硬盘、主板、鼠标、键盘等，不同的厂商造出来的东西都不一样。同样的，不同的硬件就会用不同的动作，不同的动作对应着不同的指令，软件如何想让这些硬件正常的工作起来，那就要添加各种动作，编写软件的人还要思考如何协调好这么多的硬件。面对着越来越庞大的计算机体系，个人的能力是非常有限的，要多个人考虑合作。而考虑合作，就需要有序的沟通，所以对于计算机来说，操作系统内核就出来了，有人负责整个操作系统架构，有人负责具体的各个硬件驱动，也有人负责写其他的程序，需要的时候调用这个操作系统提供的接口就可以了。这下不同的事情就可以交给不同的人来做，分工好了，面对再复杂的事情我们都能化整为零完美解决了。

#### 内核

内核是操作系统最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并且内核决定一个程序在什么时候对某部分硬件操作多长时间。内核的分类可分为单内核和双内核以及微内核。严格地说，内核并不是计算机系统中必要的组成部分。

内核是一个操作系统的核心。是基于硬件的第一层软件扩充，提供操作系统的最基本的功能，是操作系统工作的基础，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。

现代操作系统设计中，为减少系统本身的开销，往往将一些与硬件紧密相关的（如中断处理程序、设备驱动程序等）、基本的、公共的、运行频率较高的模块（如时钟管理、进程调度等）以及关键性数据结构独立开来，使之常驻内存，并对他们进行保护。通常把这一部分称之为操作系统的内核。

程序可以直接地被调入计算机中执行，这样的设计说明了设计者不希望提供任何硬件抽象和操作系统的支持，它常见于早期计算机系统的设计中。最终，一些辅助性程序，例如程序加载器和调试器，被设计到机器核心当中，或者固化在只读存储器里。这些变化发生时，操作系统内核的概念就渐渐明晰起来了。

![](https://pic1.zhimg.com/v2-f00d3ae2560808dd173d9205d5943b20_r.jpg)

#### 用户

Linux 相当于一座大房子，Linux 的用户则相当于房子的主人或者房子的住户，Linux基于用户身份对资源访问进行控制。

Linux 用户账号分为三类：

- 超级用户：root用户是Linux操作系统中默认的超级用户账号，对本主机拥有最高的权限，系统中超级用户是唯一的。
- 普通用户：由root用户或其他管理员用户创建，拥有的权限会受到限制，一般只在用户自己的宿主目录中拥有完整权限。
- 程序用户：在安装Linux操作系统及部分应用程序时，会添加一些特定的低权限用户账号，这些用户一般不允许登录到系统，仅用于维持系统或某个程序的正常运行，如bin、daemon、ftp、mail等。


#### 用户账户管理

![](https://pic4.zhimg.com/80/v2-21b7350d259da17d71424ea85e3e7c5f_720w.webp)

与 Linux 用户相关的文件为 /etc/passwd。

```bash
nihao@nihao-z690:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin
systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin
messagebus:x:102:105::/nonexistent:/usr/sbin/nologin
systemd-timesync:x:103:106:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin
syslog:x:104:111::/home/syslog:/usr/sbin/nologin
_apt:x:105:65534::/nonexistent:/usr/sbin/nologin
tss:x:106:112:TPM software stack,,,:/var/lib/tpm:/bin/false
uuidd:x:107:115::/run/uuidd:/usr/sbin/nologin
systemd-oom:x:108:116:systemd Userspace OOM Killer,,,:/run/systemd:/usr/sbin/nologin
tcpdump:x:109:117::/nonexistent:/usr/sbin/nologin
avahi-autoipd:x:110:119:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin
usbmux:x:111:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
dnsmasq:x:112:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
kernoops:x:113:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin
avahi:x:114:121:Avahi mDNS daemon,,,:/run/avahi-daemon:/usr/sbin/nologin
cups-pk-helper:x:115:122:user for cups-pk-helper service,,,:/home/cups-pk-helper:/usr/sbin/nologin
rtkit:x:116:123:RealtimeKit,,,:/proc:/usr/sbin/nologin
whoopsie:x:117:124::/nonexistent:/bin/false
sssd:x:118:125:SSSD system user,,,:/var/lib/sss:/usr/sbin/nologin
speech-dispatcher:x:119:29:Speech Dispatcher,,,:/run/speech-dispatcher:/bin/false
fwupd-refresh:x:120:126:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologin
nm-openvpn:x:121:127:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin
saned:x:122:129::/var/lib/saned:/usr/sbin/nologin
colord:x:123:130:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
geoclue:x:124:131::/var/lib/geoclue:/usr/sbin/nologin
pulse:x:125:132:PulseAudio daemon,,,:/run/pulse:/usr/sbin/nologin
hplip:x:127:7:HPLIP system user,,,:/run/hplip:/bin/false
gdm:x:128:134:Gnome Display Manager:/var/lib/gdm3:/bin/false
nihao:x:1000:1000:nihao,,,:/home/nihao:/bin/bash
sshd:x:129:65534::/run/sshd:/usr/sbin/nologin
festival:x:134:29::/nonexistent:/usr/sbin/nologin
```

/etc/passwd是一个系统文件，而不是目录。它是一个文本文件，用于存储系统中所有用户账户的基本信息。

每一行代表一个用户账户，字段之间使用冒号进行分隔，通常包含以下信息：

- 用户名：标识用户的唯一名称。

- 密码占位符：在过去，密码哈希值存储在此处，现在则通常为 "x" 表示密码已被移动到 /etc/shadow 文件中。
- 用户标识号（UID）：每个用户都有一个唯一的数字标识。
- 组标识号（GID）：指定用户所属的主要组的标识号。
- 用户描述信息：包含有关用户的备注信息或全名等。
- 主目录：用户登录后的起始目录。
- Shell：定义用户登录后默认使用的 shell。

**useradd 添加用户**

基本语法：useradd 用户名（功能描述：添加新用户）

案例：[root@lagou~]#useradd hadoop

**userdel 删除用户**

基本语法：

userdel 用户名（功能描述：删除用户但保存用户主目录）

userdel -r 用户名（功能描述：用户和用户主目录，都删除）

案例：

删除用户但保存用户主目录: [root@lagou~]#userdel hadoop
删除用户和用户主目录:[root@lagou~]#userdel -r hadoop

**passwd 设置用户密码**

基本语法：passwd 用户名（功能描述：设置用户密码）

案例：
![](https://pic4.zhimg.com/80/v2-3e8cc86c046bc965ecbd978bbb06f1db_720w.webp)

**id 判断用户是否存在**

基本语法：id 用户名

**su 切换用户**

基本语法：

su 用户名称（功能描述：切换用户，只能获得用户的执行行权限，不能获得环境变量）su - 用户名称（功能描述：切换到用户并获得该用户的环境变量及执行权限）

案例:
```bash
[root@lagou~]#su hadoop
[root@lagou~]#su - hadoop
```

**who查看登录用户信息**

基本语法:

whoami（功能描述：显示自身用户名称）
who am i（功能描述：显示登录用户的用户名）
who（功能描述：看当前有哪些用户登录到了了本台机器器上）


#### 用户组管理
多个用户又可以组成用户组，用户组有两种：

- 基本组（私有组） ：基本组账号只有一个，一般为创建用户时指定的组。
- 附加组（公共组） ：用户除了基本组以外，额外添加指定的组。附加组可以有多个，可以在基本组，也可以同时在附加组
- 
![](https://pic2.zhimg.com/80/v2-4aeee6118ec5bd090012ea1ee0bce729_720w.webp)

Linux作为多用户、多任务的系统，为了提供更好的用户管理和权限控制机制，使系统管理员能够更高效地管理用户、控制权限，并对文件和目录进行适当的保护。其引入了用户组概念，通过用户组可以简化管理过程，提高系统的安全性和可管理性。

"/etc/group" 是 Linux 系统中的一个文件，用于存储系统中所有用户组的信息。每一行代表一个用户组，它包含了用户组的名称、组密码（通常为空）、组标识号（GID）以及属于该用户组的用户列表。

**groupadd 新增组**

基本语法: groupadd 组名

案例：

增加一个 hadoop 组：groupadd hadoop
**groupdel 删除组**

基本语法：groupdel 组名

案例：

删除 hadoop 组：groupdel hadoop
**groupmod 修改组**

基本语法：groupmod -n 新组名 老组名

案例：

修改 hadoop 组名称为 hadoop1 : groupmod -n hadoop1 hadoop
**查看创建了哪些组**

基本语法：cat /etc/group
**usermod 修改用户所属组**

基本语法：usermod -g 用户组 用户名

案例：

将用户 hadoop 加入 mygroup 用户组：sermod -g mygroup hadoop


#### 用户的密码管理

![](https://pic3.zhimg.com/80/v2-de0c892d876e182503ad0c669fa59a42_720w.webp)

>注意：只有root管理员才可以修该其他用户的密码，普通账户只能修改自己的密码，并且普通用户没有修改其他用户密码的权限

在linux密码管理中，我们还应该熟悉密码策略的配置，如：

密码策略：可以通过配置文件或者命令来设置密码策略，以限制密码的复杂度和有效期限。密码策略通常包括以下内容：

- 密码长度：设置密码的最小长度要求。
- 复杂度要求：可以要求密码包含字母、数字、特殊字符等不同类型的字符。
- 历史密码限制：禁止用户在一段时间内重复使用先前使用过的密码。
- 密码有效期：设置密码的有效期限，过了有效期后需要用户更改密码。
- 警告通知：在密码即将过期之前发送警告通知给用户。

`chage` 命令：`chage` 命令用于修改用户的密码策略，比如修改密码过期时间、密码失效时间等。可以使用 `chage -l username` 查看用户当前的密码策略信息，使用 `chage -m` 修改密码最小长度，使用 `chage -M` 修改密码有效期等。

`/etc/pam.d/` 目录中的配置文件：PAM 是 Linux 中的身份验证管理机制，可以通过修改 `/etc/pam.d/` 目录下的文件来配置密码策略。常见的文件有 `common-password` 和 `system-auth` 等，可以在文件中配置密码策略规则。

密码加密算法：Linux 使用密码哈希算法（如 MD5、SHA-256、SHA-512）将用户密码进行加密存储，以确保密码的安全性。

`/etc/shadow`是一个重要的系统文件，它存储了用户的加密密码和相关的账户信息。该文件只能由系统管理员或具有特权的用户访问。其中包含了每个用户账户的密码哈希值、上次修改密码的时间、密码过期时间、账号是否被锁定等信息。这里的密码哈希值是用户密码经过加密处理后的结果，实际密码并不存储在该文件中。通过将用户输入的密码与保存在`/etc/shadow`中的密码哈希值进行比对，系统可以验证用户的身份。

#### 用户的权限管理

>Linux系统一般将文件可存/取访问的**身份**分为3个类别：owner、group、others，且3种身份各有read、write、execute等**权限**。

在多用户（可以不同时）计算机系统的管理中，权限是指某个特定的用户具有特定的系统资源使用权力，像是文件夹、特定系统指令的使用。

**常见权限**

在 Linux 中，文件和目录的权限是由三个基本权限位来控制的，分别是读取权限（r）、写入权限（w）和执行权限（x）。这些权限位可以分别应用于文件的所有者、所属组和其他用户。以下是更详细的说明：

- 读取权限（r）：读取权限允许用户查看文件的内容或目录的列表。对文件而言，具有读取权限的用户可以读取文件的内容；对目录而言，具有读取权限的用户可以列出目录中的文件和子目录。

- 写入权限（w）：写入权限允许用户修改文件的内容或目录的结构。对文件而言，具有写入权限的用户可以编辑或修改文件的内容；对目录而言，具有写入权限的用户可以创建、删除或重命名文件和子目录。

- 执行权限（x）：执行权限允许用户执行可执行文件或进入目录。对文件而言，具有执行权限的用户可以运行该文件作为程序；对目录而言，具有执行权限的用户可以进入该目录并访问其中的文件和子目录。

- 设置权限：可以使用 chmod 命令来设置文件和目录的权限。例如，使用以下命令将文件设置为所有者可读写，所属组和其他用户只可读取的权限：

- 特殊权限：除了基本权限位，还存在一些特殊权限位，如 SUID、SGID 和 sticky 位。SUID 权限允许在执行文件时临时获得文件所有者的权限，SGID 权限允许在执行文件时临时获得文件所属组的权限，sticky 位用于目录，防止其他用户删除其他人的文件。

可以使用 ls -l 命令来查看文件和目录的详细权限信息。列表中的第一列显示了权限位的设置情况，如 rwxr-xr--。

![](https://pic3.zhimg.com/80/v2-87c6be492faf7ccebd7e9f1acc83409a_720w.webp)

按照字母位置解释：

![](https://pic1.zhimg.com/80/v2-2150ac4b29617b061122ab717b627abc_720w.webp)

权限分段，每一段代表不同的用户：

- 属主权限：当前文件所属用户的权限，在Linux中每一个文件都有所属的用户
- 属组权限：当前文件的用户所在组的其它成员的权限其它
- 用户权限：跟文件所属用户不在同组的其它用户的权限

![](https://pic1.zhimg.com/80/v2-d68f20badbb7435374feae16545c3918_720w.webp)



#### sudo 权限

sudo 是一个独立的程序，需要安装和配置才能使用。通常情况下，sudo 配置文件位于 /etc/sudoers 或 /etc/sudoers.d 目录下，可使用 visudo 命令编辑该文件。

sudo 可以根据需要为不同的用户或组分配不同的授权和限制。通常情况下，授权的方式是通过添加条目到 sudoers 文件中实现的。可以使用  ALL 表示所有命令，也可以使用特定的命令或命令列表。可以限制用户仅能在特定的终端或特定的时间段内执行 sudo 命令。

一旦配置了 sudo，普通用户可以使用 sudo 命令以管理员身份执行需要的命令。需要在命令前加上 sudo 关键字，按提示输入账户密码即可。如果用户未被授权执行该命令，则会收到错误提示。

由于 sudo 具有很高的权限，因此必须谨慎使用。可以对关键命令进行审计，查看用户是否滥用了权限。可以使用特定的日志工具监控 sudo 命令的执行记录。此外，要定期更新系统和软件以确保系统安全。

超级管理员是一个特殊的用户，具有系统的最高权限。在 Ubuntu 中，默认情况下没有启用 root 用户或超级管理员账户，而是使用 sudo 权限管理来代替直接使用 root 权限。因此，Ubuntu 用户通常需要使用 sudo 命令来执行管理员任务。

#### sudo 与 su

> su是最简单的身份切换，用su我们能够进行各种用户的切换，一般都是su - username，然后输入password(注意：这里的密码不会在屏幕中显示出来)，root用su切换到其它身份的时候无需输入password。

在 Linux 中，`su` 和 `sudo` 是用于切换用户身份的命令，但它们在功能和使用方式上有一些区别：

**`su`（Switch User）命令：**

功能：`su` 命令用于切换到其他用户账号，并且可以切换为超级用户（root）。

使用方式：默认情况下，使用 `su` 命令需要输入目标用户的密码。例如，使用 `su username` 可以切换到名为 "username" 的用户账号，或使用 `su` 切换为超级用户。

特点：切换为目标用户后，会进入该用户的环境，包括工作目录、环境变量等。

**`sudo`（Superuser Do）命令：**

功能：`sudo` 命令允许普通用户以其他用户（通常是超级用户）的权限来执行命令或操作。

使用方式：使用 `sudo` 命令时，需要输入当前用户的密码，而不是目标用户的密码。例如，使用 `sudo command` 可以以超级用户权限执行指定的命令。

特点：通过 `sudo` 执行的命令会在日志中留下记录，以便审计和追踪。

**区别总结如下：**

`su` 是切换用户的命令，需要知道目标用户的密码，且切换后会进入该用户的环境。

`sudo` 是以其他用户权限执行命令的命令，需要输入当前用户的密码，具有审计和追踪功能。

一般来说，`sudo` 命令更为常用和推荐，因为它提供了更细粒度的权限控制，可以指定哪些用户可以执行特定的命令，从而提高系统的安全性。在使用 `sudo` 命令时，管理员可以将需要临时获取超级用户权限的命令添加到 `/etc/sudoers` 配置文件中，并配置相应的访问权限。

>补充：
>ACL（Access Control List）是一种在Linux系统中用于细粒度控制文件和目录权限的机制。传统的Unix文件权限模型使用9位权限标志（rwxrwxrwx）来控制所有者、所属组和其他用户对文件的访问权限。
>而ACL提供了更加灵活和精细的权限控制，它允许你为特定用户或用户组附加额外的权限。ACL可以应用于文件和目录，并且能够设置不同类型的权限，例如读取、写入、执行以及其他自定义的权限。
>使用ACL，你可以做到以下几点：
>给一个文件或目录授予额外的用户或用户组访问权限，而不仅限于所有者、所属组和其他用户。
>通过ACL为特定用户或用户组添加个别权限，而不是应用通用的文件权限。
>控制默认权限，以便新创建的文件或目录继承父级目录的ACL，而不仅仅是文件权限。
>要在Linux系统中使用ACL，你需要确保文件系统支持ACL并已启用。多数Linux发行版默认开启了ACL功能。可以使用`acl`命令检查文件系统是否支持ACL，使用`getfacl`和`setfacl`命令来查看和修改ACL规则。
>总而言之，ACL提供了更加灵活和细粒度的权限控制机制，使管理员能够更好地管理用户对文件和目录的访问权限。

#### 权限管理

**修改文件权限**:

![](https://pic2.zhimg.com/80/v2-85452b8b4add75ad95bddf1c622c4c41_720w.webp)

**chown 改变所有者**

基本语法：chown 最终用户（功能描述：改变文件或者目录的所有者）

案例：[root@lagoutest]#chown hadoop test1.txt

**chgrp改变所属组**
基本语法：chgrp 最终用户组（功能描述：改变文件或者目录的所属组）
案例：
![](https://pic4.zhimg.com/80/v2-a7916b1314ec8ebd2078e32cb3d2c71f_720w.webp)




#### 用户登录管理

用户登录选项的配置通常在 /etc/login.defs 或 /etc/default/useradd 文件中。可以设置默认的 shell、UID 和 GID 的范围、密码有效期等。可以根据需要进行调整。

使用 usermod 命令可以禁止或允许用户登录。可以通过修改用户账户的 shell 为 /sbin/nologin 来禁止用户登录。例如，使用以下命令禁止用户登录：

```bash
sudo usermod -s /sbin/nologin 用户名
```

可以使用文件权限和访问控制列表 (ACL) 来限制用户对特定文件和目录的访问权限。可以设置文件的所有者和所属组，并设置合适的访问权限。

使用 id、who、w 等命令可以查看用户账户的信息，如用户名、用户 ID、所属用户组、登录状态等。




#### 文件

Linux 内核是要对外提供服务的，而传递服务的对象就是文件。Linux 中有一切皆文件的说法，文件是 Linux 内核向我们展示信息的基本单元，组织文件的系统为文件系统树。使用 Linux 的过程就是我们在 Linux 文件系统树中找到我们需要的文件，然后或者操作，或者读取它，从而达到我们的目的或者获取我们需要的信息。

文件是信息的载体，在 Linux 中，文件存着三种型态：文件本体，软链接和硬链接。

``` bash
# 创建一个 test.txt 空文件
nihao@nihao-z690:~$ touch test.txt
# 创建这个文件的硬链接
nihao@nihao-z690:~$ ln test.txt ln_test.txt
# 创建这个文件的软链接
nihao@nihao-z690:~$ ln -s test.txt lns_test.txt
# 显示创建的文件
nihao@nihao-z690:~$ ls -la
总计 8
drwxrwxr-x 2 nihao nihao 4096 11月 30 18:23 .
drwxrwxr-x 3 nihao nihao 4096 11月 30 18:22 ..
lrwxrwxrwx 1 nihao nihao    8 11月 30 18:23 lns_test.txt -> test.txt
-rw-rw-r-- 2 nihao nihao    0 11月 30 18:22 ln_test.txt
-rw-rw-r-- 2 nihao nihao    0 11月 30 18:22 test.txt
# 显示创建的文件描述
nihao@nihao-z690:~$ file test.txt 
test.txt: empty
nihao@nihao-z690:~$ file ln_test.txt 
ln_test.txt: empty
nihao@nihao-z690:~$ file lns_test.txt 
lns_test.txt: symbolic link to test.txt
```

文件本体就是标准的文件，有内容，有权限，有用户属性等等，对于软链接和硬链接，相当于文件不同形式的分身。
硬链接是指多个文件实际上指向同一个索引节点（inode）。每个文件都有一个 inode，inode 包含文件的元数据和数据块的地址。所有硬链接文件对应的 inode 的链接计数都会加一。硬链接文件之间没有物理上的区别，它们只是同一 inode 的多个别名。当一个硬链接文件被删除时，只是链接计数减一，只有在链接计数降为零时，文件的内容才会被释放。硬链接不能跨越文件系统边界，因为 inode 是特定于文件系统的。硬链接相当于文件本体的一个别名，同时也是文件的动态备份，无论操作文件本体或者硬链接都相当于操作该文件。只有全部文件本体和硬链接全部删除时才会真正的删除文件，如果只删除文件本体，那硬链接就会变成文件本体。
软链接是一个特殊的文件，其中包含指向另一个文件的路径。软链接是通过文件路径而不是 inode 直接引用目标文件的。软链接可以链接到不存在的文件，也可以跨越文件系统。软链接文件有自己的 inode，而其内容是指向目标文件的路径。如果原始文件被删除，软链接将变为坏链接（dangling link）。软链接也可能引起“循环链接”（circular link）问题，即链接形成了一个环，导致无限循环。软链接只是相当于文件的一个分身，没有备份功能。

#### 文件系统树

组织文件的系统被称为文件系统树，基本的 Linux 文件系统树由根节点和多个根目录组成，不同的根目录存放着不同的文件，他们决定着 Linux 不同的功能。

![](https://pic1.zhimg.com/80/v2-1adefa5fa2632b9198b2e1af266f6b88_720w.jpg)



**/root**

这是系统管理员(root user)的目录。对于系统来说，系统管理员就好比是上帝，它能对系统做任何事情，甚至包括删除你的文件。因此，请小心使用root帐号。
**/bin**

这里存放了标准的(或者说是缺省的)linux的工具，比如像“ls”、“vi”还有“more”等等。通常来说，这个目录已经包含在你的“path”系 统变量里面了。什么意思呢?就是：当你在终端里输入ls，系统就会去/bin目录下面查找是不是有ls这个程序。系统所需要的那些命令位于此目录
**/etc**

这里主要存放了系统配置方面的文件。举个例子：你安装了samba这个套件，当你想要修改samba配置文件的时候，你会发现它们(配置文件)就在/etc/samba目录下。
**/dev**

这里主要存放与设备(包括外设)有关的文件( Unix 和 Linux 系统均把设备当成文件)。想连线打印机吗? 系统就是从这个目录开始工作的。另外还有一些包括磁盘设备文件、USB 设备文件等都放在这个目录。
**/home**

这里主要存放个人数据。具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：/home/用户名。当然，root用户除外。
**/tmp**

这是临时目录，只存在于内存中，关机便会消失。对于某些程序来说，有些文件被用了一次两次之后，就不会再被用到，像这样的文件就放在这里。有些 Linux 系统会定期自动对这个目录进行清理，因此，千万不要把重要的数据放在这里。
**/usr**

在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏，一些打印工具拉等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序;/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等;/usr/lib目录用于存放那些不能直接 运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器会自动帮你管理好/usr目录的。

当我们安装一个Linux发行版官方提供的软件包时，大多安装在这里。 如果有涉及服务器配置文件的，会把配置文件安装在/etc目录中。/usr目录下包括涉及字体目录/usr/share/fonts ，帮助目录 /usr/share/man或/usr/share/doc，普通用户可执行文件目录/usr/bin 或/usr/local/bin 或/usr/X11R6/bin ，超级权限用户root的可执行命令存放目录，比如 /usr/sbin 或/usr/X11R6/sbin 或/usr/local/sbin 等；还有程序的头文件存放目录/usr/include。
**/usr/local**

这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面

/usr/local 这个目录一般是用来存放用户自编译安装软件的存放目录；一般是通过源码包安装的软件，如果没有特别指定安装目录的话，一般是安装在这个目录中。这个目录下面有子目录

/usr/share 系统共用的东西存放地，比如 /usr/share/fonts 是字体目录，/usr/share/doc和/usr/share/man帮助文件。
**/opt**

这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就可以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。

举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单
通过源码包安装的软件，可以通过 ./configure --prefix=/opt/目录
**/media**

有些linux的发行版使用这个目录来挂载那些usb接口的移动硬盘(包括U盘)、CD/DVD驱动器等等。
**/boot**

Linux的内核及引导系统程序所需要的文件目录，比如 vmlinuz initrd.img 文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录。
**/lost+found**

在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损 坏的文件系统。 有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。
**/mnt**

这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom 等目录。可以参看/etc/fstab的定义。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。主要看/etc/fstab中怎 么定义了；比如光驱可以挂载到/mnt/cdrom 。
**/proc**

操作系统运行时，进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文件系统proc的挂载目录，proc并不是真正的文件系统，它的定义可以参见 /etc/fstab 。
**/sbin**
大多是涉及系统管理的命令的存放，是超级权限用户root的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的；我们记住就行了，凡是目录sbin中包含的都是root权限才能执行的。
**/var**
这个目录的内容是经常变动的，看名字就知道，我们可以理解为vary的缩写，/var下有/var/log 这是用来存放系统日志的目录。/var/www目录是定义Apache服务器站点存放目录；/var/lib 用来存放一些库文件，比如MySQL的，以及MySQL数据库的的存放地；
/var/log 系统日志存放，分析日志要看这个目录的东西；
/var/spool 打印机、邮件、代理服务器等假脱机目录；

Linux 或者说 UNIX 类的现代操作系统自身只有用户、权限、文件这三个内容，在使用 Linux 的过程中，我们基本都是围绕着这三个内容展开的。同时，这三个内容的组织形式，用户组，权限组，文件树也是非常重要的。

### （2）、 Linux 中的命令（软件）

Linux 中的命令其实就是一个个的可执行程序，脚本也算可执行程序的一种。可执行程序又叫软件，软件的组织形式是软件包，有专门的程序去管理软件包。

Linus Torvalds 开始编写和编译 Linux   内核时，他需要一套非常基本的系统实用程序来开始执行一些稍微有用的工作。内核并不提供命令或任何类型的命令 shell，比如   Bash，它本身是没有任何用处的，因此，Linus 使用了免费提供的 GNU 核心实用程序，并为 Linux   重新编译了它们。这让他拥有了一个完整的、即便是相当基本的操作系统。

#### SHELL

![](https://img-blog.csdnimg.cn/img_convert/56c96734fb37d4773ae524b0394fa5cc.jpeg)

对于计算机来说，Linux 内核只是一个管理计算机各种硬件的程序，它不具有和人们交互的能力。为此我们需要一个能够理解人类指令并让内核按照人类意愿管理和操作计算机的程序，这个程序就是 shell。shell 的变种有多个名称，下面是关于 shell 程序的一个表格：

| shell | Complete path-name | Prompt for root user  | Prompt for non root user |
| --- | --- | --- | --- |
| Bourne shell (sh) |	/bin/sh and /sbin/sh |	#	 | $ |
| GNU Bourne-Again shell (bash) | 	/bin/bash | 	bash-VersionNumber# |	bash-VersionNumber$ |
| C shell (csh) |	/bin/csh |	# |	% |
| Korn shell (ksh)	| /bin/ksh	| #	| $ |
| Z Shell (zsh)	| /bin/zsh	| <hostname>#	| <hostname>% |

**Bourne Shell (sh)**
Bourne shell 由 Steve Bourne 在 AT&T 贝尔实验室开发，被认为是第一个UNIX shell。它被表示为 sh。由于紧凑和操作速度快，Bourne shell 广受欢迎。

以上特性使得它成为 Solaris 操作系统的默认外壳。它也被用作所有 Solaris 系统管理脚本的默认外壳。然而，Bourne shell有一些明显的缺点：

它没有内置的处理逻辑和算术运算的功能。

另外，与Linux中大多数的 shell 不同，Bourne shell不能回忆以前使用过的命令。

它功能不全面， 无法提供适当的交互式使用。

Bourne shell的完整路径名称是/bin/sh和/sbin/sh。默认情况下，它对 root 用户使用 *#* 提示符，对非 root 用户使用 *$* 提示符。

**GNU Bourne-Again Shell (bash)**

GNU Bourne-Again shell 更多被称为 Bash shell，它被设计成与Bourne shell兼容。Bash shell 融合了 Linux 中不同类型 shell 的有用功能，如 Korn shell 和 C shell。

与Bourne shell不同的是，它能够自动回忆以前使用过的命令，并可以使用方向键编辑它们。

GNU Bourne-Again shell的完整路径名称是/bin/bash。默认情况下，它对 root 用户使用的提示符是 *bash-版本号#*，对非 root 用户的提示符是 *bash-版本号$*。

**C Shell (csh)**
发 C shell 是把有用的编程功能容纳进去，如对算术运算的内置支持和类似于 C 语言的语法。

此外，它还包含了 Linux 中不同类型的 shell（如Bourne shell）中所缺少的历史命令。C shell 的另一个显著功能是“别名”。

C shell的完整路径名称是/bin/csh。默认情况下，它对 root 用户的提示符是 *主机名#*，对非 root 用户的提示符是 *主机名$*。

**Korn Shell (ksh)**
Korn shell 是由 David Korn 在 AT&T 贝尔实验室开发的，用于改进 Bourne shell。它被表示为 ksh。Korn shell 本质上是 Bourne shell 的一个超集。

除了支持 Bourne shell 所支持的一切外，Korn shell 还为用户提供了新的功能。它有着内置的对算术运算的支持，同时提供类似于 C shell 的交互功能。

Korn shell 运行为 Bourne shell 编写的脚本，同时提供类似于 C 语言的字符串、数组和函数运算。它还支持为 C shell 编写的脚本。此外，它比 Linux 中大多数不同类型的 shell（包括 C shell）要快。

Korn shell 的完整路径名称是/bin/ksh。默认情况下，它对 root 用户使用 *#* 提示符，对非 root 用户使用 *$* 提示符。

**Z Shell (zsh)**
Z Shell 或 zsh 是 sh shell 的扩展，在自定义方面做了大量改进。如果你想要一个具有更多功能的现代 shell，zsh shell就是你要找的。

Z shell 有以下亮点：

- 根据给定的条件生成文件名

- 支持插件和主题

- 索引内置函数

- 自动补全命令

- 以及更多……

 Shell 程序更多的是提供一个和用户交互的接口，它能够以用户手动输入的方式一条一条命令执行，同时也可以解析已经编写好的程序脚本，自动进行命令执行。Shell 程序本身不提供或者只提供基本的内置环境命令，而我们平时执行的命令主要是由软件包中的软件来提供的，所以学习命令的使用其实就是学习软件包中的软件使用方法。

#### Coreutils

Coreutils 软件包是 GNU 项目的一部分，它是一组基本的命令行工具集，用于操作和管理Linux和其他类Unix系统中的文件和数据流。这些工具被广泛用于终端和脚本中，提供了许多常用的功能和实用程序，基本的 Linux 命令就是由这个软件包进行提供了。Coreutils 的官网地址是：https://www.gnu.org/software/coreutils 。

**GNU coreutils核心程序**
![](https://img-blog.csdnimg.cn/469ed2582e6c4bed9331c1c03433547c.png)

Linux 的基本系统操作命令有十大类：

- 目录处理命令：ls，mkdir，cd，pwd，rmdir，cp，rm
- 文件处理命令：touch，cat，more，less，head，tail
- 链接命令：ln
- 权限管理命令：chmod，chown，chgrp，umask
- 文件搜索命令：find，locate，which，whereis，grep
- 帮助命令；man，whatis，help
- 用户管理命令：useradd，passwd，who，w，su
- 压缩解压缩命令：gzip，gunzip，tar，zip，unizp
- 网络命令：write，wall，ping，ifconfig，mail，last，netstat
- 关机重启命令：shutdown，logout

- 更多...

#### util-linux

Util-linux 软件包包含许多工具。其中比较重要的是加载、卸载、格式化、分区和管理硬盘驱动器，打开 tty 端口和得到内核消息。

Util-linux 包含下面程序：

agetty, arch, blockdev, cal, cfdisk, chkdupexe, col, colcrt, colrm,  column, ctrlaltdel, cytune, ddate, dmesg, elvtune, fdformat, fdisk,  fsck.cramfs, fsck.minix, getopt, hexdump, hwclock, ipcrm, ipcs, isosize, line, logger, look, losetup, mcookie, mkfs, mkfs.bfs, mkfs.cramfs,  mkfs.minix, mkswap, more, mount, namei, parse.bash, parse.tcsh, pg,  pivot_root, ramsize (link to rdev), raw, rdev, readprofile, rename,  renice, rev, rootflags (link to rdev), script, setfdprm, setsid,  setterm, sfdisk, swapoff (link to swapon), swapon, test.bash, test.tcsh, tunelp, ul, umount, vidmode (link to rdev), whereis 和 write

简短说明：
agetty打开一个TTY端口，显示登录提示，执行/bin/login命令。

arch 显示机器的体系结构信息。

blockdev在命令行中调用块设备的ioctl。

cal显示一个简单的日历。

cfdisk 处理指定设备的分区表。

chkdupexe 找出多余的可执行文件。

col 过滤来自输入的反向行馈送内容。

colcrt预览nroff的输出。

colrm 在某个文件中删除列。

column 把输出格式化为几列。

ctrlaltdel设置CTRL+ALT+DEL组合键的功能，为硬重启或软重启。

cytune 查询和修改cyclade驱动器的中断入口。

ddate 把阳历日期转换为Discordian日期。

dmesg 显示内核的启动信息。

elvtune 调整I/O端口平衡。

fdformat 低级格式化一张软盘。

fdisk 磁盘分区管理程序。

fsck.cramfs对Cramfs文件系统的一致性进行检查。

fsck.minix 对MINIX文件系统的一致性进行检查。

getopt解析命令参数。

hexdump用用户指定的方式(包括ASCII, 十进制, 十六进制, 八进制)显示一个文件或者标准输入的数据。

hwclock查询和设置硬件时钟。(也被称为RTC或BIOS时钟)

ipcrm删除一个指定的资源。

ipcs 提供IPC机制的信息。

isosize输出iso9660文件系统的长度。

line 单行拷贝。

logger 设置系统日志的入口。

look 显示以某个给定字符串为开头的行。

losetup 启动和控制回环(loop)设备。

mcookie为xauth产生magic cookie，128位随机数。

mkfs 在一个设备(通常是一个硬盘分区)设备上建立文件系统。

mkfs.bfs 创建 SCO bfs 文件系统。

mkfs.cramfs创建cramfs文件系统。

mkfs.minix 创建 Minix 文件系统。

mkswap 初始化指定设备或文件，以用做交换分区。

more 分屏显示文件，但less更好用。

mount把一个文件系统从一个设备挂载到一个目录。

namei 显示指定路径的符号链接。

pg显示文本文件内容，一次显示一屏。

pivot_root 使某个文件系统成为当前进程的根文件系统。

ramsize 显示或者改变内存虚拟盘的大小。

rdev 查询和设置内核的根设备和其他信息。

readprofile显示/proc/profile文件的信息。

rename对文件重命名。

renice修改正在运行进程的优先级。

rev 颠倒一个文件每行字符的顺序。

rootflags在挂载根设备时，查询和设置额外的信息。

script 为终端会话过程建立一个typescipt文件，记录会话过程中终端的输出。

setfdprm设置软盘参数。

setsid 在一个新的会话过程中运行程序。

setterm 设置终端属性。

sfdisk磁盘分区表管理工具。

swapdev 能在启动内核中设置交换分区设备。

swapoff取消对指定交换设备和交换文件的使用。

swapon 使指定的交换设备和交换文件生效。

tunelp设置打印设备的参数。

ul 加下划线。

umount卸载一个被挂载的文件系统。

vidmode查询和设置视频模式。

whereis确定某命令二进制文件,源文件和手册文档的位置。

write发一个消息给另一个用户,如果他开启了writting的话。

Util-linux 依赖于: Bash, Binutils, Coreutils, Diffutils, GCC, Gettext, Glibc, Grep, Make, Ncurses, Sed, Zlib 软件包。

#### 软件包管理

Linux 只是提供一个高度可用的内核，并没有规定上层的软件包组织形式，理论上说只要是符合要求的可执行文件都能得到执行。Linux 中的软件包非常自由有不同的组织形式，这些软件包又组成了不同的发行版。而不同的发行版又使用不同的软件包管理器。总的来说，软件包的管理是一个非常杂乱的时事情。

程序有动态执行库 SO 的依赖，把 SO 和 可执行文件组织起来的软件包也同样有不同的依赖。管理这些依赖是一件非常烦杂的事情，此时各种依赖管理工具诞生了，他们是各类发行版的基石，正是有了软件包依赖管理器，我们安装软件才能从容不迫。

** dpkg**

> **Ubuntu、Debian**

`dpkg` 命令是 `Debian Linux` 系统用来安装、创建和管理软件包的实用工具。

- **命令行使用**

```text
# dpkg(选项)(参数)
$ dpkg --help
Usage: dpkg [<option> ...] <command>

# 选项
-i：安装软件包
-r：删除软件包
-P：删除软件包的同时删除其配置文件
-L：显示于软件包关联的文件
-l：显示已安装软件包列表
--unpack：解开软件包
-c：显示软件包内文件列表
--confiugre：配置软件包

# 参数
Deb软件包：指定要操作的.deb软件包
```

- **示例演示说明**

```text
# 安装包
$ dpkg -i package.deb

# 删除包
$ dpkg -r package

# 删除包（包括配置文件）
$ dpkg -P package

# 列出与该包关联的文件
$ dpkg -L package

# 显示该包的版本
$ dpkg -l package

# 解开deb包的内容
$ dpkg --unpack package.deb

# 搜索所属的包内容
$ dpkg -S keyword

# 列出当前已安装的包
$ dpkg -l

# 列出deb包的内容
$ dpkg -c package.deb

# 配置包
$ dpkg --configure package

# 列出已安装软件包
$ sudo dpkg-query -l
$ sudo dpkg-query -l | less
$ sudo dpkg-query -l | grep tmux
```





** apt**

> **Ubuntu、Debian**

`apt-get` 命令是 `Debian Linux` 发行版中的 APT 软件包管理工具。所有基于 `Debian` 的发行都使用这个包管理系统。`deb` 包可以把一个应用的文件包在一起，大体就如同 `Windows` 上的安装文件。



- **命令行使用**

```text
# apt-get(选项)(参数)
$ apt --help
Usage: apt [options] command

# 选项
-c：指定配置文件

# 参数
管理指令：对APT软件包的管理操作
软件包：指定要操纵的软件包
```

- **示例演示说明**

```text
# 更新所有已安装的软件包
$ apt-get upgrade

# 将系统升级到新版本
$ apt-get dist-upgrade

# 更新
$ apt-get update

# 安装一个新软件包
$ apt-get install packagename

# 卸载一个已安装的软件包（保留配置文件）
$ apt-get remove packagename

# 卸载一个已安装的软件包（删除配置文件）
$ apt-get –purge remove packagename

# 来删除你已经删掉的软件
$ apt-get autoclean apt

# 会把安装的软件的备份也删除
$ apt-get clean

# 列出已安装软件包
$ sudo apt list --installed
$ sudo apt list --installed | less
$ sudo apt list --installed | grep tmux
```

** rpm**

> **RHEL、CentOS**

`rpm` 命令是 `RPM` 软件包的管理工具。`rpm` 原本是 `Red Hat Linux` 发行版专门用来管理 `Linux` 各项套件的程序，由于它遵循 `GPL` 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。`RPM` 套件管理方式的出现，让 `Linux` 易于安装，升级，间接提升了 `Linux` 的适用度。

- **命令行使用**

```text
# rpm(选项)(参数)
$ rpm --help
Usage: rpm [OPTION...]

# 选项
-a：查询所有套件
-c：只列出组态配置文件，本参数需配合"-l"参数使用
-d：只列出文本文件，本参数需配合"-l"参数使用
-e<套件档>或--erase<套件档>：删除指定的套件
-f<文件>+：查询拥有指定文件的套件
-h或--hash：套件安装时列出标记
-i：显示套件的相关信息
-i<套件档>或--install<套件档>：安装指定的套件档
-l：显示套件的文件列表
-p<套件档>+：查询指定的RPM套件档
-q：使用询问模式，当遇到任何问题时，rpm指令会先询问用户
-R：显示套件的关联性信息
-s：显示文件状态，本参数需配合"-l"参数使用
-U<套件档>或--upgrade<套件档>：升级指定的套件档
-v：显示指令执行过程
-vv：详细显示指令执行过程，便于排错

# 参数
软件包：指定要操纵的rpm软件包
```

- **示例演示说明**

```text
# 安装
$ rpm -ivh your-package.rpm

# 强制安装
$ rpm --force -ivh your-package.rpm

# 卸载
$ rpm -e proftpd-1.2.8

# 列出所有安装过的包
$ rpm -qa
$ rpm -qa | grep sql

# rpm包中的文件安装到那里
$ rpm -ql ***.rpm
# 一个没有安装过的软件包
$ rpm -qlp ***.rpm
# 一个已经安装过的软件包
$ rpm -ql ***.rpm

# 某个程序是哪个软件包安装
$ rpm -qf `which 程序名`   # 返回软件包的全名
$ rpm -qif `which 程序名`  # 返回软件包的有关信息
$ rpm -qlf `which 程序名`  # 返回软件包的文件列表
```

** yum**

> **CentOS6、CentOS7**

`yum` 命令是在 `Fedora` 和 `RedHat` 以及 `SUSE` 中基于 `rpm` 的软件包管理器，它可以使系统管理人员交互和自动化地更新与管理 `RPM` 软件包，能够从指定的服务器自动下载 `RPM` 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。

- **命令行使用**

```text
# yum(选项)(参数)
$ yum --help
Loaded plugins: fastestmirror, langpacks
Usage: yum [options] COMMAND

# 选项
-h：显示帮助信息；
-y：对所有的提问都回答“yes”；
-c：指定配置文件；
-q：安静模式；
-v：详细模式；
-d：设置调试等级（0-10）；
-e：设置错误等级（0-10）；
-R：设置yum处理一个命令的最大等待时间；
-C：完全从缓存中运行，而不去下载或者更新任何头文件。

# 参数
install：安装rpm软件包；
update：更新rpm软件包；
check-update：检查是否有可用的更新rpm软件包；
remove：删除指定的rpm软件包；
list：显示软件包的信息；
search：检查软件包的信息；
info：显示指定的rpm软件包的描述信息和概要信息；
clean：清理yum过期的缓存；
shell：进入yum的shell提示符；
resolvedep：显示rpm软件包的依赖关系；
localinstall：安装本地的rpm软件包；
localupdate：显示本地rpm软件包进行更新；
deplist：显示rpm软件包的所有依赖关系。
```

- **示例演示说明**

```text
# 安装
$ yum install             # 全部安装
$ yum install package1    # 安装指定的安装包package1
$ yum groupinsall group1  # 安装程序组group1

# 更新和升级
$ yum update              # 全部更新
$ yum update package1     # 更新指定程序包package1
$ yum check-update        # 检查可更新的程序
$ yum upgrade package1    # 升级指定程序包package1
$ yum groupupdate group1  # 升级程序组group1

# 查找显示
$ yum list installed | grep mysql
$ yum list installed mysql*
$ yum info package1     # 显示安装包信息package1
$ yum list              # 显示所有已经安装和可以安装的程序包
$ yum list package1     # 显示指定程序包安装情况package1
$ yum groupinfo group1  # 显示程序组group1信息

# 删除程序
$ yum remove/erase package1  # 删除程序包package1
$ yum groupremove group1     # 删除程序组group1
$ yum deplist package1       # 查看程序package1依赖情况

# 清除缓存
$ yum clean packages    # 清除缓存目录下的软件包
$ yum clean headers     # 清除缓存目录下的 headers
$ yum clean oldheaders  # 清除缓存目录下旧的 headers
```

** dnf**

> **RHEL8、CentOS8**

`DNF` 使用 `libsolv` 进行依赖解析，由 `SUSE` 开发和维护，旨在提高性能。`Yum` 主要是用 `Python` 编写的，它有自己的应对依赖解析的方法。它的 `API` 没有完整的文档，它的扩展系统只允许 `Python` 插件。`Yum` 是 `RPM` 的前端工具，它管理依赖关系和资源库，然后使用 `RPM` 来安装、下载和删除包。



由于 `Yum` 中许多长期存在的问题仍未得到解决，因此 `Yum` 包管理器已被 `DNF` 包管理器取代。这些问题包括性能差、内存占用过多、依赖解析速度变慢等。两个管理包工具的更多区别可以查看，What is the difference between DNF and YUM? 进行阅读。

- **安装 DNF 包管理器**

```text
# 依赖
$ yum install -y epel-release

# 安装
$ yum install -y dnf

# 检查
$ dnf –version
```

- **常用命令介绍**

```text
# 安装软件包
$ dnf install nano

# 升级软件包
$ dnf update systemd

# 升级所有系统软件包
$ dnf update
$ dnf upgrade

# 检查系统软件包的更新
$ dnf check-update

# 删除软件包
$ dnf remove nano
$ dnf erase nano

# 删除无用孤立的软件包
$ dnf autoremove

# 删除缓存的无用软件包
$ dnf clean all

# 查看系统中可用的DNF软件库
$ dnf repolist

# 查看系统中可用和不可用的所有的DNF软件库
$ dnf repolist all

# 列出所有RPM包
$ dnf list

# 列出所有安装了的RPM包
$ dnf list installed

# 列出所有可供安装的RPM包
$ dnf list available

# 搜索软件库中的RPM包
$ dnf search nano

# 查找某一文件的提供者
$ dnf provides /bin/bash

# 查看软件包详情
$ dnf info nano

# 查看所有的软件包组
$ dnf grouplist

# 安装一个软件包组
$ dnf groupinstall 'Educational Software'

# 升级一个软件包组中的软件包
$ dnf groupupdate 'Educational Software'

# 删除一个软件包组
$ dnf groupremove 'Educational Software'

# 重新安装特定软件包
$ dnf reinstall nano

# 回滚某个特定软件的版本
$ dnf downgrade acpid

# 查看DNF命令的执行历史
$ dnf history

# 查看所有的DNF命令及其用途
$ dnf help

# 获取有关某条命令的使用帮助
$ dnf help clean
```

### （3）、Shell 脚本

### （3）、Linux 实用

**定时任务**

Crontab

**开机任务**

/etc/rc.load

**条件任务**

内核事件监控inotify



对外服务












# 第二章：Linux 应用开发基础


## 1. 操作系统内核的认知


### （1）、 操作系统有四个基本特征：并发性、共享性、虚拟性、异步性。

操作系统的基本特征有四个即：并发性、共享性、虚拟性、异步性

**并发性：** 指的是两个或者多个事件在同一时间间隔内发生，即这个设备一会执行这个事件一会执行那个文件，多个事件共同使用一个设备。 

操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它应该具有处理和调度多个程序同时执行的能力。在这种多道程序环境下，一段时间内，宏观上有多个程序在同时运行，而在每一时刻，单处理器环境下实际仅能有一道程序执行，故微观上这些程序还是在分时地交替执行。操作系统的并发性是通过分时得以实现的。而并行则是指两个或者多个事件在同一时刻发生，即两个或者多个事件互不影响，计算机在同一时间完成两种或两种以上的工作。 

**共享性：** 即资源共享，指系统中的资源供内存中的多道程序所共同使用。 

共享有两种方式：互斥共享和同时访问。

- 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但是 一个时间段内，只允许一个进程访问

- 同时共享方式：系统中的某些资源，允许一个时间段内，多个进程"同时"对该资源进行访问

  这个同时是从宏观上来说的，在微观上，依然是多个进程交替访问该资源。

举个例子：

互斥共享：QQ和微信都支持视频聊天，但是不能同时开启QQ和微信进行视频聊天。

同时共享：我们可以同时传输文件A和文件B，从宏观上看，AB文件是同时传输的，但是从微观上看，两个传输进程都是交替访问磁盘的。

> 注意：并发、共享是多用户OS的最基本特征；资源共享以进程并发执行为条件；系统对资源共享的有效管理，需协调诸进程对其访问

并发和共享的关系

比如上面传输文件的例子，QQ发送文件A，微信发送文件B：

- 两个进程正在并发的执行(并发性)
- 需要共享的访问硬盘资源(共享性)

如果失去并发性，则系统只有一个进程在运行，那么共享性就没有意义。

如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法同时发送文件，即不能并发。

这就是并发性和共享性互为存在条件的原因。

**虚拟性 ：**指通过某种技术把一个物理实体变成若干个逻辑上的对应物。 

虚拟性是一种管理技术，把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物的技术。采用虚拟技术的目的是为用户提供易于使用、方便高效的操作环境。

例如分时系统将一机虚拟为多机就是未来使得用户资源共享更加方便。具体表现为两种虚拟：

- 1）虚拟内存：当前要处理的作业所占的内存比计算机的内存小时，先调入部分作业，当这部分作业处理完之后再调入接下来要处理的部分作业，因而程序认为计算机内存足够大，此即虚拟了更大内存
- 2）虚拟外设：当计算机连接多个外部设备时，让多个外设工作的时间差在可接受范围内，近似于同时工作，此即虚拟外设。 

**异步性：** 指的是系统中并发执行的多道程序“走走停停”即随时可能面对中断，以不可预知的速度向前推进。 

在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底；而是走走停停，以不可预知的速度向前推进，也就是进程的执行顺序和执行时间不确定。这就是进程的异步性。



### （2）、 实时操作系统
>实时体系指体系的核算正确性不只取决于核算的逻辑正确性，还取决于发生成果的时刻。假如未满意体系的时刻束缚，则以为体系失效。
>——Donal Gillies 在 Realtime Computing FAQ 中提出的界说。

实时操作系统，当外界事件和数据产生时，系统能以足够快的速度予以处理，其处理结果能在规定的时间内控制生产结果或对系统做出响应，并控制所有实时任务协调一致运行的操作系统。

实时操作系统，一般分为硬实时和软实时，硬实时指的是在规定的时间内必须完成任务操作，在操作系统设计时保证；软实时只要按照任务的优先级，尽可能地完成任务操作即可

硬实时操作系统：完全满足在指定时间内完成关键行为。

硬实时操作系统严格规定了限定时间内必须完成任务，否则会导致严重后果发生。如在自动驾驶场景下，车辆前置摄像头模块，短距长距雷达及助力转向等模块需要连续采集处理数据，并通过算法输出决策行为。其中，系统必须在指定时间内完成对输入的采集数据完成运算及处理，并完成输出。假设方向盘转角，节气门等驾驶相关控制信号若无法确保实时性，自动驾驶系统的安全性将无法保证。

常见的硬实时操作系统有VxWorks，ThreadX、FreeRTOS、ucOS。

值得提一句的是，VxWorks是世界范围内现役航天，航海，飞机，坦克自动化控制部分使用范围最广的实时操作系统，包括国内网上热度最高的几种军事设备也同使用了此系统。

软实时操作系统：大多数情况下在指定时间内完成关键行为。

软实时系统对处理事件的时间要求是统计学预期，即使在处理过程中偶发出现了时间偏差，也不会对系统造成致命后果。如IP电视解码视频流数据时，可能会出现数据帧的丢失，但即使了，仅是用户视觉上的体验影响，或通过抖动处理，就可以解决图像上的视觉感知问题。

总结就是实时操作系统对操作系统的特性提出了时间上的要求。
- 1. 响应时间：实时操作系统要求任务的响应时间尽可能短，通常在毫秒级别以下。而非实时操作系统对任务响应时间没有严格要求。
- 2. 任务调度方式：实时操作系统通常采用抢占式调度方式，即高优先级任务可以强制中断低优先级任务执行。而非实时操作系统通常采用协作式调度方式，即任务执行完后才会主动让出CPU资源。
- 3. 可靠性：实时操作系统要求系统具有高可靠性，能够保证任务执行的正确性和稳定性。而非实时操作系统对于系统可靠性要求较低，只要程序不崩溃即可。
- 4. 硬件支持：实时操作系统通常需要硬件的支持，如中断控制器、定时器等，以实现对实时任务的快速响应和调度。而非实时操作系统则对硬件支持要求较低。
- 5. 功能模块：实时操作系统提供了一系列专门针对实时应用需求而设计的功能模块，如实时任务调度算法、中断处理机制、进程间通信方式等。而非实时操作系统则更加注重通用性，提供了更加丰富的功能模块，如文件系统、网络协议栈等。

非实时操作系统与实时操作系统相比，**最直接的差别**：

**实时操作系统严格规定了限定时间内必须完成任务，否则会导致严重后果发生。当内核处于相对消耗状态时，非实时操作系统处理延时会增加，甚至无法保证最高优先级任务执行的最后时限。**

### （3）、 分时操作系统

对于分时操作系统来说，它更加强调的是任务是否能否完成，能够在操作系统有四个基本特征下完成用户给定的既定任务即可。

### （4）、 宏内核

### （5）、 微内核

宏内核（Monolithic Kernel）和微内核（Microkernel）是操作系统内核的两种设计架构。宏内核与微内核的主要区别在于，宏内核将大部分系统功能直接实现在内核中，而微内核只实现最基本的功能，其他功能则通过进程间通信来实现。

宏内核是一种将大部分系统功能都直接实现在内核中的操作系统内核设计。这种设计的优点在于，它具有非常高的执行效率和良好的操作系统资源管理能力，因为操作系统资源可以直接在内核中实现。另外，宏内核可以减少进程间通信带来的性能损失，并提高系统的执行速度。然而，宏内核的缺点在于，由于所有组件都在内核中实现，内核的代码量非常大，因此宏内核的可靠性和安全性也存在问题。

微内核则是一种只实现最基本功能的操作系统内核设计。这种设计的优点在于，它可以避免操作系统内核越来越大的问题，减少内核的复杂性、提高内核的安全性，使得内核更加稳定、可靠。但是微内核的缺点在于，它往往需要使用进程间通信等方式来实现某些功能，这些方式往往会降低系统的执行效率。

总之，宏内核与微内核是操作系统内核的两种设计架构。宏内核将大部分系统功能直接实现在内核中，而微内核只实现最基本的功能，其他功能则通过进程间通信来实现。在实际应用中，这两种内核的设计都有各自的优点和缺点，程序员可以根据具体的应用场景来选择其中之一。

操作系统内核的几个重要的特点：

- 内核是操作系统的核心部分，它管理着系统的各种资源
  
- 内核可以看成连接应用程序和硬件的一座桥梁，是直接运行在硬件上的最基础的软件实体
  
- 在一些简单的硬件设备上可以没有内核或操作系统而直接运行程序，比方单片机等。这些设备通常只是用于特定的场合，也通常功能比较单一。而对于一般计算机来说操作系统是必不可少的。对不同的操作系统，其内核实现也是有所区别的。
  
- 目前从内核架构来划分，可分为微内核(Micro Kernel)和宏内核(Monolithic Kernel)，“宏内核”这个翻译其实不是很好，翻译成“单内核”事实上更好一点。
  
- 对于微内核，用户服务和内核服务分别运行在不同的地址空间中；对于宏内核不管是用户服务还是内核服务事实上都是内核在统一管理，它们是运行在同一地址空间中的。

我们需要好好理解第5点，也就是用户服务和内核服务运行的地址空间的问题。大家都知道Linux采用的是宏内核，但是它也区分内核空间和用户空间，那不是有歧义了吗？我们先看一张图。

![](https://i0.hdslb.com/bfs/article/694bb5955d88499c7e85eec368f3c67237300cd4.png@1256w_722h_!web-article-pic.avif)

对于Linux来说，不管是应用还是内核都是由内存管理单元来做统一的内存管理的，用户空间的程序确实不能访问内核空间，但是对于内核来说，3GB-4GB的线性地址空间对整个内核都是共用的，同时内核中的VFS、System Call等模块被划分到内核中，它们之间的地址空间是相同的，这里的用户服务按照我的理解就是这几个内核模块所需要的报备，如上图所示。

我们来列张表来对比一下微内核和宏内核的具体区别：

![](https://i0.hdslb.com/bfs/article/964fe93bf104e5d0fd89d4059bbf659e34a7949f.png@1256w_608h_!web-article-pic.avif)

核管理着所有的系统资源，在微内核中用户服务和内核服务在不同的地址空间中实现。在应用程序和硬件的通信中，内核进程和内存管理的极小的服务，而客户端程序和运行在用户空间的服务通过消息的传递来建立通信，它们之间不会有直接的交互，这样一来，微内核中的执行速度相对就比较慢了，这是微内核架构的一个缺点。 

在内核架构中，用户服务是独立于内核服务的，因此任何用户服务崩溃都不会影响到内核服务，这就加强了操作系统的健壮性，这是微内核的优势所在。另一点，微内核的扩展性强，添加一个功能，只需要建立一个新的服务到用户空间当中，而内核空间不需要任何的修改。因此，微内核可移植性强、安全并且易于扩展。

宏内核定义：

宏内核同样管理着用户程序和硬件之间的系统资源，但是和微内核不一样的是，在宏内核架构中，用户服务和内核服务在同一空间中实现。具体一点，就是内核可以代表内核进程运行代码，就是通常的内核进程；当用户进程经过系统调用或者中断进入到内核态时，内核也可以代表它运行代码。这样一来，宏内核需要管理的资源多于微内核，其大小就相对大一些了。

在宏内核架构当中，内核管理着CPU调度，内存管理，文件管理和系统调用等各模块的的工作，由于用户服务和内核服务被实现在同一空间中，这样在执行速度上要比微内核快。然而，宏内核的劣势也是显而易见的，那就是当内核中的某个服务崩溃了，整个内核也会崩溃。另一点，想要在内核中添加新的功能就意味着内核中的各个模块需要做相应的修改，因此其扩展性很弱。

内存管理的区别：

宏内核在内核空间就实现了系统所有内存管理所需的一切业务，包括内存分配策略、虚拟内存管理分页算法等，如下图所示： 

![](https://i0.hdslb.com/bfs/article/727adfc20e97b769d519cd019bb27d114708449e.png@1256w_992h_!web-article-pic.avif)

对于微内核的内存管理实现，有一个发展过程。在第一代的微内核架构中，内核代理了用户空间的内存管理，控制着内存访问的权限，如下图所示。

![](https://i0.hdslb.com/bfs/article/c10db9a0acc58a8976fa590c0afbc19932791c42.png@1256w_940h_!web-article-pic.avif)

内核中的某个服务负责管理缺页异常并保存新分配的页，只要有缺页异常发生，请求就经过内核通知页管理器。页管理器必须进入特权模式下来获取内存的访问，然后回到用户模式下。然后发送一个返回结果来触发进程，当然这个过程也是需要经过内核的。处理缺页异常或者保存新分配页的整个过程是繁复而耗时的。

为了弥补性能上的损失，之后的微内核构架在内存管理上作了相应的改变。每个进程有3个内存管理原语(Primitves)：map、grant和flush。如果进程想要共享它的内存页那么它的可以通过map来映射内存页给其它进程。当进程通过grant来让渡它的内存页给其它进程之后，该进程就丧失了这些内存页的访问权，直到让渡进程不再刷新它们。如此一来，整个系统运行过程就成了这样：在系统启动时，内核将所有内存保存到一个叫做基本的系统进程 (basic system process) 当中，当然这个所谓有基本进程是运行在用户空间中的，如果其它进程需要内存，就是再需要从内核中获取，它可以直接向这个基本的系统进程索取。

![](https://i0.hdslb.com/bfs/article/fec58d4c8912ce27bb70df8f7d0d992968a7741b.png@1256w_1138h_!web-article-pic.avif)

其它模块的区别：

微内核和宏内核在设计上还存在一些其它的区别，比方IO管理方面，宏内核的设备驱动直接在内核中实现，硬件中断也直接在内核中处理；但是在微内核中，内核是不直接处理IO中断管理的，来自硬件的请求将被重定向到用户服务中去，比方内核捕获了一个中断，那么内核发送给设备驱动服务就完事了，设备驱动服务会去处理这个中断。

总结：

微内核效率比宏内核慢，但在安全性、可靠性方面要比宏内核好，在扩展性方面微内核也有优势。

从内核构架发展趋势来说，将来或许会有比Linux更为强劲的基于微内核架构的OS出现，让我们拭目以待吧！ 

## 2. 开发环境搭建

### （1）、 GCC

### （2）、 Makefile


## 3. 常用 Linux c 函数

## 4. Linux 进程

## 5. 守护进程

## 6. 线程

## 7. 线程属性

## 8. 线程同步异步

## 9. IPC

## 10. 网络编程

# 第三章：软件调试

## 1. GDB 

## 2. Linux 栈回溯



# 第四章：图形显示

## 1. Framebuffer 概念

## 2. GUI 概念

## 3. 信号与槽



# 第五章：大容量数据存储

## 1. SQL

# 第六章：软件框架设计

## 1. C 程序的背后

## 2. 面向对象编程

## 3. extern_C 关键字



# 第七章：交叉开发
### （1）、 交叉编译环境
####  STM32 交叉编译环境
## 1. 嵌入式 Linux 系统环境组成

## 2. rftp_nfs_dnw 的作用

## 3. ext4 文件系统

# 第八章：系统内核

## 1. 嵌入式操作系统的构建方法

## 2. uboot 的功能和作用

## 3. uboot 编译与配置

## 4. Linux 内核配置

## 5. 添加一个 Linux 源码文件

## 6. busybox 功能和作用

# 第九部分：驱动程序

## 1. Linux 设备驱动

## 2. Linux 内核模块的加载卸载

## 3. Linux 字符设备驱动摸板

## 4. Linux 驱动中的信号量与自旋锁

## 5. Linux 驱动中断的常用函数及作用

## 6. Linux 驱动 platform 虚拟总线

## 7. IPCC 通信框架

## 8. OpenAMP









# 符录



# 参考文献



# 索引





操作系统宏内核和微内核区别 https://www.bilibili.com/read/cv23329414/

4岁小女孩修改一个字符获网友狂点赞https://www.linuxprobe.com/four-years-linux.html

操作系统的四个基本特征是什么:[https://www.php.cn/faq/495187.html](https://www.php.cn/faq/495187.html)

实时性操作系统和非实时性操作系统的概念及区别https://blog.csdn.net/Dinh_ding/article/details/125780067

车载实时操作系统与非实时操作系统https://zhuanlan.zhihu.com/p/84148986

Linux 中有哪些不同类型的 Shell？https://zhuanlan.zhihu.com/p/614551538


 LINUX过时了 https://www.cnblogs.com/coder-dreamer/archive/2013/01/11/2856642.html

Linux——用户、用户组管理和文件权限（8）https://zhuanlan.zhihu.com/p/424584330

嵌入式保姆级教程-一文讲解出Linux的文件目录结构 https://zhuanlan.zhihu.com/p/624152435

