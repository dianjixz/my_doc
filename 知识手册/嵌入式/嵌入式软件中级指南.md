<center>嵌入式 Linux 软件指南</center>

# 序言

# 目录



# 第一章：Linux 概论

## 1. Linux 操作系统历史

### (1)、创世纪的 UNIX

描述历史就是追溯鸡生蛋，蛋生鸡的过程。追溯 Linux 的历史，公认的开始是 UNIX 的诞生。

UNIX 操作系统是由肯•汤普森（Ken Thompson）和丹尼斯•里奇（Dennis Ritchie）合作创造的。关于 UNIX 的部分技术思路则是来源于当时的大型机 Multics 工程计划，该计划是由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是取代当时的批处理操作系统，拥有多道程序的分时处理能力，能够同时为多个机构和公司提供计算支持。这个愿望是非常美好的，美好到以至于目标太过于庞大与空洞，导致 Multics 的开发人员都不知道该做成什么样子才能满足公司对这个工程的要求，所以计划失败了。Multics 虽然失败了，肯•汤普森的故事还在继续。

![Multics 计划 logo](https://bkimg.cdn.bcebos.com/pic/a71ea8d3fd1f41347fd8fcea251f95cad0c85eb3?x-bce-process=image/resize,m_lfit,w_536,limit_1/quality,Q_70)

肯•汤普森出于自己玩 Space Travel 的需求在 Multics 失败后，决定编写一个较小的操作系统来替代 Mutics，小到能够运行在 Digital PDP-7 小型机上。肯参考了 Mutics 中的一些功能设计，编写出了一个能够满足基本功能的分时操作系统。同组人员为了调侃这个只支持两个用户的系统便称这个系统为 UNICS（Uniplexed Information and Computing System）。后来，随着 UNICS 这个名字的传播，谐音的 UNIX 明显更受大家欢迎，于是这个分时系统被正式命名为 UNIX 。

![Space Travel](https://picx.zhimg.com/23483b4703dcfef4729005f64184a0ef_r.jpg?source=1def8aca)

UNIX 最初是由汇编编写的，运行在上面的一些应用则是由 B 语言和汇编语言混合编写而成。由于 B 语言在进行系统编程时总是处处受挫，所以汤普逊和里奇对其进行了改造和扩展，完成后的语言和原来的 B 语言差异较大，所以被命名为 C 语言。C 语言的高效和强大使得编写操作系统变成了可能。汤普逊和里奇在 1973 年中用 C 语言重写了 Unix ，这个首次不是用汇编编写的操作系统成为了当时操作系统届最大胆的创新，也非常具有革命意义。C 语言的简洁紧凑、易移植、易读、易修改的特性赋予了 UNIX 强大的生命力，为 UNIX 的发展奠定了坚实的基础。

1974 年，汤普逊和里奇合作在 《ACM通信》上发表了一篇关于 UNIX 的文章《The UNIX Time-Sharing System》。这篇文章系统的介绍了 UNIX 的目标与实现，UNIX 特性：采用 C 高级语言编写、简单的用户交互 Shell 、高效便捷的树形文件系统、文件，设备，设备的统一处理、内核和核外程序的有机组合、丰富的系统程序。当时计算机大多还处于批处理阶段，这样的系统迅速的在计算机存在的地方运行了起来。

UNIX 的流行和发展并没有给诞生它的 AT&T 公司带来多少利益，但是 AT&T 却在 UNIX 中做了不少的投入。为了取得回报，1982年，AT&T 基于版本 7 开发了UNIX System Ⅲ 的第一个版本，这是一个商业版本仅供出售。同时这个新的 UNIX 商业发布版本不再包含源代码。

UNIX 的哲学 KISS（keep it simple, stupid）成为了程序开发的基础哲学之一。

### (2)、UNIX 与 MINIX

20世纪80年代，由于 AT&T 所有的 UNIX 版权的限制和闭源的操作，荷兰的 Andrew S. Tanenbaum 教授在 1987 年决定写一个不包含任何 AT&T 源代码的 UNIX 系统，名为 MINIX（即小型的 UNIX ），并开放全部源代码给大学教学和研究工作，Minix 于 2000 年重新改为BSD授权，成为自由和开放源码软件，为全球注册商标。

![](https://bkimg.cdn.bcebos.com/pic/8ad4b31c8701a18b87d674c93667100828381f305056?x-bce-process=image/resize,m_lfit,w_536,limit_1/quality,Q_70)

MINIX 属于微内核，对于宏内核的 UNIX 来说，它的内核更小，提供的功能也仅限于线程管理，内存管理和进程间通信。其余的如文件系统，设备驱动等，都是由多进程的组件提供。这种驱动由进程隔离的方式使得系统的各种服务不会相互的影响，同时缺点也是致命致命的，频繁的系统调用会造成频繁的进程切换，而系统切换带来的性能损失是不不可忽略的。

MINIX 的设计目标就是用于大学的教学和研究，所以作为它的开发者 Andrew S. Tanenbaum 教授不愿意在这个系统上添加过多的功能。MINIX 的诞生在计算机历史上并没有掀起多大的波浪，但是它为计算机的教育事业作出的贡献确实巨大的。MINIX 之父 Andrew S. Tanenbaum 的经典之作《操作系统设计与实现》，给 Linux 操作系统的创造者 Linus Torvalds 带来了很大的启发，而 Linux 给世界带来了巨大的改变。

### (3)、LINUX

在同一时刻，操作系统届有着百花切放，百家争鸣的现状。MINIX 虽然也开源，但是其教育系统的特性不愿意添加太多的代码，使其一直停留不前。同为微内核 GNU Hurd 内核由于设计的激进也是迟迟的难产。由 UNIX 衍生出的各种 UNIX 系操作系统大多是闭源的，BSD 虽然为开源系统，但其和 UNIX 的司法官司一直打到了 1994 年 1 月。这桩法律诉讼将 BSD 后续的开发，特别是自由软件，延迟了两年，而没有法律问题的 Linux 内核在这段时间获得了极大的支持。Linux 跟 386BSD 的开发几乎同时起步，Linus 说，当时如果有自由的基于 386 的 Unix-like 操作系统，他就可能不会创造 Linux 。

Linux 内核最初是由林纳斯•托瓦兹（Linus Torvalds）在赫尔辛基大学读书时出于个人爱好而编写的，当时他只是觉得教学用的迷你版 UNIX 操作系统 Minix 能用的东西太少了，也可能是出于实用主义。于是决定自己开发一个操作系统。第 1 版本于 1991 年 9 月在 MINIX 的新闻组论坛上发布，当时仅有 10000 多+行代码。刚开始只有很少的操作系统爱好者在讨论这个系统，并为这个操作系统编写补丁和更多的支持。随着 Linux 在爱好者的支持下，系统越发的完善，论坛上讨论 Linux 的声音也越来越多。渐渐最初的 MINIX 论坛上只剩下讨论 Linux 的声音了。Linux 最初的名字叫 FreaX ,寓意“自由”以及“奇特”,最后带上了一个常用字母X作为结尾,类似与 Unix 之类的系统一样。但是后来以为管理员觉得 FreaX 不好听,而且难念,所以就改成了 Linux ,前面直接取自开发者 Linus ,加上 X 后缀就成了 。

继承于 UNIX 的传统，标准的 POSIX 操作系统接口，开源的特性以及合适的操作系统空窗期让 Linux 在全世界快速的流行起来。随着全世界的工程师的参与，Linux 具备了一个现代操作系统所有的属性：多任务处理（Multitasking）、多用户支持（Multiuser）、虚拟内存（Virtual Memory）、文件系统（File System）、设备驱动程序（Device Drivers）、网络支持（Networking）、安全性（Security）、任务调度（Scheduling）、错误检测和恢复（Error Detection and Recovery）、用户界面命令解释器（Shell）、图形用户界面（Graphical User Interface，GUI）。而在其之上的各种应用软件生态覆盖了各行各业。Linux 运行在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。

严格来讲，Linux 这个词本身只表示 Linux 内核，但实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统。

Linux 是一个开源系统，开源也是 Linux 最大的优势。林纳斯•托瓦兹没有保留 Linux 源代码的版权，在公开源码的同时欢迎任何人给 Linux 提供修改代码。同时 Linux 也是免费的，意味着你可以不花一分钱就可以使用到 Linux 强大的操作系统和完善的软件生态。为了更好的管理和协作，Linux 加入了自由软件基金会，有自由的 GPL 许可证。

1996年，Torvalds 为 Linux 选定了企鹅作为它的吉祥物。Larry Ewing 提供了吉祥物的初稿。为什么是一只企鹅，据说是因为 Linus 小时候被企鹅咬过，也有解释是企鹅是南极洲的标志性动物，根据国际公约，南极洲为全人类共同所有，不属于世界上的任何国家，任何国家都无权将南极洲纳入其版图。Linux 选择企鹅图案作为 Logo，其含义是：开放源代码的 Linux 为全人类共同所有，可公司无权将其私有。

![](https://pic4.zhimg.com/80/v2-936b11fb628712db171781e13babe647_720w.webp)

Linux 拥有庞大的社区和社区管理人员，Linus 拥有 Linux 代码的裁定权，能够决定什么样的代码能够合并到 Linux 内核中，而 Linux 各个系统的管理员会审核其他开发者给提交到 Linux 子系统的代码，经过测试后提交给 Linux 等待合并。如同 Linux 的树形文化一样，Linux 社区也呈现出完全树型的结构。层层的管理级别并没有拖乱 Linux 的发展进度，Linux 内核可以让所有人参与进来，非常严谨，只要有错误，任何人都可以修改它。在 Linux git 仓库中的 commit 号为 690b0543a813b0ecfc51b0374c0ce6c8275435f0 的补丁就是一位小女孩提出的。

![](https://www.linuxprobe.com/wp-content/uploads/2020/01/four-years-linux-01.png)

虽然只是添加了一个字符，但是更改的理由是补丁作者的女儿发现那个 「 s 」字母很孤单，用她的话说是不开心，加上「 - 」后就显得开心了。最终 Linus 同意了这个补丁的合并请求，因为 Linux 是严谨的，人人可参与的。

Linux 的社区非常的活跃，全世界的开发者都在为 Linux 的驱动做着贡献。Linux 的可移植性使得 Linux 往往会被很快的移植到新的 CPU 设备中。就这样硬件成就着软件，软件也在成就着硬件。
- 1983年：Richard Stallman创建了以创建一个自由的操作系统为目标的GNU计划。

- 1989年：Richard Stallman撰写了第一版的GNU GPL。

- 1991年：第一个版本0.0.2发布，代码只有约一万行
- 1992年：Linux0.96拥有4万行代码，大约1000人使用且大部分是黑客
- 1993年：Linux0.99发布，代码量10万行，用户约2万，采用GUN的GPL协议
- 1994: 3月, Torvalds认为内核的所有组件已经完全成熟，他放出了Linux的1.0版本。XFree86项目组提供了一个图形化用户界面（GUI）.同年Red Hat公司 和SUSE 发行了他们各自的Linux 1.0分发版本。
- 1995: Linux被移植到DEC Alpha和Sun公司的SPARC平台上，而在接下来的几年里它又被广泛地移植到更多的平台上。
- 1996: Linux内核2.0版本发布。此时内核已经支持多处理器，因而成为各大公司的绝佳选择。
- 1998：很多大公司，诸如IBM, Compaq ，Oracle表示支持Linux系统。另外，一部分程序员开始了图形化用户界面KDE的开发。
- 1999：一些程序员开始致力于开发图形化环境GNOME，它可以替代依靠Qt工具包才能工作的KDE。在这一年里IBM宣布了一项支持Linux的浩大的工程。
- 2004: XFree86小组分裂，同现有的X Windows标准组织 共同成立[http://X.Org](https://link.zhihu.com/?target=http%3A//X.Org)基金会，促使了X Window ServerLinux版本极其快速而迅猛的发展。

![](https://pic3.zhimg.com/80/v2-0f9b725e91a49106a6b55bb4ebd91d8a_720w.webp)

![](https://pic4.zhimg.com/80/v2-f3da4e95700ef4eb7d0cea8d003f7f17_720w.webp)

![](https://pic3.zhimg.com/80/v2-b6f0db275df13e21d5a3fbd84a263802_720w.webp)



Linux 的历史也不是一片平坦，在其刚发布的时候就引来了“Linux 已经过时的言论”。

1992 年，MINIX 的作者 Andrew S. Tanenbaum，在新闻组 comp.os.minix 上发表了一篇 [《LINUX is obsolete》](https://www.oreilly.com/openbook/opensources/book/appa.html)的文章，批判了在 1991 年写一个宏内核系统真是一个糟糕的主意。Linus 也有力的回击了 Andrew 的评论，如果微内核当前已经成熟可用的话，他也不用大费周章的编写 Linux 操作系统了。但在21世纪的现在来看，Linux 系统经受住了历史的考验，我们的 Linux 系统依然稳健的运行在各类硬件上。

自由与商业的竞争。苹果曾聘请过 Torvalds ，因为理念不和而分道扬镳。微软和 Linux 阵营在 1997 年到 2001 年间还是有着很多敌对的情况。这种情况在 1998 年 Eric S. Raymond 发表《万圣节文件》的时候变得明显起来。这里由一位微软工程师写的关于寻求解决自由软件对微软的威胁的策略的文章。

SCO-Linux 争议。2003 年 3 月，SCO  Group 指责 IBM 把 UNIX 的代码移植到 Linux 侵犯了他们的版权。SCO 声称它们拥有代码的版权并 IBM 提起了诉讼。Red  Hat 又提起了反诉讼，因此 SCO 又提起了其他相关的诉讼。在这些诉讼进行的同时，SCO 开始把 Linux 的许可权卖给那些不愿意冒受 SCO 投诉的险的用户。因为 Novell 也声称拥有 UNIX 的版权，所以它又对 SCO 提起了诉讼。接着 SCO 便声明破产了。

Linux 诞生的时候并没有多么注意商标，虽然一直使用 Linux 的名称。直到从 1994 年开始，越来越多不同国家的人想要将 Linux 注册成自己的商标然后收取金。Linux 的开发人员非常反感这种做法，后来，Torvalds 在 Linux 国际的帮助下得到了 Linux 这个商标，随后他把这个商标转让给了 Linux 国际。目前这个商标的保护由一个专门的基金会——非营利性的Linux标识协会——来管理。






## 4. linux 操作系统和常用命令

### （1）、认识 Linux

Linux 是一个现代操作系统内核，它提供的主要功能是管理好计算机中的硬件，尽可能的屏蔽好各类硬件的差异，为计算机中的软件提供一个标准的统一调用接口。为什么要拥有一个这样的内核呢，这涉及到软件和硬件的协调了。软件是运行在硬件之上的，更具体的说是 CPU 中央处理器提供了基本的动作，这些动作被称为指令集，我们编排好一条条指令，这些指令按照规则组合起来后，就可以称之为软件，软便是松软可变动的意思，意味这软件是随时可变的。但是硬件不一样，硬件在制造好之后，就不会再改变了。在今天，我们研发出了各种个样的硬件，就比如组成计算机的几大件：CPU、内存、硬盘、主板、鼠标、键盘等，不同的厂商造出来的东西都不一样。同样的，不同的硬件就会用不同的动作，不同的动作对应着不同的指令，软件如何想让这些硬件正常的工作起来，那就要添加各种动作，编写软件的人还要思考如何协调好这么多的硬件。面对着越来越庞大的计算机体系，个人的能力是非常有限的，要多个人考虑合作。而考虑合作，就需要有序的沟通，所以对于计算机来说，操作系统内核就出来了，有人负责整个操作系统架构，有人负责具体的各个硬件驱动，也有人负责写其他的程序，需要的时候调用这个操作系统提供的接口就可以了。这下不同的事情就可以交给不同的人来做，分工好了，面对再复杂的事情我们都能化整为零完美解决了。

#### 内核

计算机软件份大致分为两类：系统软件和应用软件。系统软件的任务是管理自身和计算机硬件，应用软件是用来执行用户需要的功能。内核是最基本的系统软件，它是计算机中所有应用软件运行的基石。

#### 用户

Linux 相当于一座大房子，Linux 的用户则相当于房子的主人或者房子的住户，Linux基于用户身份对资源访问进行控制。

Linux 用户账号分为三类：

- 超级用户：root用户是Linux操作系统中默认的超级用户账号，对本主机拥有最高的权限，系统中超级用户是唯一的。
- 普通用户：由root用户或其他管理员用户创建，拥有的权限会受到限制，一般只在用户自己的宿主目录中拥有完整权限。
- 程序用户：在安装Linux操作系统及部分应用程序时，会添加一些特定的低权限用户账号，这些用户一般不允许登录到系统，仅用于维持系统或某个程序的正常运行，如bin、daemon、ftp、mail等。


#### 用户账户管理

![](https://pic4.zhimg.com/80/v2-21b7350d259da17d71424ea85e3e7c5f_720w.webp)

与 Linux 用户相关的文件为 /etc/passwd。

```bash
nihao@nihao-z690:~$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
kernoops:x:113:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin
avahi:x:114:121:Avahi mDNS daemon,,,:/run/avahi-daemon:/usr/sbin/nologin
nihao:x:1000:1000:nihao,,,:/home/nihao:/bin/bash
sshd:x:129:65534::/run/sshd:/usr/sbin/nologin
```

/etc/passwd是一个系统文件，而不是目录。它是一个文本文件，用于存储系统中所有用户账户的基本信息。

每一行代表一个用户账户，字段之间使用冒号进行分隔，通常包含以下信息：
```
[用户名]:x:[UID]:[GID]:[用户描述信息]:[主目录]:[登陆后默认使用的 Shell]
```
- 用户名：标识用户的唯一名称。

- 密码占位符：在过去，密码哈希值存储在此处，现在则通常为 "x" 表示密码已被移动到 /etc/shadow 文件中。
- 用户标识号（UID）：每个用户都有一个唯一的数字标识。
- 组标识号（GID）：指定用户所属的主要组的标识号。
- 用户描述信息：包含有关用户的备注信息或全名等。
- 主目录：用户登录后的起始目录。
- Shell：定义用户登录后默认使用的 shell。

**useradd 添加用户**

基本语法：useradd 用户名（功能描述：添加新用户）

案例：[root@~]#useradd hadoop

**userdel 删除用户**

基本语法：

userdel 用户名（功能描述：删除用户但保存用户主目录）

userdel -r 用户名（功能描述：用户和用户主目录，都删除）

案例：

删除用户但保存用户主目录: [root@~]#userdel hadoop
删除用户和用户主目录:[root@~]#userdel -r hadoop

**passwd 设置用户密码**

基本语法：passwd 用户名（功能描述：设置用户密码）

案例：
![](https://pic4.zhimg.com/80/v2-3e8cc86c046bc965ecbd978bbb06f1db_720w.webp)

**id 判断用户是否存在**

基本语法：id 用户名

**su 切换用户**

基本语法：

su 用户名称（功能描述：切换用户，只能获得用户的执行行权限，不能获得环境变量）su - 用户名称（功能描述：切换到用户并获得该用户的环境变量及执行权限）

案例:
```bash
[root@~]#su hadoop
[root@~]#su - hadoop
```

**who查看登录用户信息**

基本语法:

whoami（功能描述：显示自身用户名称）
who am i（功能描述：显示登录用户的用户名）
who（功能描述：看当前有哪些用户登录到了了本台机器器上）

#### 用户组管理

Linux作为多用户、多任务的系统，为了提供更好的用户管理和权限控制机制，使系统管理员能够更高效地管理用户、控制权限，并对文件和目录进行适当的保护。其引入了用户组概念，通过用户组可以简化管理过程，提高系统的安全性和可管理性。

- 基本组（私有组） ：基本组账号只有一个，一般为创建用户时指定的组。
- 附加组（公共组） ：用户除了基本组以外，额外添加指定的组。附加组可以有多个，可以在基本组，也可以同时在附加组
![](https://pic2.zhimg.com/80/v2-4aeee6118ec5bd090012ea1ee0bce729_720w.webp)

"/etc/group" 是 Linux 系统中的一个文件，用于存储系统中所有用户组的信息。每一行代表一个用户组，它包含了用户组的名称、组密码（通常为空）、组标识号（GID）以及属于该用户组的用户列表。

**groupadd 新增组**

基本语法: groupadd 组名

案例：

增加一个 hadoop 组：groupadd hadoop
**groupdel 删除组**

基本语法：groupdel 组名

案例：

删除 hadoop 组：groupdel hadoop
**groupmod 修改组**

基本语法：groupmod -n 新组名 老组名

案例：

修改 hadoop 组名称为 hadoop1 : groupmod -n hadoop1 hadoop
**查看创建了哪些组**

基本语法：cat /etc/group
**usermod 修改用户所属组**

基本语法：usermod -g 用户组 用户名

案例：

将用户 hadoop 加入 mygroup 用户组：sermod -g mygroup hadoop


#### 用户的密码管理

![](https://pic3.zhimg.com/80/v2-de0c892d876e182503ad0c669fa59a42_720w.webp)

>注意：只有root管理员才可以修该其他用户的密码，普通账户只能修改自己的密码，并且普通用户没有修改其他用户密码的权限

在linux密码管理中，我们还应该熟悉密码策略的配置，如：

密码策略：可以通过配置文件或者命令来设置密码策略，以限制密码的复杂度和有效期限。密码策略通常包括以下内容：

- 密码长度：设置密码的最小长度要求。
- 复杂度要求：可以要求密码包含字母、数字、特殊字符等不同类型的字符。
- 历史密码限制：禁止用户在一段时间内重复使用先前使用过的密码。
- 密码有效期：设置密码的有效期限，过了有效期后需要用户更改密码。
- 警告通知：在密码即将过期之前发送警告通知给用户。

`chage` 命令：`chage` 命令用于修改用户的密码策略，比如修改密码过期时间、密码失效时间等。可以使用 `chage -l username` 查看用户当前的密码策略信息，使用 `chage -m` 修改密码最小长度，使用 `chage -M` 修改密码有效期等。

`/etc/pam.d/` 目录中的配置文件：PAM 是 Linux 中的身份验证管理机制，可以通过修改 `/etc/pam.d/` 目录下的文件来配置密码策略。常见的文件有 `common-password` 和 `system-auth` 等，可以在文件中配置密码策略规则。

密码加密算法：Linux 使用密码哈希算法（如 MD5、SHA-256、SHA-512）将用户密码进行加密存储，以确保密码的安全性。

`/etc/shadow`是一个重要的系统文件，它存储了用户的加密密码和相关的账户信息。该文件只能由系统管理员或具有特权的用户访问。其中包含了每个用户账户的密码哈希值、上次修改密码的时间、密码过期时间、账号是否被锁定等信息。这里的密码哈希值是用户密码经过加密处理后的结果，实际密码并不存储在该文件中。通过将用户输入的密码与保存在`/etc/shadow`中的密码哈希值进行比对，系统可以验证用户的身份。

#### 用户的权限管理

>Linux系统一般将文件可存/取访问的**身份**分为 3 个类别：owner、group、others，且 3 种身份各有read、write、execute等**权限**。

在多用户（可以不同时）计算机系统的管理中，权限是指某个特定的用户具有特定的系统资源使用权力，像是文件夹、特定系统指令的使用。

**常见权限**

在 Linux 中，文件和目录的权限是由三个基本权限位来控制的，分别是读取权限（r）、写入权限（w）和执行权限（x）。这些权限位可以分别应用于文件的所有者、所属组和其他用户。以下是更详细的说明：

- 读取权限（r）：读取权限允许用户查看文件的内容或目录的列表。对文件而言，具有读取权限的用户可以读取文件的内容；对目录而言，具有读取权限的用户可以列出目录中的文件和子目录。

- 写入权限（w）：写入权限允许用户修改文件的内容或目录的结构。对文件而言，具有写入权限的用户可以编辑或修改文件的内容；对目录而言，具有写入权限的用户可以创建、删除或重命名文件和子目录。

- 执行权限（x）：执行权限允许用户执行可执行文件或进入目录。对文件而言，具有执行权限的用户可以运行该文件作为程序；对目录而言，具有执行权限的用户可以进入该目录并访问其中的文件和子目录。

- 设置权限：可以使用 chmod 命令来设置文件和目录的权限。例如，使用以下命令将文件设置为所有者可读写，所属组和其他用户只可读取的权限：

- 特殊权限：除了基本权限位，还存在一些特殊权限位，如 SUID、SGID 和 sticky 位。SUID 权限允许在执行文件时临时获得文件所有者的权限，SGID 权限允许在执行文件时临时获得文件所属组的权限，sticky 位用于目录，防止其他用户删除其他人的文件。

可以使用 ls -l 命令来查看文件和目录的详细权限信息。列表中的第一列显示了权限位的设置情况，如 rwxr-xr--。

![](https://pic3.zhimg.com/80/v2-87c6be492faf7ccebd7e9f1acc83409a_720w.webp)

按照字母位置解释：

![](https://pic1.zhimg.com/80/v2-2150ac4b29617b061122ab717b627abc_720w.webp)

权限分段，每一段代表不同的用户：

- 属主权限：当前文件所属用户的权限，在Linux中每一个文件都有所属的用户
- 属组权限：当前文件的用户所在组的其它成员的权限其它
- 用户权限：跟文件所属用户不在同组的其它用户的权限

![](https://pic1.zhimg.com/80/v2-d68f20badbb7435374feae16545c3918_720w.webp)



#### sudo 权限

sudo 是一个独立的程序，需要安装和配置才能使用。通常情况下，sudo 配置文件位于 /etc/sudoers 或 /etc/sudoers.d 目录下，可使用 visudo 命令编辑该文件。

sudo 可以根据需要为不同的用户或组分配不同的授权和限制。通常情况下，授权的方式是通过添加条目到 sudoers 文件中实现的。可以使用  ALL 表示所有命令，也可以使用特定的命令或命令列表。可以限制用户仅能在特定的终端或特定的时间段内执行 sudo 命令。

一旦配置了 sudo，普通用户可以使用 sudo 命令以管理员身份执行需要的命令。需要在命令前加上 sudo 关键字，按提示输入账户密码即可。如果用户未被授权执行该命令，则会收到错误提示。

由于 sudo 具有很高的权限，因此必须谨慎使用。可以对关键命令进行审计，查看用户是否滥用了权限。可以使用特定的日志工具监控 sudo 命令的执行记录。此外，要定期更新系统和软件以确保系统安全。

超级管理员是一个特殊的用户，具有系统的最高权限。在 Ubuntu 中，默认情况下没有启用 root 用户或超级管理员账户，而是使用 sudo 权限管理来代替直接使用 root 权限。因此，Ubuntu 用户通常需要使用 sudo 命令来执行管理员任务。

#### sudo 与 su

> su是最简单的身份切换，用su我们能够进行各种用户的切换，一般都是su - username，然后输入password (注意：这里的密码不会在屏幕中显示出来)，root 用 su 切换到其它身份的时候无需输入 password 。

在 Linux 中，`su` 和 `sudo` 是用于切换用户身份的命令，但它们在功能和使用方式上有一些区别：

**`su`（Switch User）命令：**

功能：`su` 命令用于切换到其他用户账号，并且可以切换为超级用户（root）。

使用方式：默认情况下，使用 `su` 命令需要输入目标用户的密码。例如，使用 `su username` 可以切换到名为 "username" 的用户账号，或使用 `su` 切换为超级用户。

特点：切换为目标用户后，会进入该用户的环境，包括工作目录、环境变量等。

**`sudo`（Superuser Do）命令：**

功能：`sudo` 命令允许普通用户以其他用户（通常是超级用户）的权限来执行命令或操作。

使用方式：使用 `sudo` 命令时，需要输入当前用户的密码，而不是目标用户的密码。例如，使用 `sudo command` 可以以超级用户权限执行指定的命令。

特点：通过 `sudo` 执行的命令会在日志中留下记录，以便审计和追踪。

**区别总结如下：**

`su` 是切换用户的命令，需要知道目标用户的密码，且切换后会进入该用户的环境。

`sudo` 是以其他用户权限执行命令的命令，需要输入当前用户的密码，具有审计和追踪功能。

一般来说，`sudo` 命令更为常用和推荐，因为它提供了更细粒度的权限控制，可以指定哪些用户可以执行特定的命令，从而提高系统的安全性。在使用 `sudo` 命令时，管理员可以将需要临时获取超级用户权限的命令添加到 `/etc/sudoers` 配置文件中，并配置相应的访问权限。

>补充：
>ACL（Access Control List）是一种在Linux系统中用于细粒度控制文件和目录权限的机制。传统的Unix文件权限模型使用9位权限标志（rwxrwxrwx）来控制所有者、所属组和其他用户对文件的访问权限。
>而ACL提供了更加灵活和精细的权限控制，它允许你为特定用户或用户组附加额外的权限。ACL可以应用于文件和目录，并且能够设置不同类型的权限，例如读取、写入、执行以及其他自定义的权限。
>使用ACL，你可以做到以下几点：
>给一个文件或目录授予额外的用户或用户组访问权限，而不仅限于所有者、所属组和其他用户。
>通过ACL为特定用户或用户组添加个别权限，而不是应用通用的文件权限。
>控制默认权限，以便新创建的文件或目录继承父级目录的ACL，而不仅仅是文件权限。
>要在Linux系统中使用ACL，你需要确保文件系统支持ACL并已启用。多数Linux发行版默认开启了ACL功能。可以使用`acl`命令检查文件系统是否支持ACL，使用`getfacl`和`setfacl`命令来查看和修改ACL规则。
>总而言之，ACL提供了更加灵活和细粒度的权限控制机制，使管理员能够更好地管理用户对文件和目录的访问权限。

#### 权限管理

**修改文件权限**:

![](https://pic2.zhimg.com/80/v2-85452b8b4add75ad95bddf1c622c4c41_720w.webp)

**chown 改变所有者**

基本语法：chown 最终用户（功能描述：改变文件或者目录的所有者）

案例：[root@lagoutest]#chown hadoop test1.txt

**chgrp改变所属组**
基本语法：chgrp 最终用户组（功能描述：改变文件或者目录的所属组）
案例：
![](https://pic4.zhimg.com/80/v2-a7916b1314ec8ebd2078e32cb3d2c71f_720w.webp)




#### 用户登录管理

用户登录选项的配置通常在 /etc/login.defs 或 /etc/default/useradd 文件中。可以设置默认的 shell、UID 和 GID 的范围、密码有效期等。可以根据需要进行调整。

使用 usermod 命令可以禁止或允许用户登录。可以通过修改用户账户的 shell 为 /sbin/nologin 来禁止用户登录。例如，使用以下命令禁止用户登录：

```bash
sudo usermod -s /sbin/nologin 用户名
```

可以使用文件权限和访问控制列表 (ACL) 来限制用户对特定文件和目录的访问权限。可以设置文件的所有者和所属组，并设置合适的访问权限。

使用 id、who、w 等命令可以查看用户账户的信息，如用户名、用户 ID、所属用户组、登录状态等。




#### 文件

Linux 内核是要对外提供服务的，而传递服务的对象就是文件。Linux 中有一切皆文件的说法，文件是 Linux 内核向我们展示信息的基本单元，组织文件的系统为文件系统树。使用 Linux 的过程就是我们在 Linux 文件系统树中找到我们需要的文件，然后或者操作，或者读取它，从而达到我们的目的或者获取我们需要的信息。

文件是信息的载体，在 Linux 中，文件存着三种型态：文件本体，软链接和硬链接。

``` bash
# 创建一个 test.txt 空文件
root@M5Core135:~# touch test.txt
# 创建这个文件的硬链接
root@M5Core135:~# ln test.txt ln_test.txt
# 创建这个文件的软链接
root@M5Core135:~# ln -s test.txt lns_test.txt
# 显示创建的文件
root@M5Core135:~# ls -la
total 8
drwxr-xr-x  2 root root 4096 Jul 20 14:22 .
drwx------ 13 root root 4096 Jul 20 14:22 ..
lrwxrwxrwx  1 root root    8 Jul 20 14:22 lns_test.txt -> test.txt
-rw-r--r--  2 root root    0 Jul 20 14:22 ln_test.txt
-rw-r--r--  2 root root    0 Jul 20 14:22 test.txt
# 显示创建的文件描述
root@M5Core135:~# file test.txt 
test.txt: empty
root@M5Core135:~# file ln_test.txt 
ln_test.txt: empty
root@M5Core135:~# file lns_test.txt 
lns_test.txt: symbolic link to test.txt
```

文件本体就是标准的文件，有内容，有权限，有用户属性等等，对于软链接和硬链接，相当于文件不同形式的分身。
硬链接是指多个文件实际上指向同一个索引节点（inode）。每个文件都有一个 inode，inode 包含文件的元数据和数据块的地址。所有硬链接文件对应的 inode 的链接计数都会加一。硬链接文件之间没有物理上的区别，它们只是同一 inode 的多个别名。当一个硬链接文件被删除时，只是链接计数减一，只有在链接计数降为零时，文件的内容才会被释放。硬链接不能跨越文件系统边界，因为 inode 是特定于文件系统的。硬链接相当于文件本体的一个别名，同时也是文件的动态备份，无论操作文件本体或者硬链接都相当于操作该文件。只有全部文件本体和硬链接全部删除时才会真正的删除文件，如果只删除文件本体，那硬链接就会变成文件本体。
软链接是一个特殊的文件，其中包含指向另一个文件的路径。软链接是通过文件路径而不是 inode 直接引用目标文件的。软链接可以链接到不存在的文件，也可以跨越文件系统。软链接文件有自己的 inode，而其内容是指向目标文件的路径。如果原始文件被删除，软链接将变为坏链接（dangling link）。软链接也可能引起“循环链接”（circular link）问题，即链接形成了一个环，导致无限循环。软链接只是相当于文件的一个分身，没有备份功能。

#### 文件系统树

组织文件的系统被称为文件系统树，基本的 Linux 文件系统树由根节点和多个根目录组成，不同的根目录存放着不同的文件，他们决定着 Linux 不同的功能。

![](https://pic1.zhimg.com/80/v2-1adefa5fa2632b9198b2e1af266f6b88_720w.jpg)



**/root**

这是系统管理员(root user)的目录。对于系统来说，系统管理员就好比是上帝，它能对系统做任何事情，甚至包括删除你的文件。因此，请小心使用root帐号。
**/bin**

这里存放了标准的 Linux 的工具，比如像 " ls "、" vi " 还有 " more " 等等。通常来说，这个目录已经包含在你的 " PATH " 系统变量里面了。什么意思呢？就是当你在终端里输入 ls ，系统就会去 PATH 环境变量的目录下面查找是不是有 ls 这个程序。系统所需要的那些命令位于此目录
**/etc**

这里主要存放了系统配置方面的文件。举个例子：你安装了 samba 这个套件，当你想要修改 samba 配置文件的时候，你会发现配置文件就在 /etc/samba 目录下。
**/dev**

这里主要存放与设备有关的文件( Unix 和 Linux 系统均把设备当成文件)。想连线打印机吗? 系统就是从这个目录开始工作的。另外还有一些包括磁盘设备文件、USB 设备文件等都放在这个目录。
**/home**

这里主要存放普通用户的个人数据。具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：/home/用户名。当然，root用户除外。
**/tmp**

这是临时目录，只存在于内存中，关机便会消失。对于某些程序来说，有些文件被用了一次两次之后，就不会再被用到，像这样的文件就放在这里。有些 Linux 系统会定期自动对这个目录进行清理，因此，千万不要把重要的数据放在这里。
**/usr**

在这个目录下，你可以找到那些不适合放在 /bin 或 /etc 目录下的额外的工具。比如像游戏，一些打印工具拉等等。/usr 目录包含了许多子目录 /usr/bin 目录用于存放程序，/usr/share 用于存放一些共享的数据，比如音乐文件或者图标等等，/usr/lib 目录用于存放那些不能直接运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器会自动帮你管理好 /usr 目录的。

当我们安装一个 Linux 发行版官方提供的软件包时，大多安装在这里。 如果有涉及服务器配置文件的，会把配置文件安装在 /etc 目录中。/usr 目录下包括涉及字体目录 /usr/share/fonts ，帮助目录 /usr/share/man 或 /usr/share/doc，普通用户可执行文件目录 /usr/bin 或 /usr/local/bin 或 /usr/X11R6/bin ，超级权限用户 root 的可执行命令存放目录，比如 /usr/sbin 或/usr/X11R6/sbin 或/usr/local/sbin 等，还有程序的头文件存放目录 /usr/include。
**/usr/local**

这里主要存放那些手动安装的软件，即不是通过 apt-get 安装的软件。它和 /usr 目录具有相类似的目录结构。让软件包管理器来管理 /usr 目录，而把自定义的脚本 scripts 放到 /usr/local 目录下面

/usr/local 这个目录一般是用来存放用户自编译安装软件的存放目录；一般是通过源码包安装的软件，如果没有特别指定安装目录的话，一般是安装在这个目录中。
**/opt**

这里主要存放那些可选的程序。你想尝试最新的 firefox 测试版吗?那就装到 /opt 目录下吧，这样，当你尝试完，想删掉 firefox 的时候，你就可以直接删除它，而不影响系统其他任何设置。安装到 /opt 目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。
**/media**

有些 Linux 的发行版使用这个目录来挂载那些可移动的磁盘。
**/boot**

Linux 的内核及引导系统程序所需要的文件目录，比如 vmlinuz initrd.img 文件都位于这个目录中。在一般情况下，GRUB 或 LILO 系统引导管理器也位于这个目录。
**/lost+found**

在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中 fsck 工具会检查这里，并修复已经损坏的文件系统。 有时系统发生问题，有很多的文件被移到这个目录中，可能会用手工的方式来修复，或移到文件到原来的位置上。
**/mnt**

这个目录一般是用于存放挂载储存设备的挂载目录的，比如有 cdrom 等目录。可以参看 /etc/fstab 的定义。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。主要看 /etc/fstab 中怎 么定义了。比如光驱可以挂载到 /mnt/cdrom 。
**/proc**

操作系统运行时，进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc 目录伪装的文件系统 proc 的挂载目录，proc 并不是真正的文件系统，它的定义可以参见 /etc/fstab 。
**/sbin**
大多是涉及系统管理的命令的存放，是超级权限用户 root 的可执行命令存放地，普通用户无权限执行这个目录下的命令，这个目录和 /usr/sbin; /usr/X11R6/sbin或 /usr/local/sbin 目录是相似的；我们记住就行了，凡是目录 /sbin 中包含的都是需要 root 权限才能执行的。
**/var**
这个目录的内容是经常变动的，看名字就知道，我们可以理解为 vary 的缩写，/var 下有 /var/log 这是用来存放系统日志的目录。/var/www 目录是定义 Apache 服务器站点存放目录；/var/lib 用来存放一些库文件，比如 MySQL 的，以及 MySQL 数据库的的存放地；
/var/log 系统日志存放，分析日志要看这个目录的东西；
/var/spool 打印机、邮件、代理服务器等假脱机目录；

Linux 或者说 UNIX 类的现代操作系统自身只有用户、权限、文件这三个内容，在使用 Linux 的过程中，我们基本都是围绕着这三个内容展开的。同时，这三个内容的组织形式，用户组，权限组，文件树也是非常重要的。

### （2）、 Linux 中的命令（软件）

Linux 中的命令其实就是一个个的可执行程序，脚本也算可执行程序的一种。可执行程序又叫软件，软件的组织形式是软件包，有专门的程序去管理软件包。

Linus Torvalds 开始编写和编译 Linux   内核时，他需要一套非常基本的系统实用程序来开始执行一些稍微有用的工作。内核并不提供命令或任何类型的命令 shell，比如   Bash，它本身是没有任何用处的，因此，Linus 使用了免费提供的 GNU 核心实用程序，并为 Linux   重新编译了它们。这让他拥有了一个完整的、即便是相当基本的操作系统。

#### SHELL

![](https://img-blog.csdnimg.cn/img_convert/56c96734fb37d4773ae524b0394fa5cc.jpeg)

对于计算机来说，Linux 内核只是一个管理计算机各种硬件的程序，它不具有和人们交互的能力。为此我们需要一个能够理解人类指令并让内核按照人类意愿管理和操作计算机的程序，这个程序就是 Shell。Shell 的变种有多个名称，下面是关于 Shell 程序信息的一个表格：

| shell | Complete path-name | Prompt for root user  | Prompt for non root user |
| --- | --- | --- | --- |
| Bourne shell (sh) |	/bin/sh and /sbin/sh |	#	 | $ |
| GNU Bourne-Again shell (bash) | 	/bin/bash | 	bash-VersionNumber# |	bash-VersionNumber$ |
| C shell (csh) |	/bin/csh |	# |	% |
| Korn shell (ksh)	| /bin/ksh	| #	| $ |
| Z Shell (zsh)	| /bin/zsh	| <hostname>#	| <hostname>% |

**Bourne Shell (sh)**
Bourne shell 由 Steve Bourne 在 AT&T 贝尔实验室开发，被认为是第一个UNIX shell。它被表示为 sh。由于紧凑和操作速度快，Bourne shell 广受欢迎。

以上特性使得它成为 Solaris 操作系统的默认外壳。它也被用作所有 Solaris 系统管理脚本的默认外壳。然而，Bourne shell有一些明显的缺点：

它没有内置的处理逻辑和算术运算的功能。

另外，与Linux中大多数的 shell 不同，Bourne shell不能回忆以前使用过的命令。

它功能不全面， 无法提供适当的交互式使用。

Bourne shell的完整路径名称是/bin/sh和/sbin/sh。默认情况下，它对 root 用户使用 *#* 提示符，对非 root 用户使用 *$* 提示符。

**GNU Bourne-Again Shell (bash)**

GNU Bourne-Again shell 更多被称为 Bash shell，它被设计成与Bourne shell兼容。Bash shell 融合了 Linux 中不同类型 shell 的有用功能，如 Korn shell 和 C shell。

与Bourne shell不同的是，它能够自动回忆以前使用过的命令，并可以使用方向键编辑它们。

GNU Bourne-Again shell的完整路径名称是/bin/bash。默认情况下，它对 root 用户使用的提示符是 *bash-版本号#*，对非 root 用户的提示符是 *bash-版本号$*。

**C Shell (csh)**
发 C shell 是把有用的编程功能容纳进去，如对算术运算的内置支持和类似于 C 语言的语法。

此外，它还包含了 Linux 中不同类型的 shell（如Bourne shell）中所缺少的历史命令。C shell 的另一个显著功能是“别名”。

C shell的完整路径名称是/bin/csh。默认情况下，它对 root 用户的提示符是 *主机名#*，对非 root 用户的提示符是 *主机名$*。

**Korn Shell (ksh)**
Korn shell 是由 David Korn 在 AT&T 贝尔实验室开发的，用于改进 Bourne shell。它被表示为 ksh。Korn shell 本质上是 Bourne shell 的一个超集。

除了支持 Bourne shell 所支持的一切外，Korn shell 还为用户提供了新的功能。它有着内置的对算术运算的支持，同时提供类似于 C shell 的交互功能。

Korn shell 运行为 Bourne shell 编写的脚本，同时提供类似于 C 语言的字符串、数组和函数运算。它还支持为 C shell 编写的脚本。此外，它比 Linux 中大多数不同类型的 shell（包括 C shell）要快。

Korn shell 的完整路径名称是/bin/ksh。默认情况下，它对 root 用户使用 *#* 提示符，对非 root 用户使用 *$* 提示符。

**Z Shell (zsh)**
Z Shell 或 zsh 是 sh shell 的扩展，在自定义方面做了大量改进。如果你想要一个具有更多功能的现代 shell，zsh shell就是你要找的。

Z shell 有以下亮点：

- 根据给定的条件生成文件名

- 支持插件和主题

- 索引内置函数

- 自动补全命令

- 以及更多……

 Shell 程序更多的是提供一个和用户交互的接口，它能够以用户手动输入的方式一条一条命令执行，同时也可以解析已经编写好的程序脚本，自动进行命令执行。Shell 程序本身不提供或者只提供基本的内置环境命令，而我们平时执行的命令主要是由软件包中的软件来提供的，所以学习命令的使用其实就是学习软件包中的软件使用方法。

#### Coreutils

Coreutils 软件包是 GNU 项目的一部分，它是一组基本的命令行工具集，用于操作和管理Linux和其他类Unix系统中的文件和数据流。这些工具被广泛用于终端和脚本中，提供了许多常用的功能和实用程序，基本的 Linux 命令就是由这个软件包进行提供了。Coreutils 的官网地址是：https://www.gnu.org/software/coreutils 。

**GNU coreutils核心程序**
![](https://img-blog.csdnimg.cn/469ed2582e6c4bed9331c1c03433547c.png)

Linux 的基本系统操作命令有十大类：

- 目录处理命令：ls，mkdir，cd，pwd，rmdir，cp，rm
- 文件处理命令：touch，cat，more，less，head，tail
- 链接命令：ln
- 权限管理命令：chmod，chown，chgrp，umask
- 文件搜索命令：find，locate，which，whereis，grep
- 帮助命令；man，whatis，help
- 用户管理命令：useradd，passwd，who，w，su
- 压缩解压缩命令：gzip，gunzip，tar，zip，unizp
- 网络命令：write，wall，ping，ifconfig，mail，last，netstat
- 关机重启命令：shutdown，logout

#### util-linux

Util-linux 软件包包含 Coreutils 没有的工具。其中比较重要的是加载、卸载、格式化、分区和管理硬盘驱动器，打开 tty 端口和得到内核消息。

Util-linux 包含下面程序：

agetty, arch, blockdev, cal, cfdisk, chkdupexe, col, colcrt, colrm,  column, ctrlaltdel, cytune, ddate, dmesg, elvtune, fdformat, fdisk,  fsck.cramfs, fsck.minix, getopt, hexdump, hwclock, ipcrm, ipcs, isosize, line, logger, look, losetup, mcookie, mkfs, mkfs.bfs, mkfs.cramfs,  mkfs.minix, mkswap, more, mount, namei, parse.bash, parse.tcsh, pg,  pivot_root, ramsize (link to rdev), raw, rdev, readprofile, rename,  renice, rev, rootflags (link to rdev), script, setfdprm, setsid,  setterm, sfdisk, swapoff (link to swapon), swapon, test.bash, test.tcsh, tunelp, ul, umount, vidmode (link to rdev), whereis 和 write

简短说明：

- agetty：打开一个TTY端口，显示登录提示，执行 /bin/login 命令。

- arch：显示机器的体系结构信息。

- blockdev：在命令行中调用块设备的ioctl。

- cal：显示一个简单的日历。

- cfdisk：处理指定设备的分区表。

- chkdupexe：找出多余的可执行文件。

- col：过滤来自输入的反向行馈送内容。

- colcrt：预览 nroff 的输出。

- colrm：在某个文件中删除列。

- column：把输出格式化为几列。

- ctrlaltdel：设置CTRL+ALT+DEL组合键的功能，为硬重启或软重启。

- cytune：查询和修改cyclade驱动器的中断入口。

- ddate：把阳历日期转换为Discordian日期。

- dmesg：显示内核的启动信息。

- elvtune：调整I/O端口平衡。

- fdformat：低级格式化一张软盘。

- fdisk：磁盘分区管理程序。

- fsck.cramfs：对Cramfs文件系统的一致性进行检查。

- fsck.minix：对MINIX文件系统的一致性进行检查。

- getopt：解析命令参数。

- hexdump：用用户指定的方式(包括ASCII, 十进制, 十六进制, 八进制)显示一个文件或者标准输入的数据。

- hwclock：查询和设置硬件时钟。(也被称为RTC或BIOS时钟)

- ipcrm：删除一个指定的资源。

- ipcs：提供IPC机制的信息。

- isosize：输出iso9660文件系统的长度。

- line：单行拷贝。

- logger：设置系统日志的入口。

- look：显示以某个给定字符串为开头的行。

- losetup：启动和控制回环(loop)设备。

- mcookie：为xauth产生magic cookie，128位随机数。

- mkfs：在一个设备(通常是一个硬盘分区)设备上建立文件系统。

- mkfs.bfs：创建 SCO bfs 文件系统。

- mkfs.cramfs：创建cramfs文件系统。

- mkfs.minix：创建 Minix 文件系统。

- mkswap：初始化指定设备或文件，以用做交换分区。

- more：分屏显示文件，但less更好用。

- mount：把一个文件系统从一个设备挂载到一个目录。

- namei：显示指定路径的符号链接。

- pg：显示文本文件内容，一次显示一屏。

- pivot_root：使某个文件系统成为当前进程的根文件系统。

- ramsize：显示或者改变内存虚拟盘的大小。

- rdev：查询和设置内核的根设备和其他信息。

- readprofile：显示/proc/profile文件的信息。

- rename：对文件重命名。

- renice：修改正在运行进程的优先级。

- rev：颠倒一个文件每行字符的顺序。

- rootflags：在挂载根设备时，查询和设置额外的信息。

- script：为终端会话过程建立一个typescipt文件，记录会话过程中终端的输出。

- setfdprm：设置软盘参数。

- setsid：在一个新的会话过程中运行程序。

- setterm：设置终端属性。

- sfdisk：磁盘分区表管理工具。

- swapdev：能在启动内核中设置交换分区设备。

- swapoff：取消对指定交换设备和交换文件的使用。

- swapon：使指定的交换设备和交换文件生效。

- tunelp：设置打印设备的参数。

- ul：加下划线。

- umount：卸载一个被挂载的文件系统。

- vidmode：查询和设置视频模式。

- whereis：确定某命令二进制文件,源文件和手册文档的位置。

- write：发一个消息给另一个用户,如果他开启了writting的话。

Util-linux 依赖于: Bash, Binutils, Coreutils, Diffutils, GCC, Gettext, Glibc, Grep, Make, Ncurses, Sed, Zlib 软件包。

#### 软件包管理

Linux 只是提供一个高度可用的内核，并没有规定上层的软件包组织形式，理论上说只要是符合要求的可执行文件都能得到执行。Linux 中的软件包非常自由有不同的组织形式，这些软件包又组成了不同的发行版。而不同的发行版又使用不同的软件包管理器。总的来说，软件包的管理是一个非常杂乱的时事情。

程序有动态执行库 SO 的依赖，把 SO 和 可执行文件组织起来的软件包也同样有不同的依赖。管理这些依赖是一件非常烦杂的事情，此时各种依赖管理工具诞生了，他们是各类发行版的基石，正是有了软件包依赖管理器，我们安装软件才能从容不迫。

**dpkg**

> **Ubuntu、Debian**

`dpkg` 命令是 `Debian Linux` 系统用来安装、创建和管理软件包的实用工具。

- **命令行使用**

```text
root@M5Core135:~# dpkg(选项)(参数)
root@M5Core135:~# dpkg --help
Usage: dpkg [<option> ...] <command>

# 选项
-i：安装软件包
-r：删除软件包
-P：删除软件包的同时删除其配置文件
-L：显示于软件包关联的文件
-l：显示已安装软件包列表
--unpack：解开软件包
-c：显示软件包内文件列表
--confiugre：配置软件包

# 参数
Deb软件包：指定要操作的.deb软件包
```

- **示例演示说明**

```text
# 安装包
root@M5Core135:~# dpkg -i package.deb

# 删除包
root@M5Core135:~# dpkg -r package

# 删除包（包括配置文件）
root@M5Core135:~# dpkg -P package

# 列出与该包关联的文件
root@M5Core135:~# dpkg -L package

# 显示该包的版本
root@M5Core135:~# dpkg -l package

# 解开deb包的内容
root@M5Core135:~# dpkg --unpack package.deb

# 搜索所属的包内容
root@M5Core135:~# dpkg -S keyword

# 列出当前已安装的包
root@M5Core135:~# dpkg -l

# 列出deb包的内容
root@M5Core135:~# dpkg -c package.deb

# 配置包
root@M5Core135:~# dpkg --configure package

# 列出已安装软件包
root@M5Core135:~# sudo dpkg-query -l
root@M5Core135:~# sudo dpkg-query -l | less
root@M5Core135:~# sudo dpkg-query -l | grep tmux
```

**apt**

> **Ubuntu、Debian**

`apt-get` 命令是 `Debian Linux` 发行版中的 APT 软件包管理工具，它是 dpkg 的前端工具。所有基于 `Debian` 的发行都默认使用这个包管理系统。`deb` 包可以把一个应用的文件包在一起，大体就如同 `Windows` 上的安装文件。

- **命令行使用**

```text
# apt-get(选项)(参数)
root@M5Core135:~# apt --help
Usage: apt [options] command

# 选项
-c：指定配置文件

# 参数
管理指令：对APT软件包的管理操作
软件包：指定要操纵的软件包
```

- **示例演示说明**

```text
# 更新所有已安装的软件包
root@M5Core135:~# apt-get upgrade

# 将系统升级到新版本
root@M5Core135:~# apt-get dist-upgrade

# 更新
root@M5Core135:~# apt-get update

# 安装一个新软件包
root@M5Core135:~# apt-get install packagename

# 卸载一个已安装的软件包（保留配置文件）
root@M5Core135:~# apt-get remove packagename

# 卸载一个已安装的软件包（删除配置文件）
root@M5Core135:~# apt-get –purge remove packagename

# 来删除你已经删掉的软件
root@M5Core135:~# apt-get autoclean apt

# 会把安装的软件的备份也删除
root@M5Core135:~# apt-get clean

# 列出已安装软件包
root@M5Core135:~# apt list --installed
root@M5Core135:~# apt list --installed | less
root@M5Core135:~# apt list --installed | grep tmux
```

### （3）、Shell 脚本

Shell 脚本就是将需要运行的程序命令用一定的流程控制组织起来，整合到一个文件中，这个文件被称为 Shell 脚本。

因为 Shell 脚本本身包含的就是 Shell 能够执行的命令语句，所以 Shell 脚本不用编译就能由 Shell 直接解释执行。当然解释执行的属性也带来了运行速度慢的缺点，但这个缺点在脚本语言中一般不会去考虑。

#### 简单的 Shell 脚本

我们以 bash 脚本为例子。

Shell 脚本默认是以 .sh 结尾，所以我们首先创建一个 test.sh 的文件。

```bash
root@M5Core135:~# touch test.sh
root@M5Core135:~# ls
test.sh
```

然后在该文件中添加下面的内容：

```bash
root@M5Core135:~/tmp# cat test.sh 
#!/bin/bash
echo "hello world!"
```

其中的 `#!/bin/bash` 意思是执行这个脚本的程序是 /bin/bash。

`echo "hello world!"` 是执行一个输出 "hello world!" 的命令。

给该脚本赋予可执行的权限：

```bash
root@M5Core135:~# chmod +x test.sh 
root@M5Core135:~# ls test.sh -l
-rwxr-xr-x 1 root root 32  7月20日 15:08 test.sh
```

执行脚本：

```bash
root@M5Core135:~/tmp# ./test.sh 
hello world!
```

执行脚本后，输出了 "hello world!" 。

#### Shell 脚本中的变量

变量是可变的参数量，用于表示在脚本程序运行过程中需要代指变化的参数。

Shell 中存在三种类型的变量：

- 局部变量：在当前脚本中起作用的变量。
- 环境变量：Shell 环境中的变量，在 Shell 运行后所有程序都能访问到的变量。
- Shell 变量：这是 Shell 为程序运行时传递的特殊变量，主要是用户输入参数等等。

**操作变量：**

- 创建普通变量：`test="hello world!"`。

- 创建局部变量：`local local_test="hello world!"`。

- 创建局部变量：`test="hello world!" ;readonly test`

- 创建环境变量：`export test_all="hello world!"`

- 使用变量：`echo $test` 或者 echo ${test}

- 删除变量：unset test

**字符串操作：**

- 字符串拼接：直接将两个字符串写在一起即可。`str="hello"" ""world!"`、`str0="hello";str1=" ";str2="world!";str=$str0$str1$str2`
- 字符串截取：通过字符串命令进行截取，比如`cut`、`sed`、`awk`等。也可以通过 Shell 的字符串处理, ${varible:n1:n2}截取字符串变量 varible 中从 n1 位置开始，长度为 n2 的子字符串。
- 获取字符串长度：通过字符串命令，`echo $str | awk '{print length($0)}'`，`echo $str | wc -L`。通过 Shell 方式`echo ${#str}`。

**数组操作：**

- 定义一个数组：

```bash
#!/bin/bash
test=("hello" " " "world" "!")
```

- 操作数组: 

```bash
#!/bin/bash
test=("hello" " " "world" "!")
echo ${test[0]}	# 访问单个数组
echo ${test[*]}	# 打印整个数组
test[0]="test"	# 对数组 0 号元素重新赋值
echo ${test[*]}
unset test[2]	# 删除数组 2 号元素
echo ${test[*]}

```

- 遍历数组：

```bash
#!/bin/bash
a=(1 2 3 4 5 6)
for((i=0; i<10; i++))
do
    echo "a[$i]=${a[$i]}"
done
```

- 获取数组长度:

```bash
#!/bin/bash
a=(1 2 3 4 5 6)
echo ${a[*]}
echo "a len: ${#a[*]}"
```

- 合并数组：

``` bash
#!/bin/bash
a=("hello" " " "world" "!")
b=("hello" "zhaixue.cc")
c=(${a[*]} ${b[*]})
echo ${c[*]}
```

**特殊变量：**


- $0 ：代表执行的文件名
- $1 ：代表传入的第1个参数
- $n ：代表传入的第n个参数
- $# ：参数个数
- $* ：以一个单字符串显示所有向脚本传递的参数。
- $@ ：与$*相同，但是使用时加引号，并在引号中返回每个参数
- $$ ：脚本运行的当前进程号
- $! ：后台运行的最后一个进程的ID
- $? ：显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。

**算术运算：**

Shell 使用算术运算需要特殊的方式：

```bash
#！/bin/bash
num1=21
num2=5
add_val=$((num1 + num2)) 
sub_val=$((num1 - num2)) 
mul_val=$((num1 * num2)) 
div_val=$((num1 / num2)) 
res_val=$((num1 % num2)) 
echo "num1 + num2 : $add_val"
echo "num1 - num2 : $sub_val"
echo "num1 * num2 : $mul_val"
echo "num1 / num2 : $div_val"
echo "num1 % num2 : $res_val"
```
**逻辑运算：**

```bash
#！/bin/bash
if [ 1 -eq 1 ] ; then
	echo "1 等于 1"
fi
if [ 1 -ne 2 ] ; then
	echo "1 不等于 2"
fi
if [ 2 -gt 1 ] ; then
	echo "2 大于 1"
fi
if [ 1 -lt 2 ] ; then
	echo "1 小于 2"
fi
if [ 2 -ge 1 ] ; then
	echo "2 大于等于 1"
fi
if [ 1 -le 1 ] ; then
	echo "1 小于等于 1"
fi
if [[ 1 -eq 1 && 1 -gt 0 ]] ; then
	echo "1 等于 1 同时 1 大于 0"
fi
if [[ 1 -eq 2 || 2 -gt 1 ]] ; then
	echo "1 等于 2 或者 2 大于 1"
fi
```

**文件测试运算符:**

```bash
#！/bin/bash
if [ -b "/dev/mmcblk0" ] ; then
	echo "文件是块设备文件"
fi
if [ -c "/dev/tty1" ] ; then
	echo "文件是字符设备文件"
fi
if [ -d "/home" ] ; then
	echo "检测文件是目录"
fi
if [ -f "/root/123.wav" ] ; then
	echo "文件是普通文件或者文件存在"
fi
if [ -g "/root/123.wav" ] ; then
	echo "文件设置了 SGID 位"
fi
if [ -k "/root/123.wav" ] ; then
	echo "文件设置了粘着位(Sticky Bit)"
fi
mkfifo /root/test_pipe
if [ -p "/root/test_pipe" ] ; then
	echo "文件是有名管道"
fi
rm /root/test_pipe
if [ -u "/root/123.wav" ] ; then
	echo "文件设置了 SUID 位"
fi
if [ -r "/root/123.wav" ] ; then
	echo "文件可读"
fi
if [ -w "/root/123.wav" ] ; then
	echo "文件可写"
fi
if [ -x "/root/123.wav" ] ; then
	echo "文件可执行"
fi
if [ -s "/root/123.wav" ] ; then
	echo "文件为空"
fi
if [ -e "/root/123.wav" ] ; then
	echo "文件（包括目录）存在"
fi
```

**流程控制:**

```bash
#！/bin/bash

# if else 判断
if true ; then
    echo "条件是 true"
else
    echo "条件是 false"
fi

# for循环
for loop in 1 2 3 4 5
do
    echo "The value is: $loop"
done

# while循环
int=1
while(( $int<=5 ))
do
    echo $int
    let "int++"
done

# 多分支结构
color="red"
case $color in
    "red")
        echo "You chose red."
        ;;
    "green")
        echo "You chose green."
        ;;
    "blue")
        echo "You chose blue."
        ;;
    *)
        echo "Invalid color."
        ;;
esac

# 单选结构
echo "What is your favourite?"
select var in "apple" "orange" "banana"; do
  break;
done
echo "You have selected $var"

```
**子函数:**

```bash
#!/bin/bash
testParam(){
    echo "第一个参数为 $1 !"
    shift
    echo "剩下的参数为 $@ !"
}
testParam 1 2 3 4

```

IO 流的重定向:

每一个 Linux 程序都会需要输入输出，io 重定向就是将 Linux 程序的输入输出重新定位到文件。

一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：

1、标准输入文件 (stdin)：stdin的文件描述符为 0，Unix 程序默认从 stdin 读取数据。
2、标准输出文件 (stdout)：stdout 的文件描述符为 1，Unix 程序默认向 stdout 输出数据。
3、标准错误文件 (stderr)：stderr 的文件描述符为 2，Unix 程序会向 stderr 流中写入错误信息。

```bash
#!/bin/bash

# 输入重定向
command1 < file

# 输出重定向
command1 > file

# 标准错误文件重定向
command 2 > file

# 完全输出文件重定向
command > file 2>&1
```

>  /dev/null 这是一个特殊的设备文件，名字为“文件黑洞“，它只能写入文件，不能读出文件。常用于忽略程序的所有输出。




### （3）、Linux 实用

**定时任务**

Crontab 是 Linux 和 Unix 中用于定时任务非常实用的工具。它相当于 Linux 系统中的闹钟，能够按照设定的时间执行预定的程序。

Crontab 运行时是由一个名叫 Cron 的守护程序来定时读取时刻表中的条目，并与现在时刻进行比较，当时间符合后就调用时刻表中需要执行的命令。

Crontab 的基本命令有四个：

- `crontab -l`：列出当前用户的所有Crontab任务
- `crontab -e`：编辑当前用户的Crontab任务
- `crontab -r`：删除当前用户的所有Crontab任务
- `crontab -i`：在删除 Crontab 任务前提醒用户确认

一个 crontab 时刻条目如下：

```bash
0 5 * * 1 tar -zcf /var/backups/home.tgz /home/
minute   hour    day   month   week      command
```

编写规则如下：

星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。

逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”。 

中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”。 

正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。 

艾特（@）：可以用 @ 符号表示出现什么状态时运行脚本，比如`@reboot `：开机时执行；`@yearly == 0 0 1 1 * ` ：每年执行一次；`@monthly == 0 0 1 * *`:每月执行一次；`@weekly == 0 0 * * 0`：每周执行一次；`@daily == 0 0 * * *`: 每天执行一次；`@hourly == 0 * * * *`：没小时执行一次

每天 `18：30 `执行每日任务：

```bash
root@M5Core135:~# crontab -l
# m h  dom mon dow   command
30 18 * * * /home/nihao/.everyday_task.sh &
```



**开机任务**

Linux 的开机任务没有一个固定的方式：可以通过 crontab，也可以通过 systemd 服务脚本，在这里我们介绍一个通用的 /etc/rc.load 的方式。

/etc/rc.local 是一个默认约定的当系统启动完成后执行的脚本，大多数系统都会默认这个文件的存在。如果使用 systemd 作为 init 系统没有这个脚本时，我们需要手动添加：

```bash
#!/bin/bash
# 创建 /etc/rc.local 
sudo cat < EOF > /etc/rc.local 
#!/bin/bash
# you command

exit 0
EOF

# 添加执行权限
sudo chmod +x /etc/rc.local

# 创建 systemd 服务脚本
sudo cat < EOF > /lib/systemd/system/rc-local.service
[Unit]
Description=/etc/rc.local Compatibility
Documentation=man:systemd-rc-local-generator(8)
ConditionFileIsExecutable=/etc/rc.local
After=network.target

[Service]
Type=forking
ExecStart=/etc/rc.local start
TimeoutSec=0
RemainAfterExit=yes
GuessMainPID=no

[Install]
WantedBy=multi-user.target
EOF

# 使能开机服务
sudo systemctl enable rc-local
```



**条件任务**

inotify 软件可用于监控 Linux 文件或者目录的变换，这对于当目录发生变化后执行某些动作很有用。

安装：

```bash
sudo apt-get install inotify-tools
```
监视文件或目录的变化:
```bash
inotifywait /path/to/directory
```
监视特定事件类型：
```bash
inotifywait -e modify,create,delete /path/to/directory
```
通过递归监视子目录:
```bash
inotifywait -r /path/to/directory
```
当监视的文件被修改时，执行自定义脚本：
```bash
#!/bin/bash

directory="/path/to/directory"

inotifywait -m -e modify --format '%w%f' "$directory" | while read file
do
    echo "File $file was modified. Performing custom action."
    # 在这里添加你要执行的自定义操作
done
```

### （4）、Linux 网络配置

Linux 中的网络配置有很多中形式，在这里介绍如何手动方法去配置无线网络。

需要的安装的软件包:net-tools, udhcpc

```bash
#!/bin/bash
sudo apt install net-tools udhcpc
```

相关命令

```bash
#!/bin/bash
ifconfig                           # 显示所有网卡和接口信息
ifconfig -a                        # 显示所有网卡（包括开机没启动的）信息
ifconfig eth0                      # 指定设备显示信息
ifconfig eth0 up                   # 激活网卡
ifconfig eth0 down                 # 关闭网卡
ifconfig eth0 192.168.120.56       # 给网卡配置 IP 地址
ifconfig eth0 10.0.0.8 netmask 255.255.255.0 up     # 配置 IP 并启动
ifconfig eth0 hw ether 00:aa:bb:cc:dd:ee            # 修改 MAC 地址
dhclient -i eth0									# 获取 dhcp 动态ip
```

> 注意：修改网口的 mac 地址时，一定要让网卡接口处于关闭状态 ( ifconfig eth0 down )。

如果网口获取到 ip 地址，能 ping 通外网的 ip 地址但是不能 ping 网址的时，大概率是没有设置系统 dns 服务器。修改过程如下：

```bash
echo 'nameserver 8.8.8.8
nameserver 114.114.114.114' > /etc/resolv.conf
```




# 第二章：Linux 应用开发

## 1. 操作系统内核

Linux 应用是建立在 Linux操作系统内核上的。从软件的整体运行来看，内核给应用程序提供标准二进制 api 接口，这些接口是内核将底层硬件抽象出来的结果，无论底层硬件如何变换，应用程序都可以通过标准的接口进行工作。这些二进制 api 接口由和操作系统的特性有关，所以想要使用二进制 api 接口，需要了解操作系统特性。


### （1）、 操作系统有四个基本特性

操作系统的基本特征有四个即：并发性、共享性、虚拟性、异步性

**并发性：** 指的是两个或者多个事件在同一时间间隔内发生，即这个设备一会执行这个事件一会执行那个文件，多个事件共同使用一个设备。 

操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它应该具有处理和调度多个程序同时执行的能力。在这种多道程序环境下，一段时间内，宏观上有多个程序在同时运行，而在每一时刻，单处理器环境下实际仅能有一道程序执行，故微观上这些程序还是在分时地交替执行。操作系统的并发性是通过分时得以实现的。而并行则是指两个或者多个事件在同一时刻发生，即两个或者多个事件互不影响，计算机在同一时间完成两种或两种以上的工作。 

**共享性：** 即资源共享，指系统中的资源供内存中的多道程序所共同使用。 

共享有两种方式：互斥共享和同时访问。

- 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但是 一个时间段内，只允许一个进程访问

- 同时共享方式：系统中的某些资源，允许一个时间段内，多个进程"同时"对该资源进行访问

  这个同时是从宏观上来说的，在微观上，依然是多个进程交替访问该资源。

> 注意：并发、共享是多用户OS的最基本特征；资源共享以进程并发执行为条件；系统对资源共享的有效管理，需协调诸进程对其访问

并发和共享的关系

- 两个进程正在并发的执行(并发性)
- 需要共享的访问硬盘资源(共享性)

如果失去并发性，则系统只有一个进程在运行，那么共享性就没有意义。

如果失去共享性，则多个应用程序不能同时访问硬盘资源，就无法同时发送文件，即不能并发。

这就是并发性和共享性互为存在条件的原因。

**虚拟性 ：**指通过某种技术把一个物理实体变成若干个逻辑上的对应物。 

虚拟性是一种管理技术，把物理上的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物的技术。采用虚拟技术的目的是为用户提供易于使用、方便高效的操作环境。

例如分时系统将一机虚拟为多机就是未来使得用户资源共享更加方便。具体表现为两种虚拟：

- 1）虚拟内存：当前要处理的作业所占的内存比计算机的内存小时，先调入部分作业，当这部分作业处理完之后再调入接下来要处理的部分作业，因而程序认为计算机内存足够大，此即虚拟了更大内存
- 2）虚拟外设：当计算机连接多个外部设备时，让多个外设工作的时间差在可接受范围内，近似于同时工作，此即虚拟外设。 

**异步性：** 指的是系统中并发执行的多道程序“走走停停”即随时可能面对中断，以不可预知的速度向前推进。 

在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底；而是走走停停，以不可预知的速度向前推进，也就是进程的执行顺序和执行时间不确定。这就是进程的异步性。



### （2）、 操作系统分类

操作系统会给运行在其上的应用程序分配虚拟化的硬件资源，不同的资源分配方案对应用程序的运行效果影响是巨大的。而人们在不同场景下对计算机运行的要求是不同的，于是便根据资源分配方案划分了操作系统额的分类。

#### 分时操作系统

计算机的硬件承载能力是有限的，在一段时间内，硬件能做的事情也是有限的。应用程序工作的时候需要对硬件有持续的需求，这种需求也包括 cpu 运行资源的使用上。在没有操作系统的时候，采用人工的方法划分 cpu 使用时段，程序会一直运行到结束。有了操作系统之后，操作系统会根据算法自动的为程序划分 cpu 使用时段，操作系统分配资源是十分快速的，这给应用程序划分更小的运行资源提供了可能，也让多个用户同时使用计算机提供了可能。借鉴多道批处理流水线，将运行资源划分到人无法觉察的地步，然后让程序分时段轮流使用运行资源，只要人无法觉察，看起来就像是计算机同时运行了多个应用程序。这种能够自动划分操作系统分时运行资源的操作系统被叫做分时操作系统。

分时操作系统的特点：

- 交互性：用户能与系统实现交互；

- 独立性：多个用户间可以彼此独立运行；

分时系统也有缺点，分时系统让多个用户同时联机共享主机，但也使得系统变得更加复杂，且无法选择具体用户作业的先后顺序。

分时系统的代表是：Unix、Linux、windows 等主要直接为人提供交互服务的系统。

#### 实时操作系统

>实时体系指体系的核算正确性不只取决于核算的逻辑正确性，还取决于发生成果的时刻。假如未满意体系的时刻束缚，则以为体系失效。
>——Donal Gillies 在 Realtime Computing FAQ 中提出的界说。

分时系统的缺点无法选择具体用户作业的先后顺序，也就导致了无法保证应用程序对外服务的实时性。为了解决这个问题，研发人员更改了操作系统的运行资源分配方式，添加应用程序的紧急性，让拥有紧急事情的应用程序更快的享受运行资源，也就是更快的执行，从而保证应用程序的实时，这样的操作系统就被叫做实时操作系统。

实时操作系统，当外界事件和数据产生时，系统能以足够快的速度予以处理，其处理结果能在规定的时间内控制生产结果或对系统做出响应，并控制所有实时任务协调一致运行的操作系统。

实时操作系统，一般分为硬实时和软实时，硬实时指的是在规定的时间内必须完成任务操作，在操作系统设计时保证；软实时只要按照任务的优先级，尽可能地完成任务操作即可

硬实时操作系统：完全满足在指定时间内完成关键行为。

硬实时操作系统严格规定了限定时间内必须完成任务，否则会导致严重后果发生。如在自动驾驶场景下，车辆前置摄像头模块，短距长距雷达及助力转向等模块需要连续采集处理数据，并通过算法输出决策行为。其中，系统必须在指定时间内完成对输入的采集数据完成运算及处理，并完成输出。假设方向盘转角，节气门等驾驶相关控制信号若无法确保实时性，自动驾驶系统的安全性将无法保证。

常见的硬实时操作系统有 VxWorks，ThreadX、FreeRTOS、ucOS。

值得提一句的是，VxWorks是世界范围内现役航天，航海，飞机，坦克自动化控制部分使用范围最广的实时操作系统，包括国内网上热度最高的几种军事设备也同使用了此系统。

软实时操作系统：大多数情况下在指定时间内完成关键行为。

软实时系统对处理事件的时间要求是统计学预期，即使在处理过程中偶发出现了时间偏差，也不会对系统造成致命后果。如IP电视解码视频流数据时，可能会出现数据帧的丢失，但即使了，仅是用户视觉上的体验影响，或通过抖动处理，就可以解决图像上的视觉感知问题。

总结就是实时操作系统对操作系统的特性提出了时间上的要求。
- 1. 响应时间：实时操作系统要求任务的响应时间尽可能短，通常在毫秒级别以下。而非实时操作系统对任务响应时间没有严格要求。
- 2. 任务调度方式：实时操作系统通常采用抢占式调度方式，即高优先级任务可以强制中断低优先级任务执行。而非实时操作系统通常采用协作式调度方式，即任务执行完后才会主动让出CPU资源。
- 3. 可靠性：实时操作系统要求系统具有高可靠性，能够保证任务执行的正确性和稳定性。而非实时操作系统对于系统可靠性要求较低，只要程序不崩溃即可。
- 4. 硬件支持：实时操作系统通常需要硬件的支持，如中断控制器、定时器等，以实现对实时任务的快速响应和调度。而非实时操作系统则对硬件支持要求较低。
- 5. 功能模块：实时操作系统提供了一系列专门针对实时应用需求而设计的功能模块，如实时任务调度算法、中断处理机制、进程间通信方式等。而非实时操作系统则更加注重通用性，提供了更加丰富的功能模块，如文件系统、网络协议栈等。

非实时操作系统与实时操作系统相比，**最直接的差别**：

**实时操作系统严格规定了限定时间内必须完成任务，否则会导致严重后果发生。当内核处于相对消耗状态时，非实时操作系统处理延时会增加，甚至无法保证最高优先级任务执行的最后时限。**

### （3）、 操作系统的内核结构

操作系统内核按照提供服务的大小分为宏内核和微内核。

#### 宏内核（Monolithic Kernel）

在操作系统诞生的时候，Unix 的设计就是宏内核，宏内核是一种将大部分系统功能都直接实现在内核中的操作系统内核设计。这种设计的优点在于，它具有非常高的执行效率和良好的操作系统资源管理能力，因为操作系统资源可以直接在内核中实现。另外，宏内核可以减少进程间通信带来的性能损失，并提高系统的执行速度。然而，宏内核的缺点在于，由于所有组件都在内核中实现，内核的代码量非常大，因此宏内核的可靠性和安全性也存在问题。

内核管理着用户程序和硬件之间的系统资源，在宏内核架构中，用户服务和内核服务在同一空间中实现。具体一点，就是内核可以代表内核进程运行代码，就是通常的内核进程；当用户进程经过系统调用或者中断进入到内核态时，内核也可以代表它运行代码。这样一来，宏内核需要管理的资源多于微内核，其大小就相对大一些了。

在宏内核架构当中，内核管理着CPU调度，内存管理，文件管理和系统调用等各模块的的工作，由于用户服务和内核服务被实现在同一空间中，这样在执行速度上要比微内核快。然而，宏内核的劣势也是显而易见的，那就是当内核中的某个服务崩溃了，整个内核也会崩溃。另一点，想要在内核中添加新的功能就意味着内核中的各个模块需要做相应的修改，因此其扩展性很弱。

#### 微内核（Micro kernel）

为了解决安全性和稳定性，那就需要对内核态运行的程序进行剥离和隔离，所以微内核只实现最基本的功能，其他功能则通过进程间通信来实现。

微内核则是一种只实现最基本功能的操作系统内核设计。这种设计的优点在于，它可以避免操作系统内核越来越大的问题，减少内核的复杂性、提高内核的安全性，使得内核更加稳定、可靠。但是微内核的缺点在于，它往往需要使用进程间通信等方式来实现某些功能，这些方式往往会降低系统的执行效率。

内核管理着所有的系统资源，在微内核中用户服务和内核服务在不同的地址空间中实现。在应用程序和硬件的通信中，内核进程和内存管理的极小的服务，而客户端程序和运行在用户空间的服务通过消息的传递来建立通信，它们之间不会有直接的交互，这样一来，微内核中的执行速度相对就比较慢了，这是微内核架构的一个缺点。 

在内核架构中，用户服务是独立于内核服务的，因此任何用户服务崩溃都不会影响到内核服务，这就加强了操作系统的健壮性，这是微内核的优势所在。另一点，微内核的扩展性强，添加一个功能，只需要建立一个新的服务到用户空间当中，而内核空间不需要任何的修改。因此，微内核可移植性强、安全并且易于扩展。

#### 宏内核和微内核的差异

除了两者在基本内核服务上的差异之外，由于设计角度的不同，在其它服务上的设计上也有很大的区别。

![](https://i0.hdslb.com/bfs/article/694bb5955d88499c7e85eec368f3c67237300cd4.png@1256w_722h_!web-article-pic.avif)

微内核将很多的操作系统服务移动到了用户空间，我们来列张表来对比一下微内核和宏内核的具体区别：

![](https://i0.hdslb.com/bfs/article/964fe93bf104e5d0fd89d4059bbf659e34a7949f.png@1256w_608h_!web-article-pic.avif)

内存管理的区别：

宏内核在内核空间就实现了系统所有内存管理所需的一切业务，包括内存分配策略、虚拟内存管理分页算法等，如下图所示： 

![](https://i0.hdslb.com/bfs/article/727adfc20e97b769d519cd019bb27d114708449e.png@1256w_992h_!web-article-pic.avif)

对于微内核的内存管理实现，有一个发展过程。在第一代的微内核架构中，内核代理了用户空间的内存管理，控制着内存访问的权限，如下图所示。

![](https://i0.hdslb.com/bfs/article/c10db9a0acc58a8976fa590c0afbc19932791c42.png@1256w_940h_!web-article-pic.avif)

内核中的某个服务负责管理缺页异常并保存新分配的页，只要有缺页异常发生，请求就经过内核通知页管理器。页管理器必须进入特权模式下来获取内存的访问，然后回到用户模式下。然后发送一个返回结果来触发进程，当然这个过程也是需要经过内核的。处理缺页异常或者保存新分配页的整个过程是繁复而耗时的。

为了弥补性能上的损失，之后的微内核构架在内存管理上作了相应的改变。每个进程有3个内存管理原语(Primitves)：map、grant和flush。如果进程想要共享它的内存页那么它的可以通过map来映射内存页给其它进程。当进程通过grant来让渡它的内存页给其它进程之后，该进程就丧失了这些内存页的访问权，直到让渡进程不再刷新它们。如此一来，整个系统运行过程就成了这样：在系统启动时，内核将所有内存保存到一个叫做基本的系统进程 (basic system process) 当中，当然这个所谓有基本进程是运行在用户空间中的，如果其它进程需要内存，就是再需要从内核中获取，它可以直接向这个基本的系统进程索取。

![](https://i0.hdslb.com/bfs/article/fec58d4c8912ce27bb70df8f7d0d992968a7741b.png@1256w_1138h_!web-article-pic.avif)

其它模块的区别：

微内核和宏内核在设计上还存在一些其它的区别，比方IO管理方面，宏内核的设备驱动直接在内核中实现，硬件中断也直接在内核中处理；但是在微内核中，内核是不直接处理IO中断管理的，来自硬件的请求将被重定向到用户服务中去，比方内核捕获了一个中断，那么内核发送给设备驱动服务就完事了，设备驱动服务会去处理这个中断。

总结：

微内核效率比宏内核慢，但在安全性、可靠性方面要比宏内核好，在扩展性方面微内核也有优势。

从内核构架发展趋势来说，将来或许会有比Linux更为强劲的基于微内核架构的OS出现，让我们拭目以待吧！ 



## 2. 开发环境

计算机只认得二进制指令，也就是 01010101 这种的数字高低电平，它非常善于处理数字计算。开发就是将想让计算机做的计算用特定的语言写出来，然后用编译器翻译成二进制指令，让计算机执行。

### （1）、 GCC

#### 编译步骤

GCC（GNU C Compiler）全名 CNU project C and C++，为 GCC 编译套件，最初由开源 GNU 事业领袖理查德·斯托曼（Richard Stallman） 于 1985 开发。最初的 gcc 只能处理 C 语言，经过扩展，很快可处理 C++ 。经过现代多语言的发展，Fortran、Pascal、Objective -C、Java、Ada、Go等也在 gcc 的支持列表中。目前已经成为 Linux 发行版默认的编译器，以 `gcc` 命令的形式在终端（Shell）中提供。

如果 Debian 环境中没有提供 gcc 程序，可以通过下面的命令进行安装：

```bash
sudo apt install gcc
```

gcc 对源文件的处理是四个步骤，第一步：预处理，第二步：编译，第三步：汇编，第四步：链接。

![](http://new.51cto.com/files/uploadimg/20060926/1714230.jpg)



从功能上分，预处理、编译、汇编是三个不同的阶段，但 GCC 的实际操作上，它可以把这三个步骤合并为一个步骤来执行。下面我们以 C 语言为例来谈一下不同阶段的输入和输出情况。

我们新建一个 helloworld 程序！

```bash
root@M5Core135:~/hello# cat << EOF > helloworld.c
#include <stdio.h>
int main(int argc, char *argv[])
{
     printf("hello world !\n");
     return 0;
}
EOF
```

预处理：

```bash
root@M5Core135:~/hello# gcc -E helloworld.c -o helloworld.i
```

查看 helloworld.i 文件，它会将所有的 `#include` 的头文件展开，然后替换 C 文件中所有的宏。

编译：

```bash
root@M5Core135:~/hello# gcc -S helloworld.i -o helloworld.s
```

生成的 helloworld.s 文件就是 gcc 将 C 的源码编译成了汇编文件。

汇编：

```bash
gcc -c helloworld.s -o helloworld.o 
```

这一步是将汇编文件翻译成机器的二进制指令，查看 helloworld.o 就知道，这是一个二进制文件。此时该文件还是不能执行的，它还没链接上系统库，它现在还是一个独立的机器二进制程序，没有系统库的帮助，它是无法运行的。

链接：

```bash
root@M5Core135:~/hello# gcc helloworld.o -o helloworld
```

这一步会生成一个 `helloworld` 的可执行文件，它是一个完整的 elf 文件，可以由系统加载运行。

执行:

```bash
root@M5Core135:~/hello# ./helloworld 
hello world !
```

在真正的编译工程的时候，通常会将预编译，编译，汇编合成一步，然后在多个源文件的情况下将他们链接起来形成一个工程。
> 一步编译：`gcc helloworld.c -o helloworld`

#### 多文件编译

单个文件可以直接使用 gcc 一步到位生成一个可执行文件，多个文件就需要分两个阶段进行编译了。

创建多个源码文件：

```bash
# 创建 second.c
root@M5Core135:~/hello# cat << EOF > second.c
#include <stdio.h>
void say_hi(void)
{                               
   printf("hi , i am second!\n");
}           
EOF 

# 创建 second.h
root@M5Core135:~/hello# cat << EOF > second.h
#ifndef __SECOND_H__
#define __SECOND_H__
void say_hi(void);
#endif
EOF

# 创建 main.c
root@M5Core135:~/hello# cat << EOF > main.c
#include <stdio.h>
#include "second.h"
int main(int argc, char *argv[])
{
   say_hi();
   printf("hi , i am main!\n");
return 0;
}
EOF

# 编译
root@M5Core135:~/hello# gcc -c second.c -o second.o
root@M5Core135:~/hello# gcc -c main.c -o main.o
root@M5Core135:~/hello# gcc main.o second.o -o main

# 执行
root@M5Core135:~/hello# ./main 
hi , i am second!
hi , i am main!

```

#### GCC 编译静态库和动态库

首先我们创建多个文件源码：

```c
// add_minus.c
#include "add_minus.h"

int add(int a, int b)
{
        return a + b;
}

int minus(int a, int b)
{
        return a - b;
}

// add_minus.h
#ifndef __ADD_MINUS_H__
#define __ADD_MINUS_H__

int add(int a, int b);
int minus(int a, int b);

#endif /*__ADD_MINUS_H__*/

// main.c
#include <stdio.h>
#include "add_minus.h"
#include "multi_div.h"

int main(void)
{
        int rst;

        printf("Hello Cacu!\n");

        rst = add(3, 2);
        printf("3 + 2 = %d\n", rst);

        rst = minus(3, 2);
        printf("3 - 2 = %d\n", rst);

        rst = multi(3, 2);
        printf("3 * 2 = %d\n", rst);

        rst = div(6, 2);
        printf("6 / 2 = %d\n", rst);

        return 0;
}

// multi_div.c
#include "multi_div.h"

int multi(int a, int b)
{
        return a * b;
}

int div(int a, int b)
{
        return a / b;
}

// multi_div.h
#ifndef __MULTI_DIV_H__
#define __MULTI_DIV_H__

int multi(int a, int b);
int div(int a, int b);

#endif /*__MULTI_DIV_H__*/
```

```bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ ls
add_minus.c  add_minus.h  main.c  multi_div.c  multi_div.h
```

编译静态库：

```bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ gcc -c add_minus.c -o add_minus.o
nihao@nihao-z690:~/work/test/make_example-master/tmp$ ar rcs libadd_minus.a add_minus.o
```

编译动态库：

```bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ gcc -fPIC -c multi_div.c -o multi_div.o
nihao@nihao-z690:~/work/test/make_example-master/tmp$ gcc -shared multi_div.o -o libmulti_div.so
```

编译 main.c 源码:

```bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ gcc -c main.c -o main.o
```

查看当前文件：

```bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ tree
.
├── add_minus.c
├── add_minus.h
├── add_minus.o
├── libadd_minus.a
├── libmulti_div.so
├── main.c
├── main.o
├── multi_div.c
├── multi_div.h
└── multi_div.o

0 directories, 10 files
```

使用动态库和静态库生成可执行文件：

```bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ gcc -o main main.o -L. -I. -ladd_minus -lmulti_div -Wl,-rpath,./
nihao@nihao-z690:~/work/test/make_example-master/tmp$ tree
.
├── add_minus.c
├── add_minus.h
├── add_minus.o
├── libadd_minus.a
├── libmulti_div.so
├── main
├── main.c
├── main.o
├── multi_div.c
├── multi_div.h
└── multi_div.o

0 directories, 11 files
nihao@nihao-z690:~/work/test/make_example-master/tmp$ ldd main
        linux-vdso.so.1 (0x00007fff3d309000)
        libmulti_div.so => ./libmulti_div.so (0x00007f8130312000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8130000000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f813031e000)
```

执行：

```bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ ./main 
Hello Cacu!
3 + 2 = 5
3 - 2 = 1
3 * 2 = 6
6 / 2 = 3
```

>编译动态库的时候一定要添加 -fPIC 选项让代码运行与位置无关，否则运行可能会出错。
>
>-Wl 是将后面的指令传递给链接器，-rpath 是设置运行时动态库的搜索路径， ./ 执行命令的当前目录。




#### GCC 常用编译指令

gcc 的基本用法是：gcc [options] [filenames],[options] 表示参数，[filenames] 表示相关文件的名称，一些最基本的参数及含义下表所示：

|     参数      | 含义                                                         |
| :-----------: | :----------------------------------------------------------- |
|      -c       | 编译程序，但不链接成为可执行文件，生成二进制文件 .o          |
|      -E       | 编译器经过预处理阶段后停止工作，生成预编译文件 .i            |
|      –S       | 编译器经过预处理阶段后停止工作，生成汇编文件.s               |
|      -o       | 指定输出文件的名称                                           |
| -D | 设置编译的宏定义 |
| -O/-O1/-O2/O3 | 代码优化等级                                                 |
|      -Os      | 优化代码体积到最小                                           |
|    -Og -g     | 生成调试信息，方便 gdb 调试，会增大可执行文件体积            |
|      -O0      | 不使用优化                                                   |
|      -w       | 不输出任何警告信息                                           |
|     -Wall     | 将警告视为错误，编译过程一有警告便停止编译                   |
|      -v       | 输出 gcc 工作的详细过程                                      |
|     -ggdb     | 加入 GDB 调试器能识别的格式                                  |
|    -static    | 链接静态库生成目标文件，不使用动态库                         |
|    -share     | 尽量使用动态库,但是需要系统存在动态库                        |
|    -shared    | 生成适用于共享库的与地址无关的代码（PIC）                |
|     -fPIC     | 生成与位置无关的的代码，适用于使用动态库，与 `-fpic`的区别在于去除去全局偏移表的任何限制 |
|     -fPIE     | 使用与地址无关的代码生成可执行文件                           |
|  -Wl,option   | 将 option 作为选项传递给链接器。如果选项包含逗号，则将其在逗号处拆分为多个选项。如：`-Wl,-Map,output.map` 传递 `-Map output.map` 给链接器（ GNU的链接器也可这样表示：`-Wl,-Map=output.map` ） |
|   -T script   | 使用 script 作为链接器的脚本                               |
|    -I dir     | 将 dir 作为包含的头文件路径                                |
|    -L dir     | 将 dir 作为 `-l` 操作的文件路径                            |
| -sysroot=dir | 指定 dir 作为头文件和库文件寻找的根目录，这个选项在交叉编译时很有用 |

gcc 的相关知识非常多，比如控制 ELF 结构的链接脚本，控制各种警告的选项等等，读者可以自行研究。

### （2）、 GDB

**GDB 简介**

GDB 是 GNU 组织发布的、UNIX/LINUX 操作系统下的、基于命令行的、功能强大的程序调试工具。GDB 能够追踪程序的执行，也能恢复程序崩溃前的状态。gdb 的基本功能入如下：

1、设定程序的启动方式。

2、设置程序运行断点，运行到指定断点后停止。

3、回溯程序崩溃前的运行栈，检查程序崩溃的原因。

4、 动态改变程序内的堆栈或者变量。

5、远程调试

除 gdb 外，linux 下比较有名的调试器还有 xxgdb , ddd ,  kgdb , ups。

**GDB 基本使用**

gdb 的安装：

```bash
sudo apt install gdb
```

我们新编写一个程序用于学习 GDB 调试工具的使用。

```c
// test.c
#include <stdio.h>
#include <stdlib.h>
// 函数声明
int divide(int a, int b);

int main(int argc, char *argv[]) {
    int x,y,result;
    x = atoi(argv[1]);
    y = atoi(argv[2]);
    printf("开始计算...\n");
    
    result = divide(x, y);
    
    printf("%d / %d 结果是：%d\n",x, y, result);
    
    result = divide(x, y);
    
    printf("%d / %d 结果是：%d\n",x, y, result);
    return 0;
}

// 函数定义
int divide(int a, int b) {
    if (b == 0) {
        printf("错误：除数不能为0！\n");
        return -1;
    }
    return a / b;
}

```

添加可调试的选项然后编译这个程序：

```bash
root@M5Core135:~/tmp# gcc -g test.c -o test
root@M5Core135:~/tmp# ls -la
-rwxr-xr-x  1 root root 9740  7月21日 16:14 test
-rw-r--r--  1 root root  569  7月21日 16:12 test.c
root@M5Core135:~/tmp# ./test 5 1
开始计算...
5 / 1 结果是：5
5 / 1 结果是：5
root@M5Core135:~/tmp# ./test 5 0
开始计算...
错误：除数不能为0！
5 / 0 结果是：-1
错误：除数不能为0！
5 / 0 结果是：-1
```

现在我们有一个可调试的进程用于学习如何使用 gdb 进行调试。


**gdb 的基本使用**
查看 gdb 版本:

```bash
root@M5Core135:~/tmp# gdb -v
GNU gdb (Debian 13.1-3) 13.1
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
```

查看 gdb 基本帮助:

```bash
root@M5Core135:~/tmp# gdb --help
This is the GNU debugger.  Usage:

    gdb [options] [executable-file [core-file or process-id]]
    gdb [options] --args executable-file [inferior-arguments ...]

Selection of debuggee and its files:

  --args             Arguments after executable-file are passed to inferior.
  --core=COREFILE    Analyze the core dump COREFILE.
  --exec=EXECFILE    Use EXECFILE as the executable.
  --pid=PID          Attach to running process PID.
  --directory=DIR    Search for source files in DIR.
  --se=FILE          Use FILE as symbol file and executable file.
  --symbols=SYMFILE  Read symbols from SYMFILE.
  --readnow          Fully read symbol files on first access.
  --readnever        Do not read symbol files.
  --write            Set writing into executable and core files.

Initial commands and command files:

  --command=FILE, -x Execute GDB commands from FILE.
  --init-command=FILE, -ix
		     Like -x but execute commands before loading inferior.
  --eval-command=COMMAND, -ex
		     Execute a single GDB command.
		     May be used multiple times and in conjunction
		     with --command.
  --init-eval-command=COMMAND, -iex
		     Like -ex but before loading inferior.
  --nh               Do not read ~/.gdbinit.
  --nx               Do not read any .gdbinit files in any directory.

Output and user interface control:

  --fullname         Output information used by emacs-GDB interface.
  --interpreter=INTERP
		     Select a specific interpreter / user interface.
  --tty=TTY          Use TTY for input/output by the program being debugged.
  -w                 Use the GUI interface.
  --nw               Do not use the GUI interface.
  --tui              Use a terminal user interface.
  -q, --quiet, --silent
		     Do not print version number on startup.

Operating modes:

  --batch            Exit after processing options.
  --batch-silent     Like --batch, but suppress all gdb stdout output.
  --return-child-result
		     GDB exit code will be the child's exit code.
  --configuration    Print details about GDB configuration and then exit.
  --help             Print this message and then exit.
  --version          Print version information and then exit.

Remote debugging options:

  -b BAUDRATE        Set serial port baud rate used for remote debugging.
  -l TIMEOUT         Set timeout in seconds for remote debugging.

Other options:

  --cd=DIR           Change current directory to DIR.
  --data-directory=DIR, -D
		     Set GDB's data-directory to DIR.

At startup, GDB reads the following early init files and executes their
commands:
   None found.

At startup, GDB reads the following init files and executes their commands:
   * system-wide init files: /etc/gdb/gdbinit

For more information, type "help" from within GDB, or consult the
GDB manual (available as on-line info or a printed manual).

Report bugs to <https://www.gnu.org/software/gdb/bugs/>.

You can ask GDB-related questions on the GDB users mailing list
(gdb@sourceware.org) or on GDB's IRC channel (#gdb on Freenode).
```

进入 gdb 命令界面：

```bash
root@M5Core135:~/tmp# gdb
GNU gdb (Debian 13.1-3) 13.1
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "arm-linux-gnueabihf".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word".
(gdb) 

```

载入我们的可执行文件,也可以在 gdb 运行时直接以`gdb test`开始 :

```bash
(gdb) file test
Reading symbols from test...
```

设置命令行参数:

```bash
(gdb) set args 1 5
```

运行程序:

```bash
(gdb) run
Starting program: /root/tmp/test 1 5
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/arm-linux-gnueabihf/libthread_db.so.1".
开始计算...
1 / 5 结果是：0
1 / 5 结果是：0
[Inferior 1 (process 856) exited normally]
```

退出:

```bash
(gdb) quit
root@M5Core135:~/tmp#
```

**GDB 步调试**
```bash
root@M5Core135:~/tmp# gdb test
GNU gdb (Debian 13.1-3) 13.1
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "arm-linux-gnueabihf".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from test...
# 设置命令行参数
(gdb) set args 5 1
# 设置断点在 main 函数处
(gdb) b main
Breakpoint 1 at 0x596: file test.c, line 8.
# 运行进程
(gdb) r
Starting program: /root/tmp/test 5 1
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/arm-linux-gnueabihf/libthread_db.so.1".

Breakpoint 1, main (argc=3, argv=0xbefffb74) at test.c:8
8	    x = atoi(argv[1]);
# 单步运行进程
(gdb) n
9	    y = atoi(argv[2]);
(gdb) 
10	    printf("开始计算...\n");
# 打印出当前变量
(gdb) info locals 
x = 5
y = 1
result = 0
(gdb) n
开始计算...
12	    result = divide(x, y);
# 单步进入运行
(gdb) s
divide (a=5, b=1) at test.c:24
24	    if (b == 0) {
(gdb) n
28	    return a / b;
(gdb) 
29	}
(gdb) 
main (argc=3, argv=0xbefffb74) at test.c:14
14	    printf("%d / %d 结果是：%d\n",x, y, result);
(gdb) info locals 
x = 5
y = 1
result = 5
(gdb) n
5 / 1 结果是：5
16	    result = divide(x, y);
# 设置变量 y 的值为0
(gdb) print y=0
$1 = 0
(gdb) info locals 
x = 5
y = 0
result = 5
(gdb) n
错误：除数不能为0！
18	    printf("%d / %d 结果是：%d\n",x, y, result);
(gdb) 
5 / 0 结果是：-1
19	    return 0;
(gdb) 
20	}
(gdb) 
__libc_start_call_main (main=main@entry=0x40058d <main>, argc=argc@entry=3, argv=0xbefffb74, argv@entry=0xb6fc8000)
    at ../sysdeps/nptl/libc_start_call_main.h:74
74	../sysdeps/nptl/libc_start_call_main.h: No such file or directory.
(gdb) 

```

**更多 GDB 命令**

| 命令 | 简单输入          | 解释 |
| :------------: | :--: |---- |
| attach pid |  | 动态链接到正在运行的 pid 进程，链接成功后目标进程将停止执行 |
| file program |  | 载入目标可执行文件 |
| set args arg1 arg2 |  | 设置运行输入的命令行参数 |
| show args | | 显示设定的程序运行的命令行参数 |
| run | r |运行程序，调试程序从这个命令开始|
| list | l |打印出当前正在运行的源代码|
| break | b |设置运行断点，当程序运行到此处时暂停|
| info break | i b |打印出已经设置的断点信息|
| delete breakpoint 1 |  |删除断点1|
| disable breakpoint 1 |  |禁用断点1|
| enable breakpoint 1 |  |起用断点1|
| clean number |  |删除源文件文件 number 行中的断点|
| continue | c |继续运行程序，直到下一个断点|
| watch |  |在程序中设置一个监测点（即数据断点）|
| display |  |打印出观察的变量|
| undisplay | |display命令的反命令，不要显示表达式|
| print | p |查看运行时的变量以及表达式，也可以用print n=10 给变量|
| print h@10 | p h@10 |打印变量 h 数组 10 个值|
| step | s |单步运行，遇到子函数跳入其中运行|
| next | n |单步运行，遇到子函数不进入运行|
| finish |  |继续运行程序直到跳出当前栈|
| until | u |继续运行直到跳出循环（适合在循环内使用）|
| show convenience |  |查看当前的所有环境变量|
| set env env_name=value |  |设置环境变量|
| set var var_name=value |  |设置变量，var_name必须是调试环境中的变量名称|
| print var_name=value |  |修改变量值|
| info functions |  |查看程序中函数符号|
| info args |  |查看当前函数参数的值|
| info locals |  |查看当前局部变量的值|
| info variables |  |查看程序中的变量符号|
| info registers |  |查看函数寄存器信息|
| info frame |  |查看当前函数调用的栈帧信息|
| frame n |  |切换到栈编号为N的函数栈帧|
| backtrace |  |查看函数调用的顺序，函数调用栈信息|
| disassemble function |  |查看函数反汇编代码|
| set debug entry-values 1 |  |打印尾调用堆栈帧信息|
| call function |  |强制调用某函数，会显示函数返回值（如果函数返回值不是void）。|
| start function |  |执行函数，并停在函数开始位置|
| cd | |改变当前工作目录|
| clear | |删除刚才停止处的断点|
| search text | |在源文件中搜索正规表达式|
| set history expansion on | |可使用 set history expansion on 命令|
| commands | |命中断点时，列出将要执行的命令|
| up | |上移栈帧，使另一函数成为当前函数|
| down | |下移栈帧，使得另一个函数成为当前函数|
| jump | |在源程序中的另一点开始运行|
| kill | |异常终止在 gdb 控制下运行的程序|
| pwd | |显示当前工作目录|
| pype | |显示一个数据结构（如一个结构或C++类）的内容|
| quit | |退出gdb|
| signal | |将一个信号发送到正在运行的进程|
| whatis | |显示变量或函数类型|

**GDB 调试 core dump**

一个有错误的 C 源程序 bugging.c

```c
#include<stdio.h>
static char buff [256];
static char* string;
int main (int argc , char *argv[])
{
	printf ("Please input a string: ");
	gets (string);　　
	printf ("\nYour string is: %s\n", string);
    return 0;
}
```

上面这个程序非常简单，其目的是接受用户的输入，然后将用户的输入打印出来。该程序使用了一个未经过初始化的字符串地址 string，因此，编译并运行之后，将出现 Segment Fault 错误：

```bash
root@M5Core135:~/tmp# ulimit -c unlimited
root@M5Core135:~/tmp# gcc -g bugging.c -o bugging
root@M5Core135:~/tmp# ./bugging 
Please input a string: nihao

Segmentation fault (core dumped)
root@M5Core135:~/tmp# ls
bugging  bugging.c  core
root@M5Core135:~/tmp# gdb bugging core 
GNU gdb (Debian 13.1-3) 13.1
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "arm-linux-gnueabihf".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from bugging...
[New LWP 608]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/arm-linux-gnueabihf/libthread_db.so.1".
Core was generated by `./bugging'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  __GI_strlen () at ../sysdeps/arm/armv6t2/strlen.S:126
126	../sysdeps/arm/armv6t2/strlen.S: No such file or directory.
(gdb) bt
#0  __GI_strlen () at ../sysdeps/arm/armv6t2/strlen.S:126
#1  0xb6ed5dd8 in __vfprintf_internal (s=0xb6fa0d50 <_IO_2_1_stdout_>, 
    format=format@entry=0xb6fd3d80 <_rtld_global_ro> "", ap=..., ap@entry=..., 
    mode_flags=mode_flags@entry=0) at vfprintf-process-arg.c:397
#2  0xb6eceb4e in __printf (format=0x4c3660 "\nYour string is: %s\n")
    at printf.c:33
#3  0x004c358a in main (argc=1, argv=0xbe902bb4) at bugging.c:8
(gdb) info locals 
No locals.
(gdb) quit

```

可以看到程序崩溃时运行到了 printf 函数，通过查看栈的形式，我们能检查程序运行在哪里发生了错误，从而让我们能够更快定位问题。







https://zhuanlan.zhihu.com/p/265099138



### （3）、 Makefile

#### Makefile 简介

1977年，斯图亚特·菲尔德曼在贝尔实验室里制作了这个软件，并将其包含在了Unix系统中。这款软件是一个工具程序（Utility software），通过读取叫做 “Makefile” 的文件，自动化构建软件。大多数情况下，他被用来编译代码，生成结果代码，然后把结果代码链接起来生成可执行文件或者哭文件。Make出现之后，很快的就普及开来，在众多的依赖关系检查工具中，make 是应用最为广泛的一个。2003年，斯图亚特·菲尔德曼因为发明了这样一款重要的工具而接受了美国计算机协会（ACM）颁发的软件系统奖。直到现在，make 仍然被用来编译很多完整的操作系统。最著名的操作系统内核 Linux 依然选用 make 作为制作工具。

Makefile 是 make 的脚本文件，Makefile 中会存放目标和制作目标需要的步骤和顺序。

make 的工作原则：

第一、确定最终目标。

第二、确定中间步骤。

第三、确定步骤之间的依赖顺序。

第四、根据依赖顺序，判断依赖的步骤是否需要重新执行，一步步执行中间步骤并完成最终目标的制作。

Makefile 对编程的帮助，在编译程序的过程中，我们经常需要重复执行各种 gcc 命令操作。这样不仅费时费力，当有成千上万的源文件时，我们根本没办法通过手动输入完成这些操作。而 而 make 会监控我们的 c 源文件，并且自动的输出编译指令，从而把我们从不断的执行编译命令的工作中解救出来。

Makefile 和 IDE 的关系，Makefile 属于制作工具，现代 IDE 一般会自动处理制作过程，也有些 IDE 会生成 Makefile 然后用 make 完成制作过程。

除此之外，你甚至还可以在 Makefile 中储存一些你想调用的系统终端的命令，像一个 Shell 脚本一样使用它。

#### 编写 Makefile

Makefile 的主要的编写规则有三个：

``` makefile
target: dependencies ...
	commands
	...
```

- target 就是我们需要让 make 制作出来的目标。
- dependencies 是制作 target 需要的依赖，用空格隔开，这个 dependencies 可以是文件，也可以是其他的 target。
- commands 是制作 target 需要执行的命令。
> 非常值的注意的是，Makefile 的 commands 前面是用 tab 隔开的，并不是空格，如果用空格替代了就会出现错误。

现在我们来编写一个 Makefile 的 hello world！

```bash
# makefile
say_hello:
        echo "hello world!"
```

在这个 Makefile 中，定义了一个 say_hello 的目标，该目标没有依赖。制作这个目标需要执行一个 `echo "hello world!"` 的指令。


``` bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ make
echo "hello world!"
hello world!
```

现在我们执行这个 Makefile。make 会自动搜索执行 make 命令目录下的 "Makefile" 文件，并读取 Makefile 文件中的第一个目标作为默认目标，然后输出制作命令。

Makefile 中的目标只是一个声明而以，不用担心 target 的起名问题。由于 Makefile 中的目标具有可提示性，你可以用 Makefile 做一个简单的有提示命令选择脚本。

比如：

```makefile
# makefile
say_hello:
	echo "hello world!"

say_hi:
	echo "hi! How are you?"
```

当你输入 make 命令后，就可以通过 tab 键进行补全目标。当 make 指定目标后，它只会构建指定的目标。

```bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ make say_hi 
echo "hi! How are you?"
hi! How are you?
```

如果不希望 make 回显，可以在命令前面添加 "**@**" 符号。

```makefile
# makefile
say_hello:
	@echo "hello world!"

say_hi:
	@echo "hi! How are you?"
```

再次执行：

```bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ make
hello world!
nihao@nihao-z690:~/work/test/make_example-master/tmp$ make say_hi
hi! How are you?
```

我们以 gcc 中编译静态库和动态库为例，编写一个 Makefile 用于介绍：

``` makefile
# 定义目标的版本
VERSION  	=  	1.00

# 定义目标的名字
TARGET  	=  	main-$(VERSION)

# 使用 ?= 定义编译器，如果系统中没有定义 CC 编译器，就把 CC 设定成 gcc
CC   		?=  gcc

# 使用 ?= 定义打包器，如果系统中没有定义 AR 打包器，就把 AR 设定成 ar
AR			?= 	ar

# 使用 ?= 添加一个编译的宏定义
DEBUG   	?=  -DUSE_DEBUG

# 使用 := 定义需要编译的源文件， := 强制将后面的值赋值到 SOURCES 
SOURCES   	:=  add_minus.c main.c multi_div.c

# 使用 += 添加头文件寻找目录
INCLUDES   	+=  -I.

# 使用 += 添加需要的库
LIB_NAMES  	+= -lmulti_div -ladd_minus

# 使用 += 添加库寻找路径
LIB_PATH  	+=  -L.

# 使用 patsubst 函数将 SOURCES 中以 .c 结尾的文件名替换成 .o 的文件名
OBJ   		+=  $(patsubst %.c, %.o, $(SOURCES))

# 添加编译选项
CFLAGS  	+=  -Wall

# 添加链接选项
LDFLAGS	    +=  -Wl,-rpath,./

# 链接成可执行文件
$(TARGET):$(OBJ) libmulti_div.so libadd_minus.a
	$(CC) $(OBJ) $(LIB_PATH) $(LIB_NAMES) -o $(TARGET) $(LDFLAGS)
 
# 制作 libmulti_div.so 动态库
libmulti_div.so:multi_div.o
	$(CC) -shared multi_div.o -o libmulti_div.so

# 制作 libadd_minus.a 静态库
libadd_minus.a:add_minus.o
	$(AR) rcs libadd_minus.a add_minus.o

# 通过自动推导，将所有的 .c 文件编译成二进制 .o 文件
%.o: %.c
	$(CC) $(INCLUDES) $(DEBUG) -c $(CFLAGS) $< -o $@

# 清理编译出的文件
clean:
	@echo "Remove compiled files......"
	$(RM) $(OBJ)

# 删除所有编译出的文件
distclean:
	@echo "Remove linked and compiled files......"
	$(RM) $(OBJ) $(TARGET) libmulti_div.so libadd_minus.a
```

下面执行这个 makefile ：

```bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ tree
.
├── add_minus.c
├── add_minus.h
├── main.c
├── Makefile
├── multi_div.c
└── multi_div.h

0 directories, 6 files
nihao@nihao-z690:~/work/test/make_example-master/tmp$ make
cc -I. -DUSE_DEBUG -c -Wall add_minus.c -o add_minus.o
cc -I. -DUSE_DEBUG -c -Wall main.c -o main.o
cc -I. -DUSE_DEBUG -c -Wall multi_div.c -o multi_div.o
cc -shared multi_div.o -o libmulti_div.so
ar rcs libadd_minus.a add_minus.o
cc  add_minus.o  main.o  multi_div.o -L. -lmulti_div -ladd_minus -o main-1.00 -Wl,-rpath,./
# make 会自动检测文件是否发生了改动，只有改动的文件才会被重新编译
nihao@nihao-z690:~/work/test/make_example-master/tmp$ make
make: “main-1.00”已是最新。
nihao@nihao-z690:~/work/test/make_example-master/tmp$ tree
.
├── add_minus.c
├── add_minus.h
├── add_minus.o
├── libadd_minus.a
├── libmulti_div.so
├── main-1.00
├── main.c
├── main.o
├── Makefile
├── multi_div.c
├── multi_div.h
└── multi_div.o

0 directories, 12 files
nihao@nihao-z690:~/work/test/make_example-master/tmp$ make clean 
Remove compiled files......
rm -rf  add_minus.o  main.o  multi_div.o
nihao@nihao-z690:~/work/test/make_example-master/tmp$ tree
.
├── add_minus.c
├── add_minus.h
├── libadd_minus.a
├── libmulti_div.so
├── main-1.00
├── main.c
├── Makefile
├── multi_div.c
└── multi_div.h

0 directories, 9 files
nihao@nihao-z690:~/work/test/make_example-master/tmp$ make distclean 
Remove linked and compiled files......
rm -rf  add_minus.o  main.o  multi_div.o main-1.00 libmulti_div.so libadd_minus.a
nihao@nihao-z690:~/work/test/make_example-master/tmp$ tree
.
├── add_minus.c
├── add_minus.h
├── main.c
├── Makefile
├── multi_div.c
└── multi_div.h

0 directories, 6 files
```



#### Makefile 变量

Makefile 中的变量和 C 语言中的宏定义类似，主要起的作用是字符替换。值得注意的是，Makefile 中的变量是大小写敏感的。

Makefile 中的变量主要有三类：

- 用户自定义变量，用户自己定义的变量，可随意更改，比如上方的 SOURCES
- 环境变量，make 工作时提供的变量，谨慎更改，比如上方的 CC 、 AR
- 自动变量，make 工作时自动推导出的变量，由 make 完成更改，比如上方的 $%、$@、$<

Makefile 中常用的环境变量，更多的请查看 make 手册：

| 变量名   | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| $@       | **表示目标文件的名字。**如果规则有多个目标，它代表的是触发规则被执行的文件名。 |
| $%       | 当目标文件是一个静态库文件时，代表静态库的一个成员名。       |
| $<       | **表示第一个依赖文件的名字。**如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。 |
| $?       | **表示所有比目标文件更新的依赖文件列表**，以空格分隔。       |
| $^       | **表示所有依赖文件列表**，以空格分隔。一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的第一次引用的情况，即变量“$^”会去掉重复的依赖文件。 |
| $+       | 与“$^”类似，但它保留了依赖文件中重复出现的文件。             |
| $*       | 在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时，“茎”也包含目录部分）。这啥意思？ |
| CC       | 用于指定C语言的编译器。                                      |
| CXX      | 用于指定C++语言的编译器。                                    |
| AR       | 用于指定归档文件的命令。                                     |
| LD       | 用于指定链接器的命令。                                       |
| RM       | 用于指定删除文件的命令。                                     |
| CFLAGS   | 用于指定C语言编译器的选项，例如优化级别、警告级别、编译器标志等。 |
| CXXFLAGS | 用于指定C++语言编译器的选项，与CFLAGS类似，但专门针对C++代码。 |
| LDFLAGS  | 用于指定链接器的选项，例如库文件路径和链接器标志。           |

Makefile 的环境变量也可以由 make 显式指定：

```bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ make TARGET=main
cc -I. -DUSE_DEBUG -c -Wall add_minus.c -o add_minus.o
cc -I. -DUSE_DEBUG -c -Wall main.c -o main.o
cc -I. -DUSE_DEBUG -c -Wall multi_div.c -o multi_div.o
cc -shared multi_div.o -o libmulti_div.so
ar rcs libadd_minus.a add_minus.o
cc  add_minus.o  main.o  multi_div.o -L. -lmulti_div -ladd_minus -o main -Wl,-rpath,./
nihao@nihao-z690:~/work/test/make_example-master/tmp$ tree
.
├── add_minus.c
├── add_minus.h
├── add_minus.o
├── libadd_minus.a
├── libmulti_div.so
├── main
├── main.c
├── main.o
├── Makefile
├── multi_div.c
├── multi_div.h
└── multi_div.o

0 directories, 12 files
nihao@nihao-z690:~/work/test/make_example-master/tmp$ 
```

当 make 指定了 TARGET=main ，编译出的可执行文件变成了 main 。

>  Makfile 可以使用 include 指令导入其他 makefile 的变量。



#### Makefile 函数

Makefile 会提供一些函数供我们使用，调用方式是 $(fun args)

LOG 输出函数：

``` makefile
$(error "this is error")
$(warning "this is warning")
$(info "this is info")
```

如果我们想要查看 SOURCES 有多少个源文件，我们可以在 Makefile 中添加 `$(info $(SOURCES))`

``` makefile
# $(error "this is error")
$(warning "this is warning")
$(info "this is info")
test:
	@echo "test"
```

执行：

```bash
nihao@nihao-z690:~/work/test/make_example-master/tmp$ make
Makefile:68: "this is warning"
"this is info"
test
```

能看出有源文件名被打印了出来。

> $(info $(abs_objtree)) 能够打印出行号信息，方便定位问题。
>
> $(error "this is error") 执行后会退出制作过程。

常用的字符串操作函数 ：

```
$(subst <from>,<to>,<text>)
名称：字符串替换函数——subst。
功能：把字串<text>中的<from>字符串替换成<to>。
返回：函数返回被替换过后的字符串。
示例：$(subst hel,HEL,hello world!)
HELlo world!


$(patsubst <pattern>,<replacement>,<text>) 
名称：模式字符串替换函数——patsubst。
功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符%，表示任意长度的字串。如果<replacement>中也包含%，那么，中的这个%将是<pattern>中的那个%所代表的字串。（可以用/来转义，以/%来表示真实含义的%字符）
返回：函数返回被替换过后的字符串。
示例：$(patsubst %.c,%.o,add_minus.c main.c multi_div.c)
add_minus.o main.o multi_div.o


$(strip <string>)
名称：去空格函数——strip。
功能：去掉<string>字串中开头和结尾的空字符。
返回：返回被去掉空格的字符串值。
示例：$(strip a b c)
abc


$(findstring <find>,<in>)
名称：查找字符串函数——findstring。
功能：在字串<in>中查找<find>字串。
返回：如果找到，那么返回<find>，否则返回空字符串。
示例：$(findstring a,a b c)
a
$(findstring a,b c)
""


$(filter <pattern...>,<text>)
名称：过滤函数——filter。
功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可以有多个模式。
返回：返回符合模式<pattern>的字串。
示例：$(filter %.c %.s,foo.c bar.c baz.s ugh.h)
foo.c bar.c baz.s


$(sort <list>)
名称：排序函数——sort。
功能：给字符串<list>中的单词排序（升序）。
返回：返回排序后的字符串。
sort函数会去掉<list>中相同的单词。
示例：$(sort foo bar lose foot)
bar foo foot lose


$(words <text>)
名称：单词个数统计函数——words。
功能：统计<text>中字符串中的单词个数。
返回：返回<text>中的单词数。
示例：$(words, foo bar baz)
3
```

常用的文件名操作函数 ：

```
$(dir <names...>)
名称：取目录函数——dir。
功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（/）之前的部分。如果没有反斜杠，那么返回./。
返回：返回文件名序列<names>的目录部分。
示例：$(dir src/foo.c hacks)
src/ ./


$(notdir <names...>)
名称：取文件函数——notdir。
功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（/）之后的部分。
返回：返回文件名序列<names>的非目录部分。
示例：$(notdir src/foo.c hacks)
foo.c hacks


$(suffix <names...>)
名称：取后缀函数——suffix。
功能：从文件名序列<names>中取出各个文件名的后缀。
返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。
示例：$(suffix src/foo.c src-1.0/bar.h hacks)
.c .h


$(basename <names...>)
名称：取前缀函数——basename。
功能：从文件名序列<names>中取出各个文件名的前缀部分。
返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。
示例：$(basename src/foo.c src-1.0/bar.c hacks)
src/foo src-1.0/bar hacks


$(addsuffix <suffix>,<names...>)
名称：加后缀函数——addsuffix。
功能：把后缀<suffix>加到<names>中的每个单词后面。
返回：返回加过后缀的文件名序列。
示例：$(addsuffix .c,foo bar)
foo.c bar.c


$(join <list1>,<list2>)
名称：连接函数——join。
功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比<list2>的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比<list1>多，那么，<list2>多出来的单词将被复制到<list2>中。
返回：返回连接过后的字符串
示例：$(join aaa bbb , 111 222 333)
aaa111 bbb222 333

$(abspath <names>)
名称：绝对路径-abspath
功能：用于将路径转换为绝对路径。
返回：绝对路径。
示例：$(abspath .)
/home/nihao/work/test/make_example-master/tmp
```



功能函数 ：

```
$(foreach <var>,<list>,<text>)
把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。
<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var>这个参数来依次枚举<list>中的单词。
示例： 
names := a b c d
$(foreach n,$(names),$(n).o)
a.o b.o c.o d.o


$(call <expression>,<parm1>,<parm2>,<parm3>...)
call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。
当make执行这个函数时，<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是call函数的返回值。
示例： 
reverse = $(1) $(2)
foo = $(call reverse,a,b)
foo的值就是a b
参数的次序是可以自定义的，不一定是顺序的
reverse = $(2) $(1)
foo = $(call reverse,a,b)
foo的值就是b a


$(shell <cmd>)
名称：shell 命令执行函数
功能：执行 shell 命令。
返回：执行 shell 命令的返回值。
示例：$(shell echo "hello world !")
hello world !



```
自定义函数 ：

```makefile
define myfunc
	$(if $(filter $(1), yes), \
		@echo "My function param is Yes", \
		@echo "My function param is Not Yes" \
	)
endef

test:
	$(call myfunc,yes)         # 调用 myfunc 函数，输出 "My function param is Yes"
	$(call myfunc,no)          # 调用 myfunc 函数，输出 "My function param is Not Yes"
```

#### Makefile 判断

Makefile 需要用到判断控制条件制作，Makefile 的判断和宏定义类似，主要有四个条件判断：ifeq、ifneq、ifdef、ifndef。

条件表达式的语法:

```
<conditional-directive>; 
   <text-if-true>; 
else 
   <text-if-false>; 
endif 
```

ifeq：表示条件语句的开始，并指定一个条件表达式。表达式包含两个参数，以逗号分隔，表达式以圆括号括起，表示判断表达式与某个值是否相等。

```makefile
OS = linux
ifeq ($(OS),linux) 
      CFLAGS += -DLINUX
else 
      CFLAGS += -DNO_OS
endif 

# ifneq（与 ifeq 相反）

```

ifdef：如果变量 variable-name; 的值 **非空**，表达式为**真**。否则，表达式为假。当然，variable-name; 同样可以是一个函数的返回值。

```makefile
OS = linux
ifdef OS
      CFLAGS += -DLINUX
else 
      CFLAGS += -DNO_OS
endif 

# ifndef（与 ifdef 相反）
```

判断文件夹是否存在，如果不存在则创建文件夹:
```makefile
# 文件夹名
FOLDER_NAME := my_folder

# 查询文件夹是否存在
ifeq ($(wildcard $(FOLDER_NAME)),)
	$(shell mkdir $FOLDER_NAME)
endif
```



https://zhuanlan.zhihu.com/p/150176358



## 3. Linux c

C 语言是汤普逊和里奇对当时的 B 语言改进而来的，其诞生之初就被用来编写 UNIX 系统，是非常强大的一门语言。

C 具有非常鲜明的特性：

- **过程化编程：** C是一种过程化编程语言，程序由一系列函数组成。这使得程序的结构相对清晰，易于理解和维护。
- **低级语言特性：** C语言提供了对计算机底层硬件的直接访问，允许进行位级操作和内存管理。这使得C语言非常适合系统编程和嵌入式系统开发。
- **可移植性：** C语言编写的程序可以在不同的平台上进行编译和运行，这是因为C语言对硬件的依赖性相对较低。这种可移植性使得C语言成为跨平台开发的理想选择。
- **中级语言：** C语言被称为中级语言，因为它同时具有高级语言和低级语言的特性。它提供了高级语言的抽象特性，同时允许直接访问底层硬件。
- **面向过程：** C语言是一种面向过程的编程语言，程序的执行是按照一系列定义好的步骤（过程或函数）顺序执行的。
- **简洁而高效：** C语言的语法相对简单，但足够强大。它允许程序员以紧凑的方式表达想法，并且编写的代码通常执行效率很高。
 **丰富的标准库：** C语言提供了丰富的标准库，包含大量的函数，涵盖了文件操作、字符串处理、数学计算等各个方面。这些库可以帮助程序员更容易地完成任务，同时提高了代码的可移植性。
- **指针和内存管理：** C语言允许直接使用指针，使得程序员可以更灵活地操作内存。但与此同时，这也带来了需要谨慎管理内存的责任。
- **丰富的运算符：** C语言提供了丰富的运算符，包括算术运算符、逻辑运算符、关系运算符等，使得程序员可以进行各种复杂的计算和逻辑操作。
- **支持系统级编程：** 由于C语言提供了对底层硬件的直接访问，它非常适合进行系统级编程，如编写操作系统、驱动程序等。

嵌入式编程 C 语言是首选，C 语言的基本语法和编程方法在此便不在赘述，本章节主要介绍 C 语言标准库中常用的头文件和函数。

### C 语言标准

C 语言最开始没有官方标准，布莱恩·柯林汉（Brian Kernighan） 和 丹尼斯·里奇（Dennis Ritchie） 出版了一本书，名叫《  [The C Programming Language](http://baike.baidu.com/view/5012996.htm)》。这本书被 C语言开发者们称为  **K&R**，很多年来被当作 C语言的非正式的标准说明。人们称这个版本的 C语言为  **K&R C**。这个标准初步规定了 C 语言的变量，语法，程序结构。

1989年，美国国家标准协会（ANSI）通过了C语言标准，被称为  **ANSI X3.159-1989 "Programming Language C"**。因为这个标准是1989年通过的，所以一般简称  **C89标准**。有些人也简称  **ANSI C**，因为这个标准是美国国家标准协会（ANSI）发布的。

1990年，  [国际标准化组织](http://baike.baidu.com/view/42488.htm)（ISO）和  [国际电工委员会](http://baike.baidu.com/view/159311.htm)（IEC）把C89标准定为C语言的国际标准，命名为  **ISO/IEC 9899:1990 - Programming languages -- C**  [5]   。因为此标准是在1990年发布的，所以有些人把简称作  **C90标准**。不过大多数人依然称之为  **C89标准**，因为此标准与ANSI C89 标准完全等同。它规定了C语言的基本语法、数据类型、运算符等，并定义了一个基本的标准库。该标准奠定了C语言的基础，并广泛应用于早期的C编译器和开发工具。

1999 年1月，国际标准化组织（ISO）和国际电工委员会（IEC）发布了C语言的新标准，名叫  **ISO/IEC 9899:1999 - Programming languages -- C**  [8]   ，简称  **C99 标准**。这是C语言的第二个官方标准, 也是目前使用人数最多的标准。它引入了新的语言特性，如单行注释、布尔类型、变长数组、复合字面量等。此外，C99标准还增加了更多的库函数，包括对复数数学、格式化输入输出、浮点数环境等的支持。然而，C99的广泛采用相对较晚，因此某些编译器和开发环境对其支持有限。

2011年12月8日，国际标准化组织（ISO）和国际电工委员会（IEC）再次发布了C语言的新标准，名叫   **ISO/IEC 9899:2011 - Information technology -- Programming languages -- C**   [9]    ，简称   **C11标准**，原名   **C1X**。这是C语言的第三个官方标准，也是C语言的最新标准。它在C99的基础上进行了进一步改进，并引入了一些新的特性，如类型泛型、多线程支持、匿名结构体和联合体、对 Unicode 字符的支持等。C11还扩展了标准库，增加了新的头文件和函数，如对多线程编程的支持、原子操作、时间和日期处理等。

### C 编译器

C 编译器负责对 C 语言语法编译的实现，C 语言想要转换成 C 程序能够执行，那就需要 C  编译器帮忙编译。

C语言有许多不同的编译器可供使用，每个编译器都有其独特的特性、性能和支持程度。以下是一些常见的C语言编译器：

- GCC（GNU Compiler Collection）：GCC 是一个广泛使用的开源编译器套件，支持多种编程语言，包括C语言。它是许多Linux发行版的默认编译器，并且在其他平台上也有广泛的支持。GCC 提供了丰富的优化选项和严格的符合标准的支持，被认为是一个强大而可靠的编译器。
- Clang：是 LLVM 项目下的 C/C++/Objective-C/Objective-C++ 编译器，，支持C、C++ 和Objective-C。它设计注重灵活性、可扩展性和良好的诊断能力。Clang 具有较好的标准兼容性，并提供了先进的静态分析和代码检查功能。Clang 的静态分析能力使其成为许多代码编辑器和集成开发环境（IDE）的首选。
- Visual C++：Visual C++ 是微软公司提供的专有编译器，它是 Visual Studio 集成开发环境的一部分。Visual C++ 提供了一套完整的工具链，包括编辑器、调试器和性能分析器。它在 Windows 平台上具有良好的集成和支持，并且提供了一些扩展功能，如Windows API 的直接支持。
- Intel C++ Compiler：Intel C++ Compiler 是由英特尔公司提供的优化编译器，针对 Intel 架构和处理器进行了优化。它提供了强大的优化选项和针对特定硬件的优化技术，可生成高性能的代码。Intel C++ Compiler 在科学计算和高性能计算领域有较广泛的应用。

当然，还有一些特殊的编译器可供选择。TCC（Tiny C Compiler）非常小的编译器，可在内存非常小的地方工作，支持将 C 语言当成脚本执行。IBM XL C/C++、Digital Mars C/C++ Compiler 特殊厂家编译器。

编译器可以指定对 C 标准的支持版本，比如 GCC 指定 C 标准为 C11：

```bash
gcc -std=c11 -o exm exm,c
```

### C 标准库

C 语言标准库是一组**预定义函数、宏和文件的集合**，这些函数和文件提供了一些操作系统基本的功能和操作，可供 C 语言程序调用使用。

最开始 C 标准库是 ANSI 发布的 libc，后来 GNU 组织发布了自己的 glibc，glibc 兼容 libc 并扩展了一些函数。随这嵌入式的需求，有 newlibc，microlibc 等精简的 C 库。

**C语言标准库包含以下三部分**：

- **头文件（Header Files）**：C语言标准库包含一系列的头文件，用于声明函数原型、定义常量和数据类型等。开发者可以通过包含适当的头文件来使用标准库中提供的函数和类型。
- **静态库（Static Libraries）**：C语言标准库还以静态库的形式提供，其中包含了标准库函数和类型的实现代码。静态库是在编译时与应用程序一起链接，使得应用程序可以调用标准库提供的函数和类型。
- **动态库（Dynamic Libraries）**：一些操作系统和编译器还提供了C语言标准库的动态库版本。动态库是在运行时被应用程序动态加载和链接的库。应用程序可以共享同一个动态库的实例，从而节省内存，并且可以在库的更新时实现简单的升级。

函数的名字在头文件中声明，调用的函数程序则包含在库中，比如 C 语言的开始 “hello world！” 用的就是 `stdio.h` 标准输入输出头文件，需要静态或者动态的链接到标准库中。

#### 标准库头文件

C 库有很多个头文件，头文件的数量和编译器，标准库都有关系，下面将会介绍 15 个常用的标准头文件,例出常用的函数名：

**<stdio.h>**

提供了标准输入输出函数的声明、定义和相关宏定义。

- 输入输出
  - `printf`：格式化输出到标准输出流。
  - `scanf`：从标准输入流中读取格式化输入。
  - `puts`：输出字符串到标准输出流并追加换行符。
  - `gets`：从标准输入流中读取一行字符串。
  - `fgets`：从指定的输入流中读取一行字符串，包括换行符。
  - `fputc` 和 `fgetc`：将字符写入和从指定的文件流读取字符。
- 文件操作
  - `fopen`：打开一个文件。
  - `fclose`：关闭一个文件。
  - `fread` 和 `fwrite`：从文件读取数据和将数据写入文件。
  - `fprintf`：将格式化数据写入文件。

- 宏定义
  - `stdin`、`stdout` 和 `stderr`：表示标准输入、标准输出和标准错误输出流的文件指针。
  - `EOF`：表示文件结束符。
  - `BUFSIZ`：定义了标准 I/O 缓冲区的大小。
  - `NULL`：表示空指针。

**<stdlib.h>**

提供了一些常用的函数、类型和宏定义，用于内存管理、随机数生成、字符串转换、动态内存分配等操作。

- 内存管理
  - `malloc`：分配指定大小的内存块。
  - `calloc`：分配并清零指定数量的内存块。
  - `realloc`：重新分配已分配内存块的大小。
  - `free`：释放先前分配的内存块。
- 字符串转换
  - `atoi`：将字符串转换为整数。
  - `atol`：将字符串转换为长整数。
  - `atof`：将字符串转换为浮点数。
  - `itoa`：将整数转换为字符串。
- 伪随机数生成
  - `rand`：生成一个伪随机整数。
  - `srand`：设置随机数生成的种子值。
- 程序控制
  - `exit`：终止程序的执行。
  - `abort`：异常终止程序的执行。
- 动态内存分配
  - `malloc` ：用于动态地申请堆内存。
  - `calloc`：用于按照数量动态地申请堆内存。
  - `realloc` ：将扩展原来的内存区。
  - `free` ：释放申请的堆内存。

**<string.h>**

提供了字符串处理相关的函数和宏定义。

- 字符串操作
  - `strcpy`：将一个字符串复制到另一个字符串。
  - `strncpy`：复制指定长度的字符串到另一个字符串。
  - `strcat`：将一个字符串追加到另一个字符串。
  - `strncat`：将指定长度的字符串追加到另一个字符串。
  - `strcmp`：比较两个字符串的大小。
  - `strncmp`：比较指定长度的两个字符串的大小。
  - `strlen`：计算字符串的长度。
  - `strchr`：在字符串中查找指定字符的第一次出现。
  - `strstr`：在字符串中查找指定子字符串的第一次出现。
  - `strtok`：将字符串分解为一系列标记。
  
- 内存操作
  - `memset`：将指定的内存块设置为指定的值。
  - `memcpy`：将一个内存块的内容复制到另一个内存块。
  - `memmove`：将一个内存块的内容移动到另一个内存块。

**<math.h>**

提供了数学相关的函数和常量。

- 常见数学函数
  - `sqrt`：计算平方根。
  - `pow`：计算幂运算。
  - `exp`：计算指数函数。
  - `log`：计算自然对数。
  - `sin`、`cos`、`tan`：计算三角函数（正弦、余弦、正切）。
  - `asin`、`acos`、`atan`：计算反三角函数。
  - `ceil`：向上取整。
  - `floor`：向下取整。
  - `round`：四舍五入。
  - `abs`：计算绝对值。
  - `fmod`：计算浮点数的余数。
- 常量
  - `M_PI`：圆周率 π 的近似值。
  - `M_E`：自然对数的底数 e 的近似值。

**<time.h>**

提供了时间和日期相关的函数和类型。

- 时间获取和转换：
  - `time`：获取当前的系统时间，返回从 1970 年 1 月 1 日 00:00:00 UTC 到当前时间的秒数。
  - `difftime`：计算两个时间之间的差值，以秒为单位。
  - `mktime`：将时间和日期转换为从 1970 年 1 月 1 日 00:00:00 UTC 开始的秒数。
  - `localtime`：将时间表示为本地时间的结构体。
  - `gmtime`：将时间表示为协调世界时（UTC）的结构体。

- 时间格式化：
  - `strftime`：将时间转换为指定格式的字符串。
  - `asctime`：将时间转换为可读的字符串表示。
  - `ctime`：将时间转换为可读的字符串表示，与 asctime 类似。

- 延时函数：
  - `sleep`：使程序暂停指定的秒数。

- 时间类型：
  - `time_t`：表示从 1970 年 1 月 1 日 00:00:00 UTC 开始的秒数。
  - `truct tm`：表示日期和时间的结构体。

**<ctype.h>**

提供了**字符**处理相关的函数和宏定义。

- 字符分类函数：
- `isalnum`：检查字符是否是字母或数字。
- `isalpha`：检查字符是否是字母。
- `isdigit`：检查字符是否是数字。
- `islower`：检查字符是否是小写字母。
- `isupper`：检查字符是否是大写字母。
- `isspace`：检查字符是否为空格字符。
- `ispunct`：检查字符是否是标点符号。
- `isxdigit`：检查字符是否是十六进制数字。
- `isblank`：检查字符是否为空白字符（空格或制表符）。

- 字符转换函数：
  - `tolower`：将字符转换为小写字母。
  - `toupper`：将字符转换为大写字母。

- 其他函数和宏：
  - `isascii`：检查字符是否是 ASCII 字符。
  - `isgraph`：检查字符是否是可打印字符。
  - `iscntrl`：检查字符是否是控制字符。
  - `isprint`：检查字符是否是可打印字符（包括空格）。

**<stdbool.h>**

提供了布尔类型和相关操作的定义和支持。

- 类型定义：
  - `bool`：布尔类型，表示真（true）或假（false）的逻辑值。

- 常量：
  - `true`：布尔类型的真值常量，等价于非零值。
  - `false`：布尔类型的假值常量，等价于零值。

**<errno.h>**

提供了错误处理相关的宏定义和全局变量。

- 全局变量：
  - `errno`：表示当前错误码的全局变量。它是一个整数类型的变量，在发生错误时会被设置为对应的错误码。

- 宏定义：
  - `EDOM`：表示数学域错误。
  - `ERANGE`：表示结果溢出或超出范围错误。

**<float.h>**

用于定义浮点数类型的特定限制和属性。它提供了有关浮点数类型的一些重要信息和常量。下面是一些常用的常量和属性：

- 浮点数类型属性：
  - FLT_RADIX：指定浮点数的基数，通常为 2。
  - FLT_MANT_DIG：指定 float 类型的尾数位数。
  - FLT_DIG：指定 float 类型的十进制精度。
  - FLT_MIN_EXP：float 类型的最小负指数。
  - FLT_MAX_EXP：float 类型的最大正指数。
  - FLT_MIN_10_EXP：float 类型的最小负十进制指数。
  - FLT_MAX_10_EXP：float 类型的最大正十进制指数。

- float 类型的范围和精度：
  - FLT_MIN：float 类型的最小正数值。
  - FLT_MAX：float 类型的最大正数值。
  - FLT_EPSILON：float 类型的最小可表示的绝对误差。

- double 类型的范围和精度：
  - DBL_MIN：double 类型的最小正数值。
  - DBL_MAX：double 类型的最大正数值。
  - DBL_EPSILON：double 类型的最小可表示的绝对误差。

- long double 类型的范围和精度：
  - LDBL_MIN：long double 类型的最小正数值。
  - LDBL_MAX：long double 类型的最大正数值。
  - LDBL_EPSILON：long double 类型的最小可表示的绝对误差

**<limits.h>**

用于定义各种基本数据类型的实现特定限制。它提供了代表不同类型变量中可存储的最小值和最大值的常量。

- CHAR_BIT：该常量表示 char 数据类型中的位数，通常为 8。
- 整数类型的限制：
  - CHAR_MIN 和 CHAR_MAX：char 数据类型的最小值和最大值。
  - SHRT_MIN 和 SHRT_MAX：short (short int) 数据类型的最小值和最大值。
  - INT_MIN 和 INT_MAX：int 数据类型的最小值和最大值。
  - LONG_MIN 和 LONG_MAX：long (long int) 数据类型的最小值和最大值。
  - LLONG_MIN 和 LLONG_MAX：long long (long long int) 数据类型的最小值和最大值。

- 无符号整数类型的限制：
  - UCHAR_MAX：无符号 char 的最大值。
  - USHRT_MAX：无符号 short 的最大值。
  - UINT_MAX：无符号 int 的最大值。
  - ULONG_MAX：无符号 long 的最大值。
  - ULLONG_MAX：无符号 long long 的最大值。
- MB_LEN_MAX：多字节字符中的最大字节数。

**<stddef.h>**
提供了一些与指针和宏相关的类型和常量定义。它定义了一些重要的符号常量和类型，用于帮助编写可移植的代码。
- NULL：这是一个宏，用于表示空指针常量。
- size_t：这是一个无符号整数类型，在 C 语言中用于表示对象的大小。例如，sizeof 运算符返回的结果类型就是 size_t。
- ptrdiff_t：这是一个有符号整数类型，用于表示两个指针之间的差值。
- offsetof 宏：这是一个用于计算结构体成员在结构体中的偏移量的宏。它接受一个结构体类型和一个成员名作为参数，并返回该成员在结构体中的偏移量。

**<stdarg.h>**
于处理可变数量的参数函数。它提供了一组宏和类型，使得函数能够接受不定数量的参数。
- va_list：这是一个类型，用于声明可变数量参数列表的对象。
- va_start 宏：它用于初始化可变参数列表。它接受两个参数，第一个是 va_list 对象，第二个是可变参数列表的前一个已知参数。
- va_arg 宏：它用于访问可变参数列表中的下一个参数，并指定参数的类型。它接受两个参数，第一个是 va_list 对象，第二个是参数的类型。每次调用 va_arg 都会返回下一个参数，并将 va_list 对象更新为指向列表中的下一个参数。
- va_end 宏：它用于清理可变参数列表相关的资源。它接受一个参数，即 va_list 对象，用于标记列表的结束。

**<signal.h>**
信号处理
- signal 函数：该函数用于注册信号处理器（Signal Handler）以响应特定的信号。它接受两个参数，第一个参数是信号编号，第二个参数是指向信号处理器函数的指针。
- raise 函数：该函数用于向当前进程发送信号。它接受一个参数，即要发送的信号编号。
- SIG_ERR 宏：用于表示信号处理器注册失败的返回值。
- SIGINT、SIGABRT、SIGSEGV 等，用于表示特定的信号。

**<locale.h>**
用于处理与本地化（国际化）相关的操作。它提供了一些函数和类型，用于控制程序的本地化设置，包括日期、时间、货币和语言等。

- setlocale 函数：该函数用于设置程序的本地化区域设置。它接受两个参数，第一个参数是 int 类型，用于指定本地化的分类，如日期、时间、货币等；第二个参数是一个字符串，用于指定要设置的区域设置。
- localeconv 函数：该函数返回一个指向 struct lconv 类型的指针，包含了本地化相关的货币和数值格式信息。
- struct lconv：这是一个结构体类型，包含了本地化相关的货币和数值格式信息。它的成员可以用于获取和设置货币符号、小数点符号、千位分隔符等。
- 一些定义的常量：LC_ALL、LC_COLLATE、LC_CTYPE、LC_MONETARY、LC_NUMERIC 和 LC_TIME，用于指定 setlocale 函数中的本地化分类。

**<setjmp.h>**
用于提供非局部跳转函数，经常被用作异常处理恢复。
- setjmp 函数：将本函数的“调用上下文"保存到参数 env 中，同时该函数返回 0。此函数的作用可以理解为“将当前位置（调用 setjmp() 函数的位置）设置成跳转目标”；
- longjmp 函数: 此函数实现跳转，跳转至 setjmp() 函数设置的“跳转目标”，其中参数 env 就是setjmp() 函数设置的 env。此函数从 setjmp() 函数中返回，参数 val 作为从 setjmp() 函数返回时的返回值。

这些头文件一般跟随编译器提供，直接 include 即可使用。

#### Linux 头文件

主要用于 Linux 系统上进行特定的功能和操作，与 Linux 操作系统的特性和功能紧密相关。
**<unistd.h>**
提供了访问操作系统服务的函数，如文件操作、进程管理、系统调用等。

- 系统调用和进程控制：
  - fork：创建一个子进程。
  - exec 系列函数：在当前进程中执行新的程序。
  - exit：终止当前进程的执行。
  - getpid 和 getppid：获取当前进程和父进程的进程 ID。

- 文件和目录操作：
  - open 和 close：打开和关闭文件。
  - read 和 write：从文件中读取和写入数据。
  - lseek：移动文件指针。
  - access：检查文件的访问权限。
  - mkdir 和 rmdir：创建和删除目录。

- 系统资源管理：
  - sleep：使当前进程挂起指定的时间。
  - getcwd：获取当前工作目录。
  - chdir：改变当前工作目录。
  - gethostname：获取主机名。
  - getlogin：获取登录名。

- 进程间通信（IPC）：
  - pipe：创建一个管道用于进程间通信。
  - dup 和 dup2：复制文件描述符。
  - fork 和 exec 系列函数：在进程间传递状态和数据。

**<fcntl.h>**
提供了对文件描述符的操作，如打开、关闭、读取和写入文件。
- 文件控制：
 - open：打开文件并返回一个文件描述符。
 - creat：创建一个新文件。
 - close：关闭文件。

-文件状态标志（File Status Flags）：
 - O_RDONLY、O_WRONLY、O_RDWR：打开文件的读取、写入、读写模式。
 - O_APPEND：追加写入文件。
 - O_CREAT、O_EXCL：创建文件并验证文件不存在。
 - O_TRUNC：将文件截断为零长度。

-文件控制操作：
 - fcntl：对文件描述符进行各种控制操作。
 - dup、dup2：复制文件描述符。

-文件锁定：
 - flock：对文件进行简单的全局锁定。
 - fcntl：使用 F_SETLK、F_SETLKW 等命令进行更复杂的文件锁定。

**<sys/types.h>**
定义了一些基本的系统数据类型，如 size_t、pid_t 等。
- 数据类型定义：
 - size_t：用于表示对象的大小。
 - ssize_t：用于表示有符号的对象大小。
 - time_t：用于表示时间值。
 - off_t：用于表示文件偏移量。
 - pid_t：用于表示进程 ID。
 - uid_t 和 gid_t：用于表示用户 ID 和组 ID。

- 文件类型和模式定义：
  - mode_t：用于表示文件的权限模式。
  - dev_t：用于表示设备的标识符。

- 其他常见的数据类型和宏：
  - int8_t、int16_t、int32_t、int64_t：用于表示固定大小的整数类型。
  - intptr_t 和 uintptr_t：用于表示指针类型的整数值。

**<sys/stat.h>**
包含了文件状态相关的函数和宏，用于获取和修改文件的元数据。
- 文件访问权限：
 - S_IRUSR、S_IWUSR、S_IXUSR：用户（所有者）的读、写、执行权限。
 - S_IRGRP、S_IWGRP、S_IXGRP：用户组的读、写、执行权限。
 - S_IROTH、S_IWOTH、S_IXOTH：其他用户的读、写、执行权限。

- 文件类型和模式：
  - S_IFMT：用于提取文件类型的位掩码。
  - S_IFREG、S_IFDIR、S_IFLNK 等：表示不同文件类型的位掩码。
  - S_ISREG()、S_ISDIR()、S_ISLNK() 等：用于检查文件类型的宏。

 -文件状态结构体：
  - struct stat：用于描述文件的状态信息，包括文件大小、权限、时间戳等。

- 文件属性获取函数：
  - stat、lstat：获取文件的状态信息。
  - fstat：获取打开文件的状态信息。

**<sys/socket.h>**
- 用于网络编程，提供了与套接字相关的函数和数据结构。
- 函数：
  - socket()：创建一个新的套接字
  - bind()：将套接字绑定到地址指定的端口号
  - listen()：监听套接字上的连接请求
  - accept()：接收客户端的连接请求
  - connect()：建立与远程服务器的连接
  - recv()：从套接字中接收数据
  - send()：将数据发送到套接字
  - close()：关闭一个套接字
  - shutdown()：关闭一个已建立的连接（这两个有区别，本文暂不不讲解）

- 常量：
  - AF_INET：IPv4 协议的地址族，又称为 Internet 地址族
  - AF_UNIX：Unix 协议的地址族
  - SOCK_STREAM：提供面向连接、可靠的数据传输服务的套接字类型
  - SOCK_DGRAM：提供面向无连接、不可靠的数据传输服务的套接字类型
  - IPPROTO_TCP：TCP 协议的协议号
  - IPPROTO_UDP：UDP 协议的协议号

**<sys/time.h>**
提供了时间和日期相关的函数和定义，如获取当前时间、计时器等。
- 时间结构体：
 - struct timeval：表示时间值，包括秒数和微秒数。

- 时间获取函数：
  - gettimeofday：获取当前时间。

- 定时器操作函数：
  - timeradd、timersub、timerclear：对时间进行加法、减法和清零操作。

- 时间转换函数：
  - gmtime、localtime：将时间转换为本地时间或协调世界时（UTC）时间。
  - strftime：将时间格式化为字符串。

**<sys/wait.h>**
用于进程间通信，提供了等待子进程状态变化的函数和宏。
- 子进程状态常量：
  - WIFEXITED(status)：检查子进程是否正常退出。
  - WEXITSTATUS(status)：获取子进程的退出状态。
  - WIFSIGNALED(status)：检查子进程是否因信号而终止。
  - WTERMSIG(status)：获取导致子进程终止的信号编号。
  - WIFSTOPPED(status)：检查子进程是否暂停。
  - WSTOPSIG(status)：获取导致子进程暂停的信号编号。

- 等待子进程的状态改变：
  - wait：等待任意子进程的状态改变。
  - waitpid：等待指定子进程的状态改变。

**<pthread.h>**
用于多线程编程，提供了线程相关的函数和定义。
- 线程管理函数：
  - pthread_create：创建一个新线程。
  - pthread_exit：终止当前线程。
  - pthread_join：等待指定线程的结束。
  - pthread_detach：将线程设置为可分离状态，使其在退出时自动释放资源。

- 线程同步函数：
  - pthread_mutex_init、pthread_mutex_destroy：初始化和销毁互斥锁。
  - pthread_mutex_lock、pthread_mutex_unlock：对互斥锁进行加锁和解锁操作。
  - pthread_cond_init、pthread_cond_destroy：初始化和销毁条件变量。
  - pthread_cond_wait、pthread_cond_signal：等待和通知条件变量的变化。

- 线程属性操作：
  - pthread_attr_init、pthread_attr_destroy：初始化和销毁线程属性。
  - pthread_attr_getdetachstate、pthread_attr_setdetachstate：获取和设置线程的分离状态。

- 线程局部存储：
  - pthread_key_create、pthread_key_delete：创建和删除线程局部存储键。
  - pthread_setspecific、pthread_getspecific：设置和获取线程局部存储的值。

**<signal.h>**
用于信号处理，提供了处理进程间通信和异常处理的函数和定义。
- 信号处理函数：
  - signal：设置信号处理器（Signal Handler）。
  - raise：向当前进程发送指定信号。

- 信号常量：
  - SIGINT、SIGTERM、SIGQUIT：表示用户发送的中断、终止、退出信号。
  - SIGSEGV、SIGILL、SIGFPE：表示发生的错误信号，如段错误、非法指令、浮点异常等。
  - SIGUSR1、SIGUSR2：表示用户自定义的信号。

- 信号处理器的行为：
  - SIG_DFL：默认的信号处理器。
  - SIG_IGN：忽略该信号。

- **<dlfcn.h>**
用于动态加载库，提供了动态链接库的加载和使用的函数和宏。
- 动态库加载和卸载函数：
  - dlopen：打开一个动态链接库。
  - dlclose：关闭一个已打开的动态链接库。

- 符号获取函数：
  - dlsym：在动态链接库中查找指定名称的符号（函数、变量等）。

- 错误处理函数：
  - dlerror：获取最近一次动态链接库相关操作的错误信息。



这些头文件由 Linux 提供，直接 include 即可使用。

#### 链接库

链接库是头文件中函数具体的实现，他们已经被编译成二进制形式，当需要的时候链接即可。

- libc：C语言标准库的核心部分，提供了输入输出函数、字符串处理函数、内存管理函数等基本功能。会默认自动被链接到动态库。
- libm：数学库，包含了数学函数，如三角函数、指数函数、对数函数等。在需要的时候使用 -lm 链接。
- libpthread：线程库，提供了线程相关的函数和类型，用于多线程编程。在需要的时候使用 -lpthread 链接。
- libdl：动态链接库支持库，提供了动态链接库的相关函数和类型。在需要的时候使用 -ldl 链接。
- librt：实时库，提供了实时相关的函数和类型，如定时器函数、时间操作函数等。在需要的时候使用 -lrt 链接。
- libcrypt：密码库，提供了密码相关的函数和类型，如加密和解密函数。在需要的时候使用 -lcrypt 链接。

当编译时提示标准函数缺失，很可能就是没有链接相应的库。





https://blog.csdn.net/xiaorange131/article/details/53292972

https://blog.csdn.net/weixin_43764974/article/details/130892554



## 4. Linux 进程

进程是操作系统中给程序分配资源的基本单位，现在操作系统会同时运行多道程序，每个程序的集合体被命名为进程。一个进程就是一个程序在运行阶段的实体，程序在向操作系统申请资源的时候也是以进程的身份申请的。在现在操作系统中，每个进程都会被以内存分段的方式隔离起来，使得进程之间不能直接相互访问资源，不能相互影像，提高了进程的安全性。

以程序的视角来看，程序运行时，相当于单独有一个世界。这样大大减轻了编程人员的工作量，同时给计算机带来非常大的灵活性。

### Linux 进程模型

进程模型对进程所需的资源进行区分而起的名字叫做进程，在代码中就是建立进程的数据结构。

Linux进程通过一个 task_struct 结构体描述，在 linux/sched.h 中定义，通过理解该结构，可更清楚的理解 linux 进程模型。包含进程所有信息的 task_struct 数据结构是比较庞大的，但是该数据结构本身并不复杂，我们将它的所有域按其功能可做如下划分：

-   进程状态（State）
-   进程调度信息（Scheduling Information）
-   各种标识符（Identifiers）
-   进程通信有关信息（IPC：Inter_Process Communication）
-   时间和定时器信息（Times and Timers）
-   进程链接信息（Links）
-   文件系统信息（File System）
-   虚拟内存信息（Virtual Memory）
-   页面管理信息（page）
-   对称多处理器（SMP）信息
-   和处理器相关的环境（上下文）信息（Processor Specific Context）
-   其他信息

进程在系统的中的基本索引是 PID，是一个 32 位无符号整数。为了保持在 16 位平台上的兼容，PID 默认被限制到最大为 32767，也就是最多允许建立 32767 个进程。这个值可以在编译时通过宏定义指定，或者在运行时使用 `ulimit -u` 进程设定。

**PID** 的基本数据结构

```c
struct pid
{
    atomic_t count;
    unsigned int level;
    /* lists of tasks that use this pid */
    struct hlist_head tasks[PIDTYPE_MAX];
    struct rcu_head rcu;
    struct upid numbers[1];
};
* What is struct pid?
*
* A struct pid is the kernel's internal notion of a process identifier.
* It refers to individual tasks, process groups, and sessions. While
* there are processes attached to it the struct pid lives in a hash
* table, so it and then the processes that it refers to can be found
* quickly from the numeric pid value. The attached processes may be
* quickly accessed by following pointers from struct pid.
```

每个进程有进程标识符、用户标识符、组标识符，如下：

-  Pid  : 进程标识符 
- Uid、gid :用户标识符、组标识符
- Euid、egid : 有效用户标识符、有效组标识符
- Suid、sgid : 备份用户标识符、备份组标识符
- Fsuid、fsgid : 文件系统用户标识符、文件系统组标识符

在系统运行时可以使用 `ps` 命令查看进程信息：

```bash
root@M5Core135:~# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  1.8  1.8  30888  8356 ?        Ss   00:39   0:06 /sbin/init
root         2  0.0  0.0      0     0 ?        S    00:39   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        I<   00:39   0:00 [rcu_gp]
root         4  0.0  0.0      0     0 ?        I<   00:39   0:00 [rcu_par_gp]
root         5  0.1  0.0      0     0 ?        I    00:39   0:00 [kworker/0:0-ev
root         6  0.1  0.0      0     0 ?        I<   00:39   0:00 [kworker/0:0H-m
root         7  0.4  0.0      0     0 ?        I    00:39   0:01 [kworker/u2:0-e
root         8  0.0  0.0      0     0 ?        I<   00:39   0:00 [mm_percpu_wq]
root         9  0.0  0.0      0     0 ?        S    00:39   0:00 [rcu_tasks_kthr
root        10  0.0  0.0      0     0 ?        S    00:39   0:00 [rcu_tasks_trac
root        11  0.0  0.0      0     0 ?        S    00:39   0:00 [ksoftirqd/0]
root        12  0.0  0.0      0     0 ?        I    00:39   0:00 [rcu_preempt]
root        13  0.0  0.0      0     0 ?        S    00:39   0:00 [kdevtmpfs]
root        14  0.0  0.0      0     0 ?        I<   00:39   0:00 [netns]
root        15  0.0  0.0      0     0 ?        I<   00:39   0:00 [inet_frag_wq]
root        17  0.0  0.0      0     0 ?        S    00:39   0:00 [oom_reaper]
root        18  0.0  0.0      0     0 ?        I<   00:39   0:00 [writeback]
root        19  0.0  0.0      0     0 ?        S    00:39   0:00 [kcompactd0]
root        39  0.0  0.0      0     0 ?        I<   00:39   0:00 [kblockd]
root        40  0.0  0.0      0     0 ?        I<   00:39   0:00 [blkcg_punt_bio
root        41  0.0  0.0      0     0 ?        I<   00:39   0:00 [ata_sff]
root        42  0.0  0.0      0     0 ?        I<   00:39   0:00 [edac-poller]
root        43  0.0  0.0      0     0 ?        I<   00:39   0:00 [devfreq_wq]
root        44  0.0  0.0      0     0 ?        S    00:39   0:00 [watchdogd]
root        45  0.8  0.0      0     0 ?        I    00:39   0:02 [kworker/u2:1-w
root        47  0.0  0.0      0     0 ?        I<   00:39   0:00 [rpciod]
root        48  0.0  0.0      0     0 ?        I<   00:39   0:00 [kworker/u3:0]
root        49  0.0  0.0      0     0 ?        I<   00:39   0:00 [xprtiod]
root        50  0.0  0.0      0     0 ?        S    00:39   0:00 [kswapd0]
root        52  0.0  0.0      0     0 ?        I<   00:39   0:00 [nfsiod]
root        53  0.1  0.0      0     0 ?        I    00:39   0:00 [kworker/0:2-ev
root        54  0.0  0.0      0     0 ?        I    00:39   0:00 [kworker/0:3-ev
root        55  0.0  0.0      0     0 ?        I<   00:39   0:00 [optee_pcpu_not
root        56  0.0  0.0      0     0 ?        S    00:39   0:00 [hwrng]
root        57  0.0  0.0      0     0 ?        I<   00:39   0:00 [kstrp]
root        58  0.0  0.0      0     0 ?        I    00:39   0:00 [kworker/u2:3-e
root        64  0.0  0.0      0     0 ?        S    00:40   0:00 [irq/52-5a00100
root        65  0.0  0.0      0     0 ?        S    00:40   0:00 [irq/53-5a00100
root        66  0.0  0.0      0     0 ?        S    00:40   0:00 [card0-crtc0]
root        68  0.0  0.0      0     0 ?        I<   00:40   0:00 [stmmac_wq]
root        70  0.0  0.0      0     0 ?        I<   00:40   0:00 [stmmac_wq]
root        72  0.0  0.0      0     0 ?        S    00:40   0:00 [irq/60-4c00400
root        73  0.0  0.0      0     0 ?        S    00:40   0:00 [irq/62-ft6x36]
root        74  0.0  0.0      0     0 ?        S    00:40   0:00 [irq/63-4c00600
root        75  0.0  0.0      0     0 ?        S    00:40   0:00 [irq/41-stm_the
root        76  0.0  0.0      0     0 ?        S    00:40   0:00 [irq/43-mmci-pl
root        77  0.0  0.0      0     0 ?        S    00:40   0:00 [irq/22-4400400
root        78  0.0  0.0      0     0 ?        S    00:40   0:00 [spi0]
root        80  0.0  0.0      0     0 ?        I<   00:40   0:00 [mmc_complete]
root        81  0.0  0.0      0     0 ?        I<   00:40   0:00 [kworker/0:2H-k
root        82  0.0  0.0      0     0 ?        S    00:40   0:00 [jbd2/mmcblk0p1
root        83  0.0  0.0      0     0 ?        I<   00:40   0:00 [ext4-rsv-conve
root        85  0.0  0.0      0     0 ?        I<   00:40   0:00 [mld]
root        86  0.0  0.0      0     0 ?        I<   00:40   0:00 [ipv6_addrconf]
root       120  0.3  1.6  27156  7260 ?        Ss   00:40   0:01 /lib/systemd/sy
root       137  0.9  1.1  20076  5036 ?        Ss   00:40   0:03 /lib/systemd/sy
root       203  0.0  0.4   7152  2112 ?        Ss   00:40   0:00 /usr/sbin/cron 
message+   204  0.3  0.6   5832  3024 ?        Ss   00:40   0:01 /usr/bin/dbus-d
polkitd    206  0.0  1.1  35672  5400 ?        Ssl  00:40   0:00 /usr/lib/polkit
root       207  0.1  1.2  10888  5592 ?        Ss   00:40   0:00 /lib/systemd/sy
root       221  0.2  1.9  55352  8860 ?        Ssl  00:40   0:00 /usr/sbin/Modem
root       222  0.5  3.1  55316 14360 ?        Ssl  00:40   0:01 /usr/sbin/Netwo
root       224  0.0  1.7  10820  7736 ?        Ss   00:40   0:00 /sbin/wpa_suppl
root       227  0.0  0.0      0     0 ?        I<   00:40   0:00 [cfg80211]
root       259  0.0  1.3  10584  6156 ?        Ss   00:40   0:00 sshd: /usr/sbin
root       263  0.0  0.5   7136  2528 ?        S    00:40   0:00 bash -c cd /roo
root       266  0.0  0.2   2128  1252 ?        S    00:40   0:00 ./ts_test
root       267  0.0  0.3   4004  1464 tty1     Ss+  00:40   0:00 /sbin/agetty -o
root       295  0.0  0.0      0     0 ?        S    00:40   0:00 [RTW_CMD_THREAD
root       427  1.2  0.6  10072  3008 ttySTM0  Ss   00:44   0:01 /bin/login -p -
root       428  0.0  0.0      0     0 ?        S    00:44   0:00 [irq/57-4400300
root       438 24.4  1.6  12420  7400 ?        Ss   00:45   0:01 /lib/systemd/sy
root       442  0.0  0.8  32304  3784 ?        S    00:45   0:00 (sd-pam)
root       460  0.5  0.6   7236  2776 ttySTM0  S    00:45   0:00 -bash
root       465  300  0.8  10660  3660 ttySTM0  R+   00:45   0:00 ps aux
```

完整的描述一个进程的结构体需要很长的文字和代码说明，但是我们实际使用时，更多只用了解进程的状态，生命周期以及操作系统如何调度分配资源即可。

### Linux 进程状态

进程是程序运行的集合体，操作系统的资源是共享的，所以进程不能无休止的占用 CPU，同时进程也不是一直在运行。于是操作系统对进程进程状态进行了划分:

- TASK_RUNNING （可运行状态）：处于这种状态的进程，要么正在运行、要么正准备运行。正在运行的进程就是当前进程（由current所指向的进程），而准备运行的进程只要得到CPU就可以立即投入运行，CPU是这些进程唯一等待的系统资源。在任务管理器中用 R 标识。

- TASK_INTERRUPTIBLE（可中断的等待状态）：表示进程被阻塞（睡眠），直到某个条件达成，进程的状态就被设置为TASK_RUNNING。处于该状态的进程正在等待某个事件（event）或某个资源，而被挂起。对应的task_struct结构被放入对应事件的等待队列中。处于可中断等待态的进程可以被信号（外部中断触发或者其他进程触发）唤醒，如果收到信号，该进程就从等待状态进入可运行状态，并且加入到运行队列中，等待被调度。在任务管理器中用 S 标识。
- TASK_UNINTERRUPTIBLE（不可中断的等待状态）：该状态与 TASK_INTERRUPTIBLE  状态类似，也表示进程被阻塞，处于睡眠状态。当进程等待的某些条件被满足了之后，内核也会将该进程的状态设置为  TASK_RUNNING。但是，处于这个状态下的进程不能在接收到某个信号之后立即被唤醒。这时该状态与 TASK_INTERRUPTIBLE  状态唯一的区别。在任务管理器中用 D 标识。

- __TASK_STOPPED（暂停状态）：此时的进程暂时停止运行来接受某种特殊处理。通常当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或 SIGTTOU信号后就处于这种状态。例如，正接受调试的进程就处于这种状态。在任务管理器中用 T 标识。
- __TASK_TRACED（跟踪状态）：当前进程正在被另一个进程所监视。在任务管理器中用 T 标识。
- EXIT_ZOMBIE（僵死状态）：进程虽然已经终止，但由于某种原因，父进程还没有执行wait()系统调用，终止进程的信息也还没有回收。顾名思义，处于该状态的进程就是死进程，这种进程实际上是系统中的垃圾，必须进行相应处理以释放其占用的资源。在任务管理器中用 Z 标识。
- EXIT_DEAD：一个进程的最终状态。在任务管理器中用 X 标识。

![](https://images2018.cnblogs.com/blog/1387541/201804/1387541-20180427172257058-89272086.png)

### Linux 进程关系

Linux 中的进程主要是父子关系，除了 1 号进程，其他的进程都是由父进程分裂出来的，在继承关系中属于父子继承。

**1号 init 进程**

1 号进程是内核创建出的第一个用户进程 init，也是所有用户进程的祖先，1 号进程通常的任务是按照初始化脚本完成系统初始化和服务进程的创建，然后就进入回收孤儿进程的进程资源状态。现在的发行版使用了更现代的 init 程序 systemd。systemd 相比之前的 init 进程，提供和接管了更多的系统级服务，如进程组管理，守护进程监控，系统事件动作等等。

**僵尸进程**

进程被父进程创建出来并完成任务退出后，进程占用的资源还停留在系统中，此时需要父进程使用 wait 方法进行子进程资源回收，同时获取子进程的返回值。而没有及时回收资源的已经退出的进程被称为僵尸进程。

僵尸进程占用系统的资源，如果父进程不断的产生僵尸进程，那将会造成系统资源的浪费，从而影响其他进程获取资源。

防止僵尸进程的办法就是及时使用 wait 方法和 waitpid 方法进行资源回收。

**孤儿进程**

孤儿进程是相对于父进程而言的，父进程创建了子进程，但是父进程因为某种原因退出了，然后被父进程的父进程回收了。这时，子进程就脱离了父子关系，成为了孤儿进程。

孤儿进程会被系统中的 1 号 init 进程领养，也就是由 1 号 init 进程来完成孤儿进程结束后的资源回收。


### Linux 进程调度

进程调度是为进程分配计算资源的行为，不同调度算法带来实际体验的差异是很大的，特别是在系统负载比较大的情况下。

Linux 的调度算法经过了下面的几个阶段：

第一阶段：O(n)。每次遍历所有的任务，相当于多个任务一个一个的运行。这种调度算法在进程比较多的情况体验是非常差的。

第二阶段：O(1)。采用一个进程动态优先级的数组队列，算法将会按照优先级顺序查找系统中就绪的进程，然后参与调度。这个调度器很快就被后面的 CFS 公平调度器取代了。

目前：CFS 全然公平调度器。CFS 调度程序使用安抚（ appeasement ）策略确保公平性。当某个任务进入运行队列后，将记录当前时间，当某个进程等待 CPU  时，将对这个进程的 wait_runtime 值加一个数，这个数取决于运行队列当前的进程数。当执行这些计算时，也将考虑不同任务的优先级值。  将这个任务调度到 CPU 后，它的 wait_runtime  值开始递减，当这个值递减到其他任务成为红黑树的最左侧任务时，当前任务将被抢占。通过这种方式，CFS 努力实现一种理想 状态，即  wait_runtime 值为 0。
**CFS调度器类fair_sched_class**
CFS完全公平调度器的调度器类叫 fair_sched_class , 其定义在 kernel/sched/fair.c , line 8521, 它是我们熟知的是 struct sched_class 调度器类类型, 将我们的 CFS 调度器与一些特定的函数关联起来.

```c
/*
 * All the scheduling class methods:
 */
const struct sched_class fair_sched_class = {
        .next                   = &idle_sched_class,  /*  下个优先级的调度类, 所有的调度类通过next链接在一个链表中*/
        .enqueue_task           = enqueue_task_fair,
        .dequeue_task           = dequeue_task_fair,
        .yield_task             = yield_task_fair,
        .yield_to_task          = yield_to_task_fair,

        .check_preempt_curr     = check_preempt_wakeup,

        .pick_next_task         = pick_next_task_fair,
        .put_prev_task          = put_prev_task_fair,

#ifdef CONFIG_SMP
        .select_task_rq         = select_task_rq_fair,
        .migrate_task_rq        = migrate_task_rq_fair,

        .rq_online              = rq_online_fair,
        .rq_offline             = rq_offline_fair,

        .task_waking            = task_waking_fair,
        .task_dead              = task_dead_fair,
        .set_cpus_allowed       = set_cpus_allowed_common,
#endif

        .set_curr_task          = set_curr_task_fair,
        .task_tick              = task_tick_fair,
        .task_fork              = task_fork_fair,

        .prio_changed           = prio_changed_fair,
        .switched_from          = switched_from_fair,
        .switched_to            = switched_to_fair,

        .get_rr_interval        = get_rr_interval_fair,

        .update_curr            = update_curr_fair,

#ifdef CONFIG_FAIR_GROUP_SCHED
        .task_move_group        = task_move_group_fair,
#endif
};
```

下面就这调度器类成员进行介绍：

- enqueue_task：向就绪队列中添加一个进程, 某个任务进入可运行状态时，该函数将得到调用。它将调度实体（进程）放入红黑树中，并对 nr_running 变量加 1。
- dequeue_task：将一个进程从就就绪队列中删除, 当某个任务退出可运行状态时调用该函数，它将从红黑树中去掉对应的调度实体，并从 nr_running 变量中减 1。
- yield_task：在进程想要资源放弃对处理器的控制权的时, 可使用在sched_yield系统调用, 会调用内核API  yield_task完成此工作. compat_yield sysctl  关闭的情况下，该函数实际上执行先出队后入队；在这种情况下，它将调度实体放在红黑树的最右端。
- check_preempt_curr：该函数将检查当前运行的任务是否被抢占。在实际抢占正在运行的任务之前，CFS 调度程序模块将执行公平性测试。这将驱动唤醒式（wakeup）抢占。
- pick_next_task：该函数选择接下来要运行的最合适的进程。
- put_prev_task：用另一个进程代替当前运行的进程。
- set_curr_task：当任务修改其调度类或修改其任务组时，将调用这个函数。
- task_tick：在每次激活周期调度器时, 由周期性调度器调用, 该函数通常调用自 time tick 函数；它可能引起进程切换。这将驱动运行时（running）抢占。
- task_new：内核调度程序为调度模块提供了管理新任务启动的机会, 用于建立fork系统调用和调度器之间的关联, 每次新进程建立后, 则用new_task通知调度器, CFS 调度模块使用它进行组调度，而用于实时任务的调度模块则不会使用这个函数。

**CFS的就绪队列**

就绪队列是全局调度器许多操作的起点, 但是进程并不是由就绪队列直接管理的, 调度管理是各个调度器的职责,  因此在各个就绪队列中嵌入了特定调度类的子就绪队列(cfs的顶级调度就队列struct cfs_rq， 实时调度类的就绪队列struct  rt_rq和deadline调度类的就绪队列struct dl_rq)。

```c
/* CFS-related fields in a runqueue */
/* CFS调度的运行队列，每个CPU的rq会包含一个cfs_rq，而每个组调度的sched_entity也会有自己的一个cfs_rq队列 */
struct cfs_rq {
    /* CFS运行队列中所有进程的总负载 */
    struct load_weight load;
    /*
     *  nr_running: cfs_rq中调度实体数量
     *  h_nr_running: 只对进程组有效，其下所有进程组中cfs_rq的nr_running之和
    */
    unsigned int nr_running, h_nr_running;

    u64 exec_clock;

    /*
     * 当前CFS队列上最小运行时间，单调递增
     * 两种情况下更新该值: 
     * 1、更新当前运行任务的累计运行时间时
     * 2、当任务从队列删除去，如任务睡眠或退出，这时候会查看剩下的任务的vruntime是否大于min_vruntime，如果是则更新该值。
     */

    u64 min_vruntime;
#ifndef CONFIG_64BIT
    u64 min_vruntime_copy;
#endif
    /* 该红黑树的root */
    struct rb_root tasks_timeline;
     /* 下一个调度结点(红黑树最左边结点，最左边结点就是下个调度实体) */
    struct rb_node *rb_leftmost;

    /*
     * 'curr' points to currently running entity on this cfs_rq.
     * It is set to NULL otherwise (i.e when none are currently running).
     * curr: 当前正在运行的sched_entity（对于组虽然它不会在cpu上运行，但是当它的下层有一个task在cpu上运行，那么它所在的cfs_rq就把它当做是该cfs_rq上当前正在运行的sched_entity）
     * next: 表示有些进程急需运行，即使不遵从CFS调度也必须运行它，调度时会检查是否next需要调度，有就调度next
     *
     * skip: 略过进程(不会选择skip指定的进程调度)
     */
    struct sched_entity *curr, *next, *last, *skip;

#ifdef  CONFIG_SCHED_DEBUG
    unsigned int nr_spread_over;
#endif

#ifdef CONFIG_SMP
    /*
     * CFS load tracking
     */
    struct sched_avg avg;
    u64 runnable_load_sum;
    unsigned long runnable_load_avg;
#ifdef CONFIG_FAIR_GROUP_SCHED
    unsigned long tg_load_avg_contrib;
#endif
    atomic_long_t removed_load_avg, removed_util_avg;
#ifndef CONFIG_64BIT
    u64 load_last_update_time_copy;
#endif

#ifdef CONFIG_FAIR_GROUP_SCHED
    /*
     *   h_load = weight * f(tg)
     *
     * Where f(tg) is the recursive weight fraction assigned to
     * this group.
     */
    unsigned long h_load;
    u64 last_h_load_update;
    struct sched_entity *h_load_next;
#endif /* CONFIG_FAIR_GROUP_SCHED */
#endif /* CONFIG_SMP */

#ifdef CONFIG_FAIR_GROUP_SCHED
    /* 所属于的CPU rq */
    struct rq *rq;  /* cpu runqueue to which this cfs_rq is attached */

    /*
     * leaf cfs_rqs are those that hold tasks (lowest schedulable entity in
     * a hierarchy). Non-leaf lrqs hold other higher schedulable entities
     * (like users, containers etc.)
     *
     * leaf_cfs_rq_list ties together list of leaf cfs_rq's in a cpu. This
     * list is used during load balance.
     */
    int on_list;
    struct list_head leaf_cfs_rq_list;
    /* 拥有该CFS运行队列的进程组 */
    struct task_group *tg;  /* group that "owns" this runqueue */

#ifdef CONFIG_CFS_BANDWIDTH
    int runtime_enabled;
    u64 runtime_expires;
    s64 runtime_remaining;

    u64 throttled_clock, throttled_clock_task;
    u64 throttled_clock_task_time;
    int throttled, throttle_count;
    struct list_head throttled_list;
#endif /* CONFIG_CFS_BANDWIDTH */
#endif /* CONFIG_FAIR_GROUP_SCHED */
};
```

成员描述：

- nr_running：队列上可运行进程的数目。
- load：就绪队列上可运行进程的累计负荷权重。
- min_vruntime：跟踪记录队列上所有进程的最小虚拟运行时间. 这个值是实现与就绪队列相关的虚拟时钟的基础。
- tasks_timeline：用于在按时间排序的红黑树中管理所有进程。
- rb_leftmost：总是设置为指向红黑树最左边的节点, 即需要被调度的进程. 该值其实可以可以通过病例红黑树获得, 但是将这个值存储下来可以减少搜索红黑树花费的平均时间。
- curr：当前正在运行的sched_entity（对于组虽然它不会在cpu上运行，但是当它的下层有一个task在cpu上运行，那么它所在的cfs_rq就把它当做是该cfs_rq上当前正在运行的sched_entity。
- next：表示有些进程急需运行，即使不遵从CFS调度也必须运行它，调度时会检查是否next需要调度，有就调度next。
- skip：略过进程(不会选择skip指定的进程调度)。

**红黑树**

红黑树 (Red–black tree) 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构。在 CFS 调度器中将  sched_entity 存储在以时间为顺序的红黑树中，vruntime 最低的进程存储在树的左侧，vruntime 最高的进程存储在树的右侧。  为了公平，调度器每次都会选取红黑树最左端的节点调度以便保持公平性。这样，整颗红黑树最左侧的进程就被给予时间运行了，树的内容从右侧迁移到左侧以保持公平。同时，红黑树的时间复杂度为 O(log *n*)，可以快速高效地执行插入或是删除操作。如下图：

![](https://images2018.cnblogs.com/blog/1387541/201804/1387541-20180427191232454-997801789.png)



> 1.https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B/382503?fr=aladdin
>
> 2.http://blog.chinaunix.net/uid-24203478-id-3130713.html
>
> 3.https://blog.csdn.net/jinkang_zhao/article/details/71367924
>
> 4.https://blog.csdn.net/gatieme/article/details/51701149
>
> 5.https://blog.csdn.net/gatieme/article/details/52067518



### 进程的创建与运行

#### 进程的创建

只有一个进程的 C 语言代码:

```c
// file : process.c
#include<stdio.h>
#include<unistd.h>
int main(int argc, char argv[]) 
{
    printf("i am process...pid:%d,ppid:%d\n",getpid(),getppid());
    return 0;
}
```

然后用 GCC 编译这个源码并执行，查看效果：

```bash 
root@M5Core135:~/tmp# gcc process.c -o process
root@M5Core135:~/tmp# ./process 
i am process...pid:581,ppid:549
```

可以看出，这个程序执行的时候相当于一个进程了，然后打印出了自己进程的 pid 和 ppid 。

创建一个子进程的 C 语言代码：

``` c
// file : fork_process.c
#include <stdio.h>
#include <unistd.h>
int main(int argc, char argv[])
{
    pid_t id = fork(); // 创建子进程

    if (id == 0)
    {
        printf("i am process...child---pid:%d,ppid:%d\n", getpid(), getppid());
        sleep(1);
    }
    else if (id > 0)
    {
        printf("i am process..father---pid:%d,ppid:%d\n", getpid(), getppid());
        sleep(1);
    }
    else
    {
        perror("fork error!");
    }
    return 0;
}
```

编译执行后查看效果：

```bash
root@M5Core135:~/tmp# gcc fork_process.c -o fork_process
root@M5Core135:~/tmp# ./fork_process 
i am process..father---pid:628,ppid:549
i am process...child---pid:629,ppid:628
```

这段 C 程序是使用 fork 函数来创建一个子进程，`fork` 是一个在 Unix/Linux 操作系统中创建新进程的系统调用。这个系统调用会创建一个当前进程的副本（子进程）。这两个进程（父进程和子进程）在执行的瞬间是相同的，但是它们有着不同的进程 ID（PID）。在父进程返回的是子进程的 pid 号，而在子进程中会返回 0 。

![](https://pic1.zhimg.com/80/v2-4c547ab288db2beea4cca329a74b5688_720w.webp)

创建一个守护进程（孤儿进程）：

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

void daemond()
{
    // 父进程创建子进程,然后退出,形式上脱离控制终端
    pid_t pid = fork();
    if (pid > 0)
    {
        exit(0);
    }
    // 子进程创建一个新的会话
    setsid();
    // 改变当前目录为根目录
    chdir("/");
    // 设置umask掩码,防止从父进程继承的过来的屏蔽字拒绝某些权限
    umask(0);
    // 关闭文件描述符,节省系统资源
    // STDIN_FILENO就是标准输入设备（一般是键盘）的文件描述符
    // 写入/dev/null的东西会被系统丢掉
    close(STDIN_FILENO);
    // 再一次的保护
    open("/dev/null", O_RDWR);
    dup2(0, 1);
    dup2(0, 2);
    // 守护进程的核心逻辑
    // 退出
}

int main(int argc, char argv[])
{
    daemond();
    while (1)
        ;
    return 0;
}
```

#### 进程的输入输出

进程的输入输出其实就是程序的基本输入输出，对于进程来讲，操作系统给进程提供的输入输出有多个通道。

**标准输入输出**

   - `stdin` **标准输入**是程序默认的输入流。它通常关联到键盘或其他输入设备。程序可以从 `stdin` 中读取数据。在大多数编程语言中，可以使用标准库中的函数（例如，C 语言中的 `scanf` 或 Python 中的 `input`）来从 `stdin` 读取输入。

   - `stdout` **标准输出**是程序默认的输出流。它通常关联到终端窗口或其他输出设备。程序可以通过 `stdout` 输出结果，供用户或其他程序查看。在大多数编程语言中，可以使用标准库中的函数（例如，C 语言中的 `printf` 或 Python 中的 `print`）将输出发送到 `stdout`。也可使用 fprintf(stdout, ...) 直接将输出发送到 `stdout`。

   - `stderr` **标准错误输出**用于输出错误消息和诊断信息，通常关联到终端窗口或日志文件。与 `stdout` 类似，程序可以使用标准库中的函数将错误消息发送到 `stderr`。在大多数情况下，错误消息应该被输出到 `stderr`，以便于与正常输出区分。

下面是一个使用 C 语言的简单示例，演示了标准输入输出：

```c
// file : stdio_test.c
#include <stdio.h>

int main(int argc, char argv[]) {
    int number;

    // 从标准输入读取数据
    printf("Enter a number: ");
    scanf("%d", &number);

    // 将结果输出到标准输出
    printf("You entered: %d\n", number);

    // 将结果输出到标准错误输出
    fprintf(stderr, "This is an error message\n");
    
    
    return 0;
}

```

编译执行：

```bash
root@M5Core135:~/tmp# gcc stdio_test.c -o stdio_test
root@M5Core135:~/tmp# ./stdio_test 
Enter a number: 1
You entered: 1
This is an error message
```

**命令行参数**

命令行参数就是从命令行传入的参数，对于 C 程序入口 main 函数是这样写的 `int main(int argc, char argv[])`其实里面的参数保存的就是命令行传参。

- `argc`（argument count）是一个整数，表示命令行参数的数量。
- `argv`（argument vector）是一个字符指针数组，每个指针指向一个字符串，即命令行参数的实际值。

以下是一个简单的示例，演示如何在 C 语言程序中使用命令行参数：

```c
// file : cmdline_test.c
#include <stdio.h>

int main(int argc, char *argv[]) {
    // 打印程序的名称
    printf("Program name: %s\n", argv[0]);

    // 打印命令行参数的数量
    printf("Number of arguments: %d\n", argc - 1);

    // 打印所有命令行参数
    for (int i = 1; i < argc; i++) {
        printf("Argument %d: %s\n", i, argv[i]);
    }

    return 0;
}
```

编译运行：

```bash
root@M5Core135:~/tmp# gcc cmdline_test.c -o cmdline_test
root@M5Core135:~/tmp# ./cmdline_test a b c=2 -d1
Program name: ./cmdline_test
Number of arguments: 4
Argument 1: a
Argument 2: b
Argument 3: c=2
Argument 4: -d1
```

显然，命令行参数只有输入，没有输出。

**环境变量**

对于一个程序来说，进程启动的时候是有一些默认的环境参数的，这些环境参数也能被程序所读取。环境变量是一个选项和选项对应的参数值，程序读取后就能知道当前执行环境是什么样子的。

在 C 语言中，可以通过标准库 `<stdlib.h>` 中的 `getenv` 函数来获取环境变量的值。环境变量是在操作系统中存储配置信息和其他系统参数的一种机制。

以下是一个简单的例子，演示如何使用 `getenv` 函数获取和输出环境变量的值：

```c
// file : env_test.c
#include <stdio.h>
#include <stdlib.h>

// 外部变量，定义在 <unistd.h> 或 <stdlib.h> 中
extern char **environ;

int main() {
    
    // 遍历环境变量
    for (char **env = environ; *env != NULL; env++) {
        printf("%s\n", *env);
    }
    
    // 获取环境变量 PATH 的值
    char *path_value = getenv("PATH");

    if (path_value != NULL) {
        printf("PATH environment variable: %s\n", path_value);
    } else {
        printf("PATH environment variable not found\n");
    }

    return 0;
}
```

编译运行:

```bash
root@M5Core135:~/tmp# gcc env_test.c -o env_test
root@M5Core135:~/tmp# ./env_test 
SHELL=/bin/bash
LC_ADDRESS=zh_CN.UTF-8
LC_NAME=zh_CN.UTF-8
LC_MONETARY=zh_CN.UTF-8
PWD=/root/tmp
LOGNAME=root
XDG_SESSION_TYPE=tty
MOTD_SHOWN=pam
HOME=/root
LANG=en_US.UTF-8
LC_PAPER=zh_CN.UTF-8
SSH_CONNECTION=192.168.31.156 44602 192.168.31.172 22
LCD_FRAMEBUFFER=/dev/fb1
XDG_SESSION_CLASS=user
TERM=xterm-256color
LC_IDENTIFICATION=zh_CN.UTF-8
USER=root
SHLVL=1
LC_TELEPHONE=zh_CN.UTF-8
LC_MEASUREMENT=zh_CN.UTF-8
XDG_SESSION_ID=c3
LD_LIBRARY_PATH=/usr/local/lib
LC_CTYPE=zh_CN.UTF-8
XDG_RUNTIME_DIR=/run/user/0
SSH_CLIENT=192.168.31.156 44602 22
LC_TIME=zh_CN.UTF-8
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/0/bus
SSH_TTY=/dev/pts/0
LC_NUMERIC=zh_CN.UTF-8
_=./env_test
OLDPWD=/root
PATH environment variable: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

由于环境变量没有统一的描述，所以关于环境变量的每个条目的具体含义可以去搜索引擎的自行搜索，在此不做详细注解。

## 5. 守护进程

### 守护进程概述

守护进程，也就是通常所说的 Daemon 进程，是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性的执行某种任务或等待处理某些发生的事件。守护进程常常在系统启动时开始运行，在系统关闭时终止。

Linux 系统有很多守护进程，大多数服务都是用守护进程实现的。例如常见的常见的守护进程包括系统日志进程syslogd、 web 服务器 httpd、邮件服务器 sendmail 和数据库服务器 mysqld 等。

守护进程一部分是由 init 进程直接创建而来，一部分是由应用进程传建的孤儿进程被 init 进程领养后称为守护进程。

### 进程与终端

在Linux中，每一个系统与用户进行交流的界面称为终端。从该终端开始运行的进程都会依附于这个终端，这个终端称为这些进程的控制终端。当控制终端被关闭时，相应的进程都会被自动关闭。

守护进程能够突破这种限制，它从开始运行，直到整个系统关闭才会退出。如果想让某个进程不会因为用户或终端的变化而受到影响，就必须把这个进程变成一个守护进程。

### 查看守护进程

命令： ps axj

![img](https://pic2.zhimg.com/80/v2-173bb6563452685ee4727bfca34a647d_720w.jpg)

### Linux守护进程编写

![img](https://pic1.zhimg.com/80/v2-d2587b6609490298b680a43e8be9db78_720w.webp)

进程被创建出来后，如果不进行保护性设置，很容易就会受到终端或者父进程的影响而退出工作。创建守护进程的步骤其实就是如何创建出孤儿进程，并进行保护的过程。

第一步，创建孤儿进程。`

```c
// 创建子进程
pid_t child_pid = fork();

// 检查 fork 是否成功
if (child_pid < 0) {
    perror("fork");
    exit(EXIT_FAILURE);
}

// 父进程退出，使子进程成为孤儿进程
if (child_pid > 0) {
    exit(EXIT_SUCCESS);
}
```

第一步完成以后，子进程就在形式上做到了与控制终端的脱离

由于父进程已经先于子进程退出，子进程变成孤儿进程

由于守护进程是脱离控制终端的，因此，完成第一步后就会在 shell 终端里造成一程序已经运行完毕的假象。之后的所有后续工作都在子进程中完成，而用户在 shell 终端里则可以执行其他的命令，从而在形式上做到了与控制终端的脱离。

第二步，在子进程中创建新会话。

进程被组合成进程组，进程组号 GID 就是进程组长的进程号 PID 。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在孤儿进程的基础上，调用相关函数使进程成为会话组长。

- 进程组：一个或多个进程的集合。进程组由进程组ID来唯一标识。每个进程组都有一个组长进程，进程组ID就是组长进程的进程号。

- 会话期：会话组是一个或多个进程组的集合

- 终端：面向用户交互的程序。

setsid 函数用于创建一个新的会话，并使得当前进程成为新会话组的组长 setsid 函数能够使进程完全独立出来，从而脱离所有其他进程的控制。

![img](https://pic4.zhimg.com/80/v2-1e8d41845cf374453ba9eca960132e0b_720w.webp)

```c
// 创建一个新会话，并使当前进程成为新会话的领头进程
if (setsid() == -1) {
    perror("setsid");
    exit(EXIT_FAILURE);
}
```



第三步：修改当前工作目录。

在进程运行过程中，当前目录所在的文件系统是不能卸载的。所以会占用启动目录，改变工作目录的原因就是避免占用目录资源。所用的函数是 chdir ，用于改变工作目录。

通常的做法是让“/”或”/tmp”作为守护进程的当前工作目录 ，`chdir(“/”);` 或 `chdir(“/tmp”);`。

```c
// 切换工作目录到根目录，防止影响文件系统的卸载
if (chdir("/") == -1) {
    perror("chdir");
    exit(EXIT_FAILURE);
}
```

第四步：重设置文件权限掩码。

文件权限掩码是指文件权限中被屏蔽掉的对应位。把文件权限掩码设置为0，可以增加该守护进程的灵活性。设置文件权限掩码的函数umask();

```c
umask(0);
```

第五步：关闭文件描述符。

新建的子进程会从父进程那里继承所有已经打开的文件。在创建完新的会话后，守护进程已经脱离任何控制终端，应当关闭用不到的文件。这些被打开的文件可能永远不会被守护进程读或写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸载

从终端输入的字符不可能达到守护进程，守护进程中用常规的方法 (如printf) 输出的字符也不可能在终端上显示出来。所以，文件描述符为 0、1 和 2 的三个文件(对应标准输入、标准输出和标准错误这三个流)已经失去了存在的意义，也应被关闭。

```c
// 关闭不需要的文件描述符，防止影响文件操作
close(STDIN_FILENO);
close(STDOUT_FILENO);
close(STDERR_FILENO);
```

完整代码：

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 创建子进程
    pid_t child_pid = fork();

    // 检查 fork 是否成功
    if (child_pid < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    // 父进程退出，使子进程成为孤儿进程
    if (child_pid > 0) {
        exit(EXIT_SUCCESS);
    }

    // 在子进程中

    // 创建一个新会话，并使当前进程成为新会话的领头进程
    if (setsid() == -1) {
        perror("setsid");
        exit(EXIT_FAILURE);
    }

    // 切换工作目录到根目录，防止影响文件系统的卸载
    if (chdir("/") == -1) {
        perror("chdir");
        exit(EXIT_FAILURE);
    }
    
    // 重设置文件权限掩码
	umask(0);
    
    // 关闭不需要的文件描述符，防止影响文件操作
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    // 执行守护进程的核心逻辑，这里用 sleep 模拟
    while (1) {
        sleep(1);
    }

    return 0;
}
```


https://zhuanlan.zhihu.com/p/657482216



## 6. 线程



进程和线程的区别:

进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。进程之间的代码段是相互隔离独立的，他们之间不会被直接影响。线程是存在进程中的多个同时执行的代码段，他们共享进程内的所有资源。线程相当于轻量进程。其实在 Linux 内核中，创建线程时，其实就是相当于创建一个共享的进程。

Linux 中的进程：

在Linux中一个进程的创建实际上伴随着进程控制块（PCB或task_struct），进程地址空间以及页表的创建。

进程控制块（Processing Control Block），是操作系统核心中一种数据结构，主要表示进程状态。其作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位或与其它进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。 PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息，它使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位或一个能与其他进程并发执行的进程。

Linux中的多线程（Linux并不存在真正意义上的线程）：

Linux中每创建一个进程，都要伴随着产生进程控制块，进程地址空间，页表。
而操作系统中有大量的进程，一个进程内又可以包含多个线程，因此线程的数量一定会远远多于进程的。如果一个操作系统要真正地去支持使用线程，那么就必须有某种结构对线程进行相应的管理。比如：线程的创建，终止，转换，调度和释放回收等。
但是Linux并没有单独地为线程创建相应的结构去管理，而是复用了进程的结构。而Windows系统单独为线程创建了相应的结构去管理，会比Linux复杂很多。

![](https://img-blog.csdnimg.cn/f56d42f31e1b44979e515ca014df08e6.png)

由上图可以很好地理解线程为什么是 CPU 调度的基本单位，在 CPU 看来，它只关心一个独立的执行流，无论进程内部是一个还是多个执行流，CPU 都是以 task_struct 为单位来调度的。在 CPU 看来，Linux 中的进程比传统中的进程更加轻量化。进程的执行流我们叫轻量化进程。
也能很好地理解了为什么进程是分配资源的基本单位，因为进程之间是相互独立的，每个进程都有相应的进程地址空间。

线程的优点:

- 新线程的代价要比创建一个新进程小得多
- 程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多
- 占用的资源要比进程少很多
- 分利用多处理器的可并行数量 在等待慢速I/O操作结束的同时，程序可执行其他的计算任务
- 密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现
- O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作。

线程的缺点:
- 性能损失: 少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。
- 性降低: 写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了,该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。
- 访问控制: 是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。
- 难度提高: 与调试一个多线程程序比单线程程序困难得多

线程异常:
单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃
线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出

线程用途:
合理的使用多线程，能提高CPU密集型程序的执行效率合理的使用多线程，能提高IO密集型程序的用户体验（如生活中我们一边打游戏一边听音乐，就是多线程运行的一种表现）

线程 VS 进程

线程共享进程数据，但也拥有自己的一部分数据:

    线程ID； 一组寄存器； 栈； errno； 信号屏蔽字； 调度优先级

进程的多个线程共享 同一地址空间,因此Text Segment、Data Segment都是共享的,如果定义一个函数,在各线程中都可以调用,如果定义一个全局变量,在各线程中都可以访问到,除此之外,各线程还共享以下进程资源和环境:

    文件描述符表；每种信号的处理方式(SIG_ IGN、SIG_ DFL或者自定义的信号处理函数)； 当前工作目录 ；用户id和组id

进程和线程的关系如下图:
![](https://img-blog.csdnimg.cn/b51692ab17bf420ead90ce93ee94553d.png)
Linux 线程控制:

在操作系统的的视角下，Linux下没有真正意义的线程，而是用进程模拟的线程（LWP，轻量级进程），所以Linux不会提供直接创建线程的系统调用，最多提供创建轻量级进程的接口。
但是对于用户来说，用户需要的是线程接口。
所以 Linux 提供了用户线程库，对下将 Linux 接口封装，对上给用户提供进行线程控制的接口，也就是 pthread 库（原生线程库）。

>与线程有关的函数构成了一个完整的系列，绝大多数函数的名字都是以“pthread_”打头的
>要使用这些函数库，要通过引入头文<pthread.h>
>
>链接这些线程函数库时要使用编译器命令的“-lpthread”选项


创建线程:

```c
#include <pthread.h>

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);

```

**参数说明：**

- `thread`：用于存储新线程标识符的指针，`pthread_t` 类型，用于标识新创建的线程。
- `attr`：用于指定新线程属性的指针，可以为 `NULL`，表示使用默认属性。
- `start_routine`：是一个函数指针，指向新线程将要运行的函数。这个函数应该有一个 `void*` 类型的参数，并返回一个 `void*` 类型的指针。
- `arg`：是传递给 `start_routine` 函数的参数。

**返回值：**

- 如果成功，返回 0。
- 如果出现错误，返回一个正整数，表示错误代码。

**使用示例：**

```c
// file: pthread_test.c
#include <stdio.h>
#include <pthread.h>

void *thread_function(void *arg) {
    // 线程的主要逻辑
    printf("Hello from the new thread! Argument passed: %s\n", (char*)arg);
    return NULL;
}

int main() {
    pthread_t my_thread;
    const char *message = "Hello, Thread!";

    // 创建新线程
    int result = pthread_create(&my_thread, NULL, thread_function, (void*)message);

    if (result != 0) {
        fprintf(stderr, "Thread creation failed: %d\n", result);
        return 1;
    }

    // 主线程继续执行其他工作
    printf("Hello from the main thread!\n");

    // 等待新线程结束
    pthread_join(my_thread, NULL);

    return 0;
}
```

编译运行:

```bash
root@M5Core135:~/tmp# gcc pthread_test.c -o pthread_test -lpthread
root@M5Core135:~/tmp# ./pthread_test 
Hello from the main thread!
Hello from the new thread! Argument passed: Hello, Thread!
```

在这个例子中，`pthread_create` 函数用于创建一个新线程，新线程执行 `thread_function` 函数，并传递了一个字符串作为参数。主线程继续执行其他工作，然后通过 `pthread_join` 函数等待新线程结束。这样可以确保在主线程继续执行之前，新线程已经完成了它的任务。


线程ID及地址空间布局：

pthread_ create 函数会产生一个线程 ID，存放在第一个参数指向的地址中。该线程 ID 和前面说的线程 ID 不是一回事。
前面讲的线程 ID 属于进程调度的范畴。因为线程是轻量级进程，是操作系统调度器的最小单位，所以需要一个数值来唯一表示该线程。
pthread_ create 函数第一个参数指向一个虚拟内存单元，该内存单元的地址即为新创建线程的线程ID，属于本地线程库的范畴。线程库的后续操作，就是根据该线程ID来操作线程的。本地线程库提供了 pthread_ self 函数，可以获得线程自身的ID：

 

```c
#include <pthread.h>

pthread_t pthread_self(void);
```

**返回值：**

- 返回调用线程的线程标识符，类型为 `pthread_t`。

**使用示例：**

```c
#include <stdio.h>
#include <pthread.h>

void *thread_function(void *arg) {
    // 获取当前线程的线程标识符
    pthread_t tid = pthread_self();
    printf("Thread ID inside the thread function: %lu\n", tid);

    // 线程的主要逻辑
    // ...

    return NULL;
}

int main() {
    pthread_t my_thread;

    // 创建新线程
    int result = pthread_create(&my_thread, NULL, thread_function, NULL);

    if (result != 0) {
        fprintf(stderr, "Thread creation failed: %d\n", result);
        return 1;
    }

    // 获取主线程的线程标识符
    pthread_t main_tid = pthread_self();
    printf("Thread ID inside the main function: %lu\n", main_tid);

    // 主线程继续执行其他工作
    // ...

    // 等待新线程结束
    pthread_join(my_thread, NULL);

    return 0;
}

```

pthread_t 到底是什么类型呢？取决于实现。对于 Linux 目前实现的本地线程库实现而言，pthread_t 类型的线程ID，本质就是一个进程地址空间上的一个地址。

下图中的mmap区域是共享区
![](https://img-blog.csdnimg.cn/5a5f57ad51e94bbfa3d1891f5431b46f.png)

线程终止:

只终止某个线程而不是终止整个进程，可以有三种方法：

    1.线程函数处进行 return 。
    2.线程可以自己调用 pthread_exit 函数终止自己。
    3.一个线程可以调用 pthread_cancel 函数终止同一进程中的另一个线程。

> 注意：在线程中使用return代表该线程退出，而在main函数（主线程）中使用return代表整个进程退出。

```c
#include <pthread.h>

void pthread_exit(void *retval);
```

**参数说明：**

- `retval`：线程的退出状态，可以是任何指针类型的值。这个状态可以被主线程或其他线程通过 `pthread_join` 函数获取。

**使用示例：**

```c
#include <stdio.h>
#include <pthread.h>

void *thread_function(void *arg) {
    printf("Thread is executing...\n");

    // 模拟一些工作
    for (int i = 0; i < 5; ++i) {
        printf("Working... %d\n", i);
        sleep(1);
    }

    // 线程退出，并传递退出状态
    int *exit_status = malloc(sizeof(int));
    *exit_status = 42;
    pthread_exit((void *)exit_status);

    // 以下的代码不会被执行，因为线程已经退出
    printf("This will not be printed.\n");

    return NULL;
}

int main() {
    pthread_t my_thread;
    void *thread_exit_status;

    // 创建新线程
    int result = pthread_create(&my_thread, NULL, thread_function, NULL);

    if (result != 0) {
        fprintf(stderr, "Thread creation failed: %d\n", result);
        return 1;
    }

    // 主线程等待新线程结束，并获取退出状态
    pthread_join(my_thread, &thread_exit_status);

    if (thread_exit_status != NULL) {
        printf("Thread exit status: %d\n", *((int *)thread_exit_status));
        free(thread_exit_status);
    } else {
        printf("Thread exit status is NULL.\n");
    }

    printf("Main thread exiting...\n");

    return 0;
}
```

在这个示例中，新线程执行了一些工作，然后通过 `pthread_exit` 函数退出，并传递一个退出状态。主线程通过 `pthread_join` 函数等待新线程结束，并获取退出状态。这样，可以在线程退出时传递一些信息，以便主线程了解线程的执行情况。在实际应用中，线程退出状态可以是任何类型的数据，根据需要进行传递。

```c
#include <pthread.h>

int pthread_cancel(pthread_t thread);
```

**参数说明：**

- `thread`：要取消的目标线程的线程标识符。

**返回值：**

- 成功时返回 0。
- 失败时返回一个正整数，表示错误代码。

**使用示例：**

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void *thread_function(void *arg) {
    // 线程的主要逻辑
    while (1) {
        printf("Thread is running...\n");
        sleep(1);
    }

    // 以下的代码不会被执行，因为线程会在取消请求后终止
    printf("This will not be printed.\n");

    return NULL;
}

int main() {
    pthread_t my_thread;

    // 创建新线程
    int result = pthread_create(&my_thread, NULL, thread_function, NULL);

    if (result != 0) {
        fprintf(stderr, "Thread creation failed: %d\n", result);
        return 1;
    }

    // 等待一段时间
    sleep(3);

    // 请求取消线程
    result = pthread_cancel(my_thread);
    if (result != 0) {
        fprintf(stderr, "Thread cancellation failed: %d\n", result);
        return 1;
    }

    // 等待新线程结束
    result = pthread_join(my_thread, NULL);

    if (result == 0) {
        printf("Thread has been canceled.\n");
    } else {
        fprintf(stderr, "Thread join failed: %d\n", result);
        return 1;
    }

    printf("Main thread exiting...\n");

    return 0;
}

```

在这个示例中，主线程创建了一个新线程，然后等待一段时间后发送取消请求给新线程。新线程在主循环中通过 `sleep` 模拟执行一些任务。当主线程发送取消请求后，新线程会在适当的时候（例如在 `sleep` 调用结束后）收到取消请求，并终止执行。主线程通过 `pthread_join` 函数等待新线程结束。需要注意的是，线程在收到取消请求后，可以选择在取消点（cancellation point）终止执行，而不是立即终止。 `sleep` 是一个取消点的例子，它会在收到取消请求后立即返回。



线程回收:

已经退出的线程，其空间没有被释放，仍然在进程的地址空间内。创建新的线程不会复用刚才退出线程的地址空间。

    ```c
    #include <pthread.h>
    
    int pthread_join(pthread_t thread, void **retval);
    
    ```

**参数说明：**

- `thread`：要等待的目标线程的线程标识符。
- `retval`：用于存储目标线程的退出状态的指针。如果不关心退出状态，可以传递 `NULL`。

**返回值：**

- 成功时返回 0。
- 失败时返回一个正整数，表示错误代码。

**使用示例：**

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void *thread_function(void *arg) {
    printf("Thread is executing...\n");

    // 模拟一些工作
    for (int i = 0; i < 5; ++i) {
        printf("Working... %d\n", i);
        sleep(1);
    }

    // 线程退出，并传递退出状态
    int *exit_status = malloc(sizeof(int));
    *exit_status = 42;
    pthread_exit((void *)exit_status);

    // 以下的代码不会被执行，因为线程已经退出
    printf("This will not be printed.\n");

    return NULL;
}

int main() {
    pthread_t my_thread;
    void *thread_exit_status;

    // 创建新线程
    int result = pthread_create(&my_thread, NULL, thread_function, NULL);

    if (result != 0) {
        fprintf(stderr, "Thread creation failed: %d\n", result);
        return 1;
    }

    // 主线程等待新线程结束，并获取退出状态
    result = pthread_join(my_thread, &thread_exit_status);

    if (result == 0) {
        if (thread_exit_status != NULL) {
            printf("Thread exit status: %d\n", *((int *)thread_exit_status));
            free(thread_exit_status);
        } else {
            printf("Thread exit status is NULL.\n");
        }
    } else {
        fprintf(stderr, "Thread join failed: %d\n", result);
        return 1;
    }

    printf("Main thread exiting...\n");

    return 0;
}

```

在这个示例中，主线程创建了一个新线程，然后通过 `pthread_join` 函数等待新线程结束，并获取新线程的退出状态。新线程通过 `pthread_exit` 函数传递了一个退出状态。主线程通过 `pthread_join` 获取新线程的退出状态，并在必要时释放相应的资源。 `pthread_join` 会阻塞调用线程，直到指定的线程结束为止。



线程分离:

默认情况下，新创建的线程是 joinable 的，线程退出后，需要对其进行 pthread_join 操作，否则无法释放资源，从而造成系统泄漏。
如果不关心线程的返回值，join 是一种负担，这个时候，我们可以告诉系统，当线程退出时，自动释放线程资源。

```c
#include <pthread.h>

int pthread_detach(pthread_t thread);

```

**参数说明：**

- `thread`：要分离的目标线程的线程标识符。

**返回值：**

- 成功时返回 0。
- 失败时返回一个正整数，表示错误代码。

**使用示例**

```c
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

void *thread_function(void *arg) {
    printf("Thread is executing...\n");

    // 模拟一些工作
    for (int i = 0; i < 5; ++i) {
        printf("Working... %d\n", i);
        sleep(1);
    }

    // 由于线程被设置为分离状态，无需显式调用pthread_exit
    // 也不需要等待其他线程调用pthread_join

    printf("Thread is exiting...\n");

    return NULL;
}

int main() {
    pthread_t my_thread;

    // 创建新线程
    int result = pthread_create(&my_thread, NULL, thread_function, NULL);

    if (result != 0) {
        fprintf(stderr, "Thread creation failed: %d\n", result);
        return 1;
    }

    // 将新线程设置为分离状态
    result = pthread_detach(my_thread);
    if (result != 0) {
        fprintf(stderr, "Thread detach failed: %d\n", result);
        return 1;
    }

    // 主线程继续执行其他工作
    sleep(3);

    printf("Main thread exiting...\n");

    return 0;
}
```

在这个示例中，主线程创建了一个新线程，并通过 `pthread_detach` 函数将新线程设置为分离状态。这样，新线程在结束时会自动释放其相关资源，无需显式调用 `pthread_join` 或 `pthread_exit`。主线程继续执行其他工作，不需要等待新线程的结束。需要注意的是，一旦线程被设置为分离状态，就不能再将其转换为非分离状态。


https://blog.csdn.net/iamxiaobai_/article/details/131723986



## 7. 线程属性

属性对象是不透明的，而且不能通过赋值直接进行修改。系统提供了一组函数，用于初始化、配置和销毁每种对象类型。

初始化和配置属性后，属性便具有进程范围的作用域。使用属性时最好的方法即是在程序执行早期一次配置好所有必需的状态规范。然后，根据需要引用相应的属性对象。

使用属性对象具有两个主要优点。

- 使用属性对象可增加代码可移植性。

  即使支持的属性可能会在实现之间有所变化，但您不需要修改用于创建线程实体的函数调用。这些函数调用不需要进行修改，因为属性对象是隐藏在接口之后的。

  如果目标系统支持的属性在当前系统中不存在，则必须显式提供才能管理新的属性。管理这些属性是一项非常容易的移植任务，因为只需在明确定义的位置初始化属性对象一次即可。

- 应用程序中的状态规范已被简化。

  例如，假设进程中可能存在多组线程。每组线程都提供单独的服务。每组线程都有各自的状态要求。

  在应用程序执行初期的某一时间，可以针对每组线程初始化线程属性对象。以后所有线程的创建都会引用已经为这类线程初始化的属性对象。初始化阶段是简单和局部的。将来就可以快速且可靠地进行任何修改。

在进程退出时需要注意属性对象。初始化对象时，将为该对象分配内存。必须将此内存返回给系统。`pthreads` 标准提供了用于销毁属性对象的函数调用。

线程属性可用于控制更加细粒的线程，同时更加细致的控制线程的生命周期。

```c
#include <pthread.h>

int pthread_attr_init(pthread_attr_t *attr);
```

**参数说明：**

- `attr`：指向线程属性对象的指针，函数将初始化该对象。

| **属性**     | **值**                  | **结果**                                                     |
| ------------ | ----------------------- | ------------------------------------------------------------ |
| scope        | PTHREAD_SCOPE_PROCESS   | 新线程与进程中的其他线程发生竞争。                           |
| detachstate  | PTHREAD_CREATE_JOINABLE | 线程退出后，保留完成状态和线程 ID。                          |
| stackaddr    | NULL                    | 新线程具有系统分配的栈地址。                                 |
| stacksize    | 0                       | 新线程具有系统定义的栈大小。                                 |
| priority     | 0                       | 新线程的优先级为 0。                                         |
| inheritsched | PTHREAD_EXPLICIT_SCHED  | 新线程不继承父线程调度优先级。                               |
| schedpolicy  | SCHED_OTHER             | 新线程对同步对象争用使用 Solaris 定义的固定优先级。线程将一直运行，直到被抢占或者直到线程阻塞或停止为止。 |

**返回值：**

- 成功时返回 0。
- 失败时返回一个正整数，表示错误代码。

```c
#include <pthread.h>

int pthread_attr_destroy(pthread_attr_t *attr);

```

**参数说明：**

- `attr`：指向线程属性对象的指针，函数将销毁该对象。

**返回值：**

- 成功时返回 0。
- 失败时返回一个正整数，表示错误代码。

**使用示例：**

```c
#include <stdio.h>
#include <pthread.h>

void *thread_function(void *arg) {
    // 线程的主要逻辑
    printf("Thread is executing...\n");
    return NULL;
}

int main() {
    pthread_t my_thread;
    pthread_attr_t my_thread_attr;

    // 初始化线程属性对象
    int result = pthread_attr_init(&my_thread_attr);

    if (result != 0) {
        fprintf(stderr, "Thread attribute initialization failed: %d\n", result);
        return 1;
    }

    // 设置线程属性（例如，设置线程为分离状态）
    // pthread_attr_setdetachstate(&my_thread_attr, PTHREAD_CREATE_DETACHED);

    // 创建新线程时传递线程属性对象
    result = pthread_create(&my_thread, &my_thread_attr, thread_function, NULL);

    if (result != 0) {
        fprintf(stderr, "Thread creation failed: %d\n", result);
        return 1;
    }

    // 等待新线程结束
    result = pthread_join(my_thread, NULL);

    if (result != 0) {
        fprintf(stderr, "Thread join failed: %d\n", result);
        return 1;
    }

    // 销毁线程属性对象
    result = pthread_attr_destroy(&my_thread_attr);

    if (result != 0) {
        fprintf(stderr, "Thread attribute destruction failed: %d\n", result);
        return 1;
    }

    printf("Main thread exiting...\n");

    return 0;
}

```

在这个示例中，主线程创建了一个线程属性对象 `my_thread_attr`，然后通过 `pthread_attr_init` 函数进行初始化。接着，可以通过其他函数如 `pthread_attr_setdetachstate` 来设置线程属性，例如将线程设置为分离状态。在创建新线程时，通过将线程属性对象传递给 `pthread_create` 函数，新线程将继承这些属性。在程序结束时，通过 `pthread_attr_destroy` 函数销毁线程属性对象。


## 8. 线程同步异步

在多线程编程中，"同步"和"异步"是两个重要的概念，它们描述了线程或任务之间的交互和执行方式。

线程同步指的是在多线程环境中，确保线程以一种协调一致的方式执行，通常涉及到对共享资源的访问控制。目的防止数据竞争和条件竞争，确保数据的一致性和完整性。可以通过互斥锁（mutexes）、信号量（semaphores）、读写锁（rwlocks）、条件变量（condition variables）等机制来实现同步。特点是同步操作通常会阻塞线程，直到满足某些条件（例如，获取了锁或接收到信号）。

线程异步指的是线程独立于其他线程执行，不需要等待其他线程的操作完成。目的提高程序的响应性和并发性能，通过允许线程独立运行而不互相干扰。比如创建独立的线程来处理任务，使用回调函数、事件循环、消息队列等。异步操作的特点允许线程在等待某些操作（如I/O操作）完成时继续执行其他任务。
同步例子，如果有一个共享的数据结构，比如一个列表，多个线程需要添加或删除元素，那么这些线程在访问和修改列表时需要通过锁来同步，以确保在任何时刻只有一个线程能修改列表。
异步例子，如果一个线程负责读取网络数据，而另一个线程处理用户输入，这两个线程可以异步运行。网络线程在等待数据到达时不会阻塞用户输入线程，它们各自独立处理自己的任务。

线程同步关注的是线程间的协调和顺序，通常涉及共享资源的安全访问。
线程异步则更关注于线程的独立性和非阻塞性，允许线程在后台执行任务，而主线程可以继续执行其他工作。

在设计多线程程序时，合理地使用同步和异步可以提高程序的效率和响应性，但也需要谨慎处理，以避免死锁、活锁或数据不一致等问题。


### 线程同步

承担线程同步的就是信号量。

线程信号量有下面几种形式：

- 互斥锁：使用互斥锁（互斥）可以使线程按顺序执行。通常，互斥锁通过确保一次只有一个线程执行代码的临界段来同步多个线程。互斥锁还可以保护单线程代码。 
- 条件变量：使用条件变量可以以原子方式阻塞线程，直到某个特定条件为真为止。条件变量始终与互斥锁一起使用。
- 信号：信号可以是未命名的，也可以是命名的。未命名信号在进程内存中分配，并会进行初始化。未命名信号可能可供多个进程使用，具体取决于信号的分配和初始化的方式。命名信号类似于进程共享的信号，区别在于命名信号是使用路径名而非 pshared 值引用的。命名信号可以由多个进程共享。命名信号具有属主用户 ID、组 ID 和保护模式。
- 读写锁：通过读写锁，可以对受保护的共享资源进行并发读取和独占写入。读写锁是可以在**读取**或**写入**模式下锁定的单一实体。要修改资源，线程必须首先获取互斥写锁。必须释放所有读锁之后，才允许使用互斥写锁。

#### 互斥锁

互斥锁函数说明：

| **操作**             | **函数名称**                                                 | 函数参数                                                     | 返回值                                                       |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 初始化互斥锁         | `int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);` | `mutex`：指向互斥锁对象的指针，函数将初始化该对象。`attr`：指向互斥锁属性对象的指针，可以为 `NULL`，表示使用默认属性。 | 成功时返回 0。失败时返回一个正整数，表示错误代码。           |
| 锁定互斥锁           | `int pthread_mutex_lock(pthread_mutex_t *mutex);`            | `mutex`：指向互斥锁对象的指针，函数将尝试获取该互斥锁。      | 同上                                                         |
| 解除锁定互斥锁       | `int pthread_mutex_unlock(pthread_mutex_t *mutex);`          | 同上                                                         | 同上                                                         |
| 使用非阻塞互斥锁锁定 | `pthread_mutex_trylock`                                      | 同上                                                         | 成功时返回 0。 如果互斥锁已经被占用，返回 `EBUSY`（表示资源忙碌，锁已经被其他线程占用）。 如果 `mutex` 无效，返回 `EINVAL`（表示参数无效）。 如果线程不是互斥锁的所有者，返回 `EPERM`（表示没有权限解锁互斥锁）。 其他错误情况下返回相应的错误代码。 |
| 销毁互斥锁           | `int pthread_mutex_destroy(pthread_mutex_t *mutex);`         | 同上                                                         | 成功时返回 0。失败时返回一个正整数，表示错误代码。           |
| 初始化互斥锁属性对象 | `pthread_mutexattr_init`                                     | `attr`：指向互斥锁属性对象的指针，函数将初始化该对象         | 同上                                                         |
| 销毁互斥锁属性对象   | `pthread_mutexattr_destroy`                                  | 同上                                                         | 同上                                                         |



示例:

```c
#include <stdio.h>
#include <pthread.h>

// 共享资源
int shared_data = 0;

// 互斥锁
pthread_mutex_t my_mutex;

void *thread_function(void *arg) {
    // 尝试加锁
    int result = pthread_mutex_trylock(&my_mutex);

    if (result == 0) {
        // 成功获取锁
        // 修改共享资源
        shared_data++;
        printf("Thread %ld: Shared data: %d\n", (long)arg, shared_data);

        // 解锁
        pthread_mutex_unlock(&my_mutex);
    } else if (result == EBUSY) {
        // 锁已经被其他线程占用
        printf("Thread %ld: Mutex is busy, try again later.\n", (long)arg);
    } else {
        // 其他错误情况
        fprintf(stderr, "Thread %ld: Mutex trylock failed: %d\n", (long)arg, result);
    }

    return NULL;
}
void *thread_function1(void *arg) {
    // 加锁
    if (pthread_mutex_lock(&my_mutex) != 0) {
        fprintf(stderr, "Mutex lock failed.\n");
        return NULL;
    }

    // 修改共享资源
    shared_data++;
    printf("Thread %ld: Shared data: %d\n", (long)arg, shared_data);

    // 解锁
    if (pthread_mutex_unlock(&my_mutex) != 0) {
        fprintf(stderr, "Mutex unlock failed.\n");
        return NULL;
    }

    return NULL;
}

int main() {
    pthread_t my_thread1, my_thread2;

    // 初始化互斥锁
    int result = pthread_mutex_init(&my_mutex, NULL);

    if (result != 0) {
        fprintf(stderr, "Mutex initialization failed: %d\n", result);
        return 1;
    }

    // 创建两个线程
    result = pthread_create(&my_thread1, NULL, thread_function, (void *)1);
    if (result != 0) {
        fprintf(stderr, "Thread creation failed: %d\n", result);
        return 1;
    }

    result = pthread_create(&my_thread2, NULL, thread_function, (void *)2);
    if (result != 0) {
        fprintf(stderr, "Thread creation failed: %d\n", result);
        return 1;
    }

    // 等待两个线程结束
    result = pthread_join(my_thread1, NULL);
    if (result != 0) {
        fprintf(stderr, "Thread join failed: %d\n", result);
        return 1;
    }

    result = pthread_join(my_thread2, NULL);
    if (result != 0) {
        fprintf(stderr, "Thread join failed: %d\n", result);
        return 1;
    }

    // 销毁互斥锁
    result = pthread_mutex_destroy(&my_mutex);

    if (result != 0) {
        fprintf(stderr, "Mutex destruction failed: %d\n", result);
        return 1;
    }

    printf("Main thread exiting...\n");

    return 0;
}
```

#### 条件变量

条件变量函数说明：

| **函数名称**                                                 | **操作**           | 函数参数                                                     | 返回值                                             |
| ------------------------------------------------------------ | ------------------ | ------------------------------------------------------------ | -------------------------------------------------- |
| int pthread_condattr_init(pthread_condattr_t *cattr);        | 初始化条件变量属性 | 参数 `attr` 是一个指向条件变量属性对象的指针，该指针将被初始化为默认的条件变量属性值。 | 成功时返回 0。失败时返回一个正整数，表示错误代码。 |
| int pthread_condattr_destroy(pthread_condattr_t *attr);      | 删除条件变量属性   | 参数 `attr` 是一个指向条件变量属性对象的指针，该指针将被销毁。 | 同上                                               |
| int pthread_condattr_setpshared(pthread_condattr_t *attr, int pshared); | 设置条件变量的范围 | 参数 `attr` 是一个指向条件变量属性对象的指针。参数 `pshared` 指定条件变量的共享属性，可以为 `PTHREAD_PROCESS_PRIVATE`（条件变量只能在同一进程内的线程之间共享）或 `PTHREAD_PROCESS_SHARED`（条件变量可在不同进程间的线程之间共享）。 | 同上                                               |
| int pthread_condattr_getpshared(const pthread_condattr_t *attr, int *pshared); | 获取条件变量的范围 | 参数 `attr` 是一个指向条件变量属性对象的指针，该对象已经被初始化。参数 `pshared` 是一个指向整数的指针，用于存储条件变量的共享属性。 | 同上                                               |

   示例：

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

// 共享资源
int shared_variable = 0;

// 条件变量
pthread_cond_t condition_variable;

// 互斥锁
pthread_mutex_t mutex;

// 示例线程函数
void* example_thread(void* arg) {
    int thread_id = *(int*)arg;
    free(arg);

    // 模拟一些工作
    sleep(1);

    // 加锁
    if (pthread_mutex_lock(&mutex) != 0) {
        perror("pthread_mutex_lock");
        return NULL;
    }

    // 修改共享资源
    shared_variable = thread_id;

    // 发送信号通知其他线程条件变量的状态已改变
    if (pthread_cond_signal(&condition_variable) != 0) {
        perror("pthread_cond_signal");
        pthread_mutex_unlock(&mutex);
        return NULL;
    }

    // 解锁
    if (pthread_mutex_unlock(&mutex) != 0) {
        perror("pthread_mutex_unlock");
        return NULL;
    }

    return NULL;
}

int main() {
    // 初始化互斥锁
    if (pthread_mutex_init(&mutex, NULL) != 0) {
        perror("pthread_mutex_init");
        return 1;
    }

    // 初始化条件变量属性对象
    pthread_condattr_t cond_attr;
    if (pthread_condattr_init(&cond_attr) != 0) {
        perror("pthread_condattr_init");
        return 1;
    }

    // 设置条件变量属性为可进程间共享
    if (pthread_condattr_setpshared(&cond_attr, PTHREAD_PROCESS_SHARED) != 0) {
        perror("pthread_condattr_setpshared");
        return 1;
    }

    // 使用初始化后的属性对象创建条件变量
    if (pthread_cond_init(&condition_variable, &cond_attr) != 0) {
        perror("pthread_cond_init");
        return 1;
    }

    // 创建两个线程
    pthread_t thread1, thread2;
    int *thread1_id = malloc(sizeof(int));
    int *thread2_id = malloc(sizeof(int));
    *thread1_id = 1;
    *thread2_id = 2;

    if (pthread_create(&thread1, NULL, example_thread, (void*)thread1_id) != 0 ||
        pthread_create(&thread2, NULL, example_thread, (void*)thread2_id) != 0) {
        perror("pthread_create");
        return 1;
    }

    // 加锁
    if (pthread_mutex_lock(&mutex) != 0) {
        perror("pthread_mutex_lock");
        return 1;
    }

    // 等待条件变量的状态改变
    if (pthread_cond_wait(&condition_variable, &mutex) != 0) {
        perror("pthread_cond_wait");
        pthread_mutex_unlock(&mutex);
        return 1;
    }

    // 打印共享资源的值
    printf("Main Thread: Shared Variable = %d\n", shared_variable);

    // 解锁
    if (pthread_mutex_unlock(&mutex) != 0) {
        perror("pthread_mutex_unlock");
        return 1;
    }

    // 等待线程结束
    if (pthread_join(thread1, NULL) != 0 || pthread_join(thread2, NULL) != 0) {
        perror("pthread_join");
        return 1;
    }

    // 销毁条件变量属性对象
    if (pthread_condattr_destroy(&cond_attr) != 0) {
        perror("pthread_condattr_destroy");
        return 1;
    }

    // 销毁条件变量
    if (pthread_cond_destroy(&condition_variable) != 0) {
        perror("pthread_cond_destroy");
        return 1;
    }

    // 销毁互斥锁
    if (pthread_mutex_destroy(&mutex) != 0) {
        perror("pthread_mutex_destroy");
        return 1;
    }

    return 0;
}

```

信号函数说明:

所需的头文件

```c
#include <semaphore.h>
```

| **函数名称**                                               | **操作**         | 函数参数                                                     | 返回值                                             |
| ---------------------------------------------------------- | ---------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| int sem_init(sem_t *sem, int pshared, unsigned int value); | 初始化信号       | `sem`: 指向要初始化的信号量的指针。 `pshared`: 指定信号量是在进程间共享还是线程间共享。如果为 0，信号量将被线程共享；否则，信号量将在进程间共享。通常使用 `0`。 `value`: 指定信号量的初始值。 | 成功时返回 0。失败时返回一个正整数，表示错误代码。 |
| int sem_post(sem_t *sem);                                  | 增加信号         | `sem`: 指向要增加的信号量的指针。                            | 同上                                               |
| int sem_wait(sem_t *sem);                                  | 基于信号计数阻塞 | `sem`: 指向要减少的信号量的指针。                            | 同上                                               |
| int sem_trywait(sem_t *sem);                               | 减小信号计数     | `sem`: 指向要尝试减少的信号量的指针。                        | 同上                                               |
| int sem_destroy(sem_t *sem);                               | 销毁信号状态     | `sem`: 指向要销毁的信号量的指针。                            | 同上                                               |

示例:

```c
#include <stdio.h>
#include <semaphore.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

// 全局变量，作为信号量
sem_t mySemaphore;

void* thread_wait_function(void* arg) {
    int thread_id = *(int*)arg;
    free(arg);

    printf("Thread %d is waiting using sem_wait...\n", thread_id);

    // 等待信号量
    if (sem_wait(&mySemaphore) == 0) {
        printf("Thread %d acquired the semaphore using sem_wait.\n", thread_id);

        // 模拟一些工作
        sleep(2);

        printf("Thread %d releasing the semaphore.\n", thread_id);

        // 释放信号量
        sem_post(&mySemaphore);
    } else {
        perror("sem_wait");
    }

    return NULL;
}

void* thread_trywait_function(void* arg) {
    int thread_id = *(int*)arg;
    free(arg);

    printf("Thread %d is trying to acquire the semaphore using sem_trywait...\n", thread_id);

    // 尝试等待信号量，如果信号量的值为正，减少该值并继续执行，否则立即返回
    if (sem_trywait(&mySemaphore) == 0) {
        printf("Thread %d acquired the semaphore using sem_trywait.\n", thread_id);

        // 模拟一些工作
        sleep(2);

        printf("Thread %d releasing the semaphore.\n", thread_id);

        // 释放信号量
        sem_post(&mySemaphore);
    } else {
        printf("Thread %d failed to acquire the semaphore using sem_trywait.\n", thread_id);
    }

    return NULL;
}

int main() {
    // 初始化信号量
    if (sem_init(&mySemaphore, 0, 1) != 0) {
        perror("sem_init");
        return 1;
    }

    // 创建线程，一个使用sem_wait，一个使用sem_trywait
    pthread_t thread_wait, thread_trywait;
    
    int* thread_id_wait = malloc(sizeof(int));
    *thread_id_wait = 1;
    if (pthread_create(&thread_wait, NULL, thread_wait_function, (void*)thread_id_wait) != 0) {
        perror("pthread_create");
        return 1;
    }

    int* thread_id_trywait = malloc(sizeof(int));
    *thread_id_trywait = 2;
    if (pthread_create(&thread_trywait, NULL, thread_trywait_function, (void*)thread_id_trywait) != 0) {
        perror("pthread_create");
        return 1;
    }

    // 主线程等待所有线程结束
    if (pthread_join(thread_wait, NULL) != 0) {
        perror("pthread_join");
        return 1;
    }

    if (pthread_join(thread_trywait, NULL) != 0) {
        perror("pthread_join");
        return 1;
    }

    // 销毁信号量
    if (sem_destroy(&mySemaphore) != 0) {
        perror("sem_destroy");
        return 1;
    }

    return 0;
}
```

#### 读写锁

所需头文件

```c
#include <pthread.h>
```

读写锁函数说明:

| **函数名称**                                                 | **操作**         | 函数参数                                                     | 返回值                                             |
| ------------------------------------------------------------ | ---------------- | ------------------------------------------------------------ | -------------------------------------------------- |
| int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);     | 初始化读写锁属性 | `attr`: 指向要初始化的读写锁属性对象的指针。                 | 成功时返回 0。失败时返回一个正整数，表示错误代码。 |
| int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);  | 销毁读写锁属性   | `attr`: 指向要初始化的读写锁属性对象的指针。                 | 同上                                               |
| int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared); | 设置读写锁属性   | `attr`: 指向读写锁属性对象的指针。 `pshared`: 用于指定共享属性的值。可以是 `PTHREAD_PROCESS_PRIVATE`（锁在进程间不共享）或 `PTHREAD_PROCESS_SHARED`（锁在进程间共享）。 | 同上                                               |
| int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *attr, int *pshared); | 获取读写锁属性   | `attr`: 指向读写锁属性对象的指针。 `pshared`: 用于存储共享属性值的整数指针。 | 同上                                               |

示例:

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

pthread_rwlock_t rwlock;

void *reader(void *arg) {
    pthread_rwlock_rdlock(&rwlock);
    printf("Reader: acquired the lock\n");
    pthread_rwlock_unlock(&rwlock);
    printf("Reader: released the lock\n");
    return NULL;
}

void *writer(void *arg) {
    pthread_rwlock_wrlock(&rwlock);
    printf("Writer: acquired the lock\n");
    pthread_rwlock_unlock(&rwlock);
    printf("Writer: released the lock\n");
    return NULL;
}

int main() {
    pthread_t t1, t2, t3;
    pthread_rwlockattr_t attr;
    int shared;

    // Initialize rwlock attributes
    pthread_rwlockattr_init(&attr);

    // Set the rwlock to be shared between processes
    pthread_rwlockattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);

    // Get the rwlock shared attribute
    pthread_rwlockattr_getpshared(&attr, &shared);
    if (shared == PTHREAD_PROCESS_SHARED) {
        printf("rwlock is set to be shared between processes.\n");
    } else {
        printf("rwlock is set to be shared between threads of a process.\n");
    }

    // Initialize the rwlock with the attributes
    pthread_rwlock_init(&rwlock, &attr);

    // Create reader and writer threads
    pthread_create(&t1, NULL, reader, NULL);
    pthread_create(&t2, NULL, writer, NULL);
    pthread_create(&t3, NULL, reader, NULL);

    // Wait for threads to finish
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    pthread_join(t3, NULL);

    // Destroy rwlock and its attributes
    pthread_rwlock_destroy(&rwlock);
    pthread_rwlockattr_destroy(&attr);

    return 0;
}
```

### 线程异步

线程的异步机制只有`信号`，类似于进程的信号。

线程信号具备以下特点

- 任何线程都可以向其它线程(同一进程下)发送信号；
- 每个线程都具备自己独立的信号屏蔽集，不影响其它线程；
- 线程创建时，不继承原线程的信号屏蔽集；
- 同进程下，所有线程共享对某信号的处理方式，即一个设置，所有有效；
- 多个线程的程序，向某一个线程发送终止信号，则整个进程终止

所需头文件

```c
 #include <signal.h>
```

信号函数说明:

| 函数名称                                                     | **操作**   | 函数参数                                                     | 返回值                                                       |
| ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| sighandler_t signal(int signum, sighandler_t handler);       | 安装信号   | `signum`：代表要设置处理程序的信号的编号，例如SIGINT、SIGTERM等。 `handler`：是一个函数指针，指向您希望在接收到指定信号时调用的处理程序函数。处理程序函数必须接受一个整数参数，代表接收到的信号编号，通常命名为`signum`。 | `signal` 函数的返回值是一个函数指针类型 `sighandler_t`，该函数指针指向之前与该信号相关联的信号处理程序。这是为了让您可以在设置新的信号处理程序之前保存旧的处理程序，以便稍后恢复或查询它。如果之前没有与该信号相关联的处理程序，返回值通常为 `SIG_DFL`（默认处理程序）或 `SIG_IGN`（忽略信号）。 |
| int pthread_kill(pthread_t threadid, int signo);             | 发送信号   | 发送信号  `threadid`：指定目标线程的线程标识符（`pthread_t` 类型），即要发送信号的线程。 `signo`：指定要发送的信号的编号，例如SIGINT、SIGTERM等。 | `pthread_kill` 函数成功时返回0，如果发生错误，则返回一个非零的错误代码。您可以使用 `pthread_kill` 函数向另一个线程发送信号，以便该线程可以捕获信号并执行相应的处理。 |
| int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset); | 设置屏蔽集 | `how`：指定要执行的操作。可以采用以下值之一：  `SIG_BLOCK`：将 `set` 中的信号添加到线程的信号屏蔽集中。 `SIG_UNBLOCK`：从线程的信号屏蔽集中解除 `set` 中的信号屏蔽。 `SIG_SETMASK`：将线程的信号屏蔽集设置为 `set` 中的信号集。 `set`：一个指向 `sigset_t` 类型的指针，指定要添加、解除或设置的信号集。 `oldset`：一个指向 `sigset_t` 类型的指针，用于存储之前的信号屏蔽集。如果不需要保存之前的信号屏蔽集，可以将此参数设置为 `NULL`。 | `pthread_sigmask` 函数成功时返回0，如果发生错误，则返回一个非零的错误代码。 |

示例:

```c
/*threadsig.c*/
#include <signal.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
void sighandler(int signo);
 
void *
thr1_fn(void *arg)
{
    struct sigaction    action;
    action.sa_flags = 0;
    action.sa_handler = sighandler;
       
    sigaction(SIGINT, &action, NULL);
    
    pthread_t   tid = pthread_self();
    int     rc;
 
    printf("thread 1 with tid:%lu\n", tid);
    rc = sleep(60);
    if (rc != 0)
        printf("thread 1... interrupted at %d second\n", 60 - rc);
    printf("thread 1 ends\n");
    return NULL;
}
 
void *
thr2_fn(void *arg)
{
    struct sigaction    action;
    pthread_t       tid = pthread_self();
    int         rc, err;
   
    printf("thread 2 with tid:%lu\n", tid);
     
    action.sa_flags = 0;
    action.sa_handler = sighandler;
       
    err = sigaction(SIGALRM, &action, NULL);
     
    rc = sleep(60);
    if (rc != 0)
        printf("thread 2... interrupted at %d second\n", 60 - rc);
    printf("thread 2 ends\n");
    return NULL;
}
 
void *
thr3_fn(void *arg)
{
    pthread_t   tid = pthread_self();
    sigset_t    mask;
    int     rc, err;
   
    printf("thread 3 with tid%lu\n", tid);
 
     
    sigemptyset(&mask); /* 初始化mask信号集 */
   
    sigaddset(&mask, SIGALRM);
    err = pthread_sigmask(SIG_BLOCK, &mask, NULL);
    if (err != 0)
    {
        printf("%d, %s/n", rc, strerror(rc));
        return NULL;
    }
   
    rc = sleep(10);
    if (rc != 0)
        printf("thread 3... interrupted at %d second\n", 60 - rc);
    err = pthread_sigmask( SIG_UNBLOCK,&mask,NULL );
    if ( err != 0 )
    {
        printf("unblock %d, %s/n", rc, strerror(rc));
        return NULL;
    }
    
    rc = sleep(10);
    if (rc != 0)
        printf("thread 3... interrupted at %d second after unblock\n", 60 - rc);

    printf("thread 3 ends\n");
    return NULL;
 
    return NULL;
}
 
int
main(void)
{
    int     rc, err;
    pthread_t   thr1, thr2, thr3, thrm = pthread_self();
 
    printf("thread main with pid %lu\n",thrm);
    err = pthread_create(&thr1, NULL, thr1_fn, NULL);
    if (err != 0) {
        printf("error in creating pthread:%d\t%s\n",err, strerror(rc));
        exit(1);
    }
 
     
/*  pthread_kill(thr1, SIGALRM);    send a SIGARLM signal to thr1 before thr2 set the signal handler, then the whole process will be terminated*/
    err = pthread_create(&thr2, NULL, thr2_fn, NULL);
    if (err != 0) {
        printf("error in creating pthread:%d\t%s\n",err, strerror(rc));
        exit(1);
    }
     
    err = pthread_create(&thr3, NULL, thr3_fn, NULL);
    if (err != 0) {
        printf("error in creating pthread:%d\t%s\n",err, strerror(rc));
        exit(1);
    }
 
    sleep(10);
    //内部产生的信号，只有指定的线程能收到，因此要向所有线程发送
    pthread_kill(thr1, SIGALRM);
    pthread_kill(thr2, SIGALRM);
    pthread_kill(thr3, SIGALRM);
    pthread_kill(thr3, SIGALRM);
    pthread_kill(thr3, SIGALRM);
    sleep(5);
    pthread_join(thr1, NULL);   /*wait for the threads to complete.*/
    pthread_join(thr2, NULL);
    pthread_join(thr3, NULL);
    printf("main ends\n");
    return 0;
}
 
void
sighandler(int signo)
{
    pthread_t   tid = pthread_self();
     
    printf("thread with pid:%lu receive signo:%d\n", tid, signo);
    return;
}
```

在上面的代码中，主线程创建三个线程。线程1注册SIGINT信号(即ctrl+c) ，线程2注册SIGALRM，线程三则是先阻塞SIGALRM，然后解除阻塞。

编译后看运行结果：

```bash
xzc@xzc-HP-ProBook-4446s:~/code/test$ gcc -o threadsig threadsig.c -pthread
xzc@xzc-HP-ProBook-4446s:~/code/test$ ./threadsig 
thread main with pid 139946922108736
thread 2 with tid:139946905396992
thread 1 with tid:139946913789696
thread 3 with tid139946897004288
^Cthread with pid:139946922108736 receive signo:2
thread with pid:139946913789696 receive signo:14
thread 1... interrupted at 4 second
thread 1 ends
thread with pid:139946905396992 receive signo:14
thread 2... interrupted at 4 second
thread 2 ends
^Cthread with pid:139946922108736 receive signo:2
^Cthread with pid:139946922108736 receive signo:2
thread with pid:139946897004288 receive signo:14
thread 3 ends
main ends
xzc@xzc-HP-ProBook-4446s:~/code/test$
```

在第一行红色的地方，主线程正在sleep，我按下ctrl+c，只有主线程收到并处理了信号。说明进程会从主线程开始查找不阻塞该信号的线程来处理job control类的信号。

由于主线程sleep被打断，随后向三个线程发送了SIGALRM，线程1、2由于没有阻塞该信号，被迫从sleep中醒来，并结束进程。进程3仍在sleep。

在第二行红色的地方，线程3第一次sleep终于完成，解除了对SIGALRM的阻塞。于是马上收到被阻塞的SIGALRM(发送3次，只收到一次)。

> 请注意信号阻塞与忽略的区别。



https://www.cnblogs.com/Jscroop/p/12815466.html



## 9. IPC

IPC（Inter-Process  Communication，进程间通信）是一组机制和技术，允许不同进程之间在同一系统上进行数据传输、共享资源和协作。这些IPC机制用于在多个进程之间进行通信，以便它们可以协调工作和交换数据。

### 管道（Pipe）

- 管道是一种用于在父子进程或兄弟进程之间进行通信的简单IPC机制。
- 有两种类型：无名管道（Anonymous Pipe）和命名管道（Named Pipe，也称为FIFO）。
- 无名管道通常用于具有亲缘关系的进程，它们共享文件描述符。
- 命名管道可用于非亲缘关系进程之间的通信。
- 管道是一种半双工通信机制，管道的数据流是单向的,通常从一个进程（写入端）流向另一个进程（读取端），需要使用多个管道才能实现双向通信。
- 管道中的数据是无格式的字节流,通信两端需要协商好数据格式。
- 写端写满数据后会阻塞,读端需要及时读取以防止写端阻塞。
- 管道有大小限制,一般是页大小,超过限制写入会阻塞。
- 管道中的数据存储在页缓冲区中,读完后会从内核缓冲区释放。
- 无名管道在最后一个读或写端关闭后自动删除,不占用磁盘空间，有名管道需要手动删除。
- 可以使用select/poll检测管道是否就绪以实现同步，不用阻塞线程。
- 管道的实质是一个具有 FIFO 性质的特殊文件。

所需头文件：

```c
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
```

相关函数说明:

| 函数名称                                       | **操作**     | 函数参数                                                     | 返回值                                                     |
| ---------------------------------------------- | ------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| int pipe(int pipefd[2]);                       | 创建无名管道 | 参数 `pipefd` 是一个包含两个整数元素的数组，用于存储管道的文件描述符。`pipefd[0]` 用于从管道中读取数据，`pipefd[1]` 用于向管道中写入数据。 | 成功时返回0，失败时返回-1，并设置 `errno` 来指示错误原因。 |
| int mkfifo(const char *pathname, mode_t mode); | 创建命名管道 | `pathname`：指定要创建的命名管道的路径。这是一个字符串，通常是一个文件系统路径，可以是绝对路径或相对路径。 `mode`：指定创建的命名管道的权限和权限掩码。通常使用八进制表示，例如 `0666` 表示读写权限。 | 成功时返回0，失败时返回-1，并设置 `errno` 来指示错误原因。 |

无名管道的示例:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    int pipefd[2];
    pid_t child_pid;

    // 创建管道
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // 创建子进程
    child_pid = fork();

    if (child_pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (child_pid == 0) {
        // 子进程
        close(pipefd[1]); // 关闭写端
        char buffer[100];
        ssize_t bytes_read;

        // 从管道中读取数据
        bytes_read = read(pipefd[0], buffer, sizeof(buffer));

        if (bytes_read == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        printf("Child received data from parent: %.*s\n", (int)bytes_read, buffer);
        close(pipefd[0]); // 关闭读端
    } else {
        // 父进程
        close(pipefd[0]); // 关闭读端
        const char *message = "Hello, child!";

        // 向管道中写入数据
        if (write(pipefd[1], message, strlen(message)) == -1) {
            perror("write");
            exit(EXIT_FAILURE);
        }

        close(pipefd[1]); // 关闭写端
    }

    return 0;
}

```

有名管道的示例:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <string.h>

int main() {
    const char *fifo_path = "/tmp/my_fifo"; // 命名管道的路径

    // 创建命名管道，如果已存在则忽略
    if (mkfifo(fifo_path, 0666) == -1) {
        perror("mkfifo");
        exit(EXIT_FAILURE);
    }

    // 创建子进程
    pid_t pid = fork();

    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        // 子进程写入数据到命名管道
        int fd = open(fifo_path, O_WRONLY);
        if (fd == -1) {
            perror("open");
            exit(EXIT_FAILURE);
        }

        const char *message = "Hello, Parent!";
        ssize_t bytes_written;

        // 向命名管道中写入数据
        bytes_written = write(fd, message, strlen(message));

        if (bytes_written == -1) {
            perror("write");
            exit(EXIT_FAILURE);
        }

        printf("Child wrote data to named pipe.\n");

        // 关闭命名管道文件描述符
        close(fd);
    } else {
        // 父进程读取数据从命名管道
        int fd = open(fifo_path, O_RDONLY);
        if (fd == -1) {
            perror("open");
            exit(EXIT_FAILURE);
        }

        char buffer[100];
        ssize_t bytes_read;

        // 从命名管道中读取数据
        bytes_read = read(fd, buffer, sizeof(buffer));

        if (bytes_read == -1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        printf("Parent received data from child: %.*s\n", (int)bytes_read, buffer);

        // 关闭命名管道文件描述符
        close(fd);

        // 等待子进程退出
        wait(NULL);
    }

    return 0;
}

```



### 消息队列（Message Queues）：

- 消息队列允许进程通过消息进行通信，每个消息都有一个特定的类型。
- 进程可以通过消息队列发送和接收消息，通常采用FIFO（先进先出）方式处理消息。
- 消息队列可以用于不同进程之间的通信，包括不具有亲缘关系的进程。
- 进程间消息队列允许进程异步通信，发送者和接收者不需要同时准备好。

所需头文件：

```c
#include <fcntl.h>  /*Define 0_*constant*/
#include <sys/stat.h>  /*Define mode constants*/
#include <mqueue.h>
```

| 函数名称                                                     | 操作                                                         | 函数参数                                                     | 返回值                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------------- |
| mqd_t mq_open(const char *name, int oflag,  mode_t mode, struct mq_attr *attr); | 创建消息队列实例                                             | name: 消息队列名称，oflag：根据传入标识来创建或者打开一个已创建的消息队列，mode：访问权限，attr：消息队列属性地址。 | 成功返回消息队列描述符，失败返回-1，错误码存于error中 |
| mqd_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio); | 无限阻塞方式接收消息                                         | mqdes: 消息队列描述符，msg_ptr：消息体缓冲区地址，msg_len：消息体长度，长度必须大于等于消息属性设定的最大值，msg_prio：消息优先级。 | 成功返回消息长度，失败返回-1，错误码存于error中       |
| mqd_t mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio, const struct timespec *abs_timeout); | 指定超时时间阻塞方式接收消息                                 | mqdes: 消息队列描述符，msg_ptr：消息体缓冲区地址，msg_len：消息体长度，长度必须大于等于消息属性设定的最大值，msg_prio：消息优先级，abs_timeout：超时时间 | 成功返回消息长度，失败返回-1，错误码存于error中       |
| mqd_t mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio); | 无限阻塞方式发送消息                                         | mqdes: 消息队列描述符，msg_ptr：待发送消息体缓冲区地址，msg_len：消息体长度，msg_prio：消息优先级 | 成功返回 0，失败返回-1                                |
| mqd_t mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio, const struct timespec *abs_timeout); | 指定超时时间阻塞方式发送消息                                 | mqdes: 消息队列描述符，msg_ptr：待发送消息体缓冲区地址，msg_len：消息体长度，msg_prio：消息优先级，abs_timeout：超时时间 | 成功返回 0，失败返回-1                                |
| mqd_t mq_close(mqd_t mqdes);                                 | 关闭消息队列                                                 | mqdes: 消息队列描述符                                        | 成功返回0，失败返回-1                                 |
| mqd_t mq_unlink(const char *name);                           | 删除消息队列，一旦消息队列被成功删除，将无法再使用相同的名称创建该消息队列。 | name: 消息队列名称                                           | 成功返回0，失败返回-1                                 |

使用示例:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <mqueue.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    const char *queue_name = "/my_queue"; // 消息队列的名称
    mqd_t mq; // 消息队列描述符
    struct mq_attr attr; // 消息队列属性
    pid_t child_pid;

    // 设置消息队列属性
    attr.mq_flags = 0;
    attr.mq_maxmsg = 10; // 最大消息数
    attr.mq_msgsize = 256; // 每个消息的最大大小
    attr.mq_curmsgs = 0;

    // 创建消息队列
    mq = mq_open(queue_name, O_CREAT | O_RDWR, 0666, &attr);
    if (mq == (mqd_t)-1) {
        perror("mq_open");
        exit(EXIT_FAILURE);
    }

    // 创建子进程
    child_pid = fork();

    if (child_pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (child_pid == 0) {
        // 子进程重新打开消息队列并发送消息三次
        mqd_t child_mq;

        child_mq = mq_open(queue_name, O_RDWR);
        if (child_mq == (mqd_t)-1) {
            perror("mq_open (child)");
            exit(EXIT_FAILURE);
        }

        for (int i = 0; i < 3; i++) {
            char message[256];
            sprintf(message, "Hello from child process, message %d!", i + 1);
            if (mq_send(child_mq, message, strlen(message) + 1, 0) == -1) {
                perror("mq_send (child)");
                exit(EXIT_FAILURE);
            }
        }

        mq_close(child_mq); // 关闭子进程的消息队列
        exit(EXIT_SUCCESS);
    } else {
        // 父进程接收消息
        char received_message[256];
        unsigned int priority;

        // 等待子进程退出
        wait(NULL);

        // 从消息队列接收消息
        while (mq_receive(mq, received_message, sizeof(received_message), &priority) != -1) {
            printf("Parent received: %s\n", received_message);
        }

        if (errno != EAGAIN) {
            perror("mq_receive (parent)");
            exit(EXIT_FAILURE);
        }
    }

    // 关闭和删除消息队列
    mq_close(mq);
    mq_unlink(queue_name);

    return 0;
}

```

https://zhuanlan.zhihu.com/p/638279470

https://zhuanlan.zhihu.com/p/389623919?utm_id=0

https://zhuanlan.zhihu.com/p/651152391

### 共享内存（Shared Memory）：

- 共享内存允许多个进程共享同一块内存区域，以便它们可以直接读写其中的数据。
- 这是一种高效的IPC机制，但需要额外的同步机制来避免竞态条件。
- 共享内存本质上就是内存中的一块区域，用于进程间通信使用。

所需头文件：

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
```

| 函数名称                                                 | 操作                                                         | 函数参数                                                     | 返回值                                                       |
| -------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| int shmget(key_t key, size_t size, int shmflg);          | 创建共享内存                                                 | `key`：一个用于唯一标识共享内存段的键值。可以使用 `ftok` 函数生成键值，也可以使用IPC_PRIVATE来创建一个新的共享内存段。 `size`：指定要创建或获取的共享内存段的大小（以字节为单位）。 `shmflg`：指定共享内存的访问权限和选项，通常使用 `IPC_CREAT` 标志来创建共享内存段。 | 如果成功，`shmget`函数返回0。 如果失败，返回-1，并设置`errno`以指示错误的原因。 |
| void *shmat(int shmid, const void *shmaddr, int shmflg); | 创建共享内存后还不能直接使用，需要找到内存地址后才能使用，即连接。 | `shmid`：共享内存段的标识符，通常是由`shmget`函数获取的共享内存标识符。 `shmaddr`：通常设置为`NULL`，表示让操作系统自动选择合适的地址来连接共享内存。如果需要指定连接地址，可以提供一个非空指针。 `shmflg`：用于指定连接的选项，通常设置为0。 | 成功，`shmat`函数返回指向连接共享内存的地址的指针。失败，返回`(void*)-1`，并设置`errno`以指示错误的原因。 |
| int shmdt(const void *shmaddr);                          | 当使用完毕后，需要分离挂接的共享内存。                       | `shmaddr`：指向共享内存连接地址的指针，通常是由`shmat`函数返回的连接共享内存的地址。 | 如果成功，`shmdt`函数返回0。 如果失败，返回-1，并设置`errno`以指示错误的原因。 |
| int shmctl(int shmid, int cmd, struct shmid_ds *buf);    | 销毁共享内存                                                 | `shmid`：共享内存段的标识符，通常是由`shmget`函数获取的共享内存标识符。 cmd：用于指定执行的操作命令，可以是以下之一：  `IPC_RMID`：删除共享内存段。 `IPC_STAT`：获取共享内存段的信息。 `IPC_SET`：设置共享内存段的信息。 `buf`：指向`struct shmid_ds`结构的指针，用于传递共享内存段的信息。 | 如果成功，shmctl函数根据操作不同返回不同的值：  如果`cmd`为`IPC_RMID`，则返回0表示删除成功。 如果`cmd`为`IPC_STAT`，则返回0表示成功，并将共享内存段的信息填充到`buf`中。 如果`cmd`为`IPC_SET`，则返回0表示设置成功。 如果失败，返回-1，并设置`errno`以指示错误的原因。 |

示例：

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <sys/wait.h>

#define SHM_SIZE 1024 // 共享内存的大小

int main() {
    key_t key = ftok("shmfile", 65);
    int shmid = shmget(key, SHM_SIZE, 0666 | IPC_CREAT); // 创建共享内存

    if (shmid == -1) {
        perror("shmget");
        exit(1);
    }

    char *shared_memory = (char *)shmat(shmid, NULL, 0); // 连接共享内存

    if (shared_memory == (void *)-1) {
        perror("shmat");
        exit(1);
    }

    // 创建子进程
    pid_t child_pid = fork();

    if (child_pid == -1) {
        perror("fork");
        exit(1);
    }

    if (child_pid == 0) { // 子进程
        printf("Child Process: Writing to shared memory\n");
        sprintf(shared_memory, "Hello from child process!");

        // 分离共享内存
        if (shmdt(shared_memory) == -1) {
            perror("shmdt");
            exit(1);
        }
    } else { // 父进程
        wait(NULL); // 等待子进程完成
        printf("Parent Process: Reading from shared memory\n");
        printf("Data read from shared memory: %s\n", shared_memory);

        // 分离共享内存
        if (shmdt(shared_memory) == -1) {
            perror("shmdt");
            exit(1);
        }

        // 删除共享内存
        if (shmctl(shmid, IPC_RMID, NULL) == -1) {
            perror("shmctl");
            exit(1);
        }
    }

    return 0;
}

```

### 信号（Signals）：

- 信号是一种轻量级IPC机制，用于通知进程发生了某个事件或异常。
- 进程可以发送信号给其他进程，也可以定义自己的信号处理函数来响应接收到的信号。

所需头文件：

```c
#include <unistd.h>
#include <signal.h>
```

| 函数名称 | 操作 | 函数参数 | 返回值 |
| -------- | ---- | -------- | ------ |
| sighandler_t signal(int signum, sighandler_t handler);       | 安装信号   | `signum`：代表要设置处理程序的信号的编号，例如SIGINT、SIGTERM等。 `handler`：是一个函数指针，指向您希望在接收到指定信号时调用的处理程序函数。处理程序函数必须接受一个整数参数，代表接收到的信号编号，通常命名为`signum`。 | `signal` 函数的返回值是一个函数指针类型 `sighandler_t`，该函数指针指向之前与该信号相关联的信号处理程序。这是为了让您可以在设置新的信号处理程序之前保存旧的处理程序，以便稍后恢复或查询它。如果之前没有与该信号相关联的处理程序，返回值通常为 `SIG_DFL`（默认处理程序）或 `SIG_IGN`（忽略信号）。 |

信号编号与说明：

| 信号名  | 编号 | 说明                                                         |
| ------- | ---- | ------------------------------------------------------------ |
| SIGHUP  |  1   | 如果终端界面检测到一个连接断开， 则将此信号送给与该终端相关的进程。 |
| SIGINT  |  2   | 当用户按中断键(一般采用 Delete或Ctrl+C)时，终端驱动程序产生这个信号并将信号送给前台进程组中的每一个进程。当一个进程在运行时失控，特别是它正在屏幕上产生大量不需要的输出时，常用此信号终止它。 |
| SIGQUIT |  3   | 当用户在终端上按退出键(一般采用CtrI+C) 时，产生此信号，并送至前台进程组中的所有进程。 |
| SIGILL  |  4   | 此信号指示进程已执行一条非法硬件指令。                       |
| SIGTRAP |  5   | 指示一个实现定义的硬件故障。                                 |
| SIGABRT |  6   | 调用abort()函数时产生此信号，进程异常终止。                  |
| SIGEMT  |  7   | 指示一个实现定义的硬件故障。                                 |
| SIGFPE  |  8   | 此信号表示一个算术运算异常，例如除以0，浮点溢出等。          |
| SIGKILL |  9   | 强制终止进程。不能被捕捉、阻塞或忽略。                      |
| SIGBUS  | 10   | 指示一个实现定义的硬件故障。                                 |
| SIGSEGV | 11   | 指示进程进行了一次无效的存储访问。                           |
| SIGSYS  | 12   | 指示一个无效的系统调用。由于某种未知原因，某个进程执行了一条系统调用命令，但是调用命令所用的参数无效。 |
| SIGPIPE | 13   | 如果在读进程时已终止写管道，则产生此信号。                   |
| SIGALRM | 14   | 超过用alarm()函数设置的时间时产生此信号。                    |
| SIGTERM | 15   | 这是由kill命令发送的系统默认终止信号。                       |
| SIGURG  | 16   | 此信号通知进程已经发生一个紧急情况。在网络连接上，接到非规定波特率的数据时，此信号可选择地产生。 | 
| SIGCHLD | 17   | 在一个进程终止或停止时，SIGCHLD信号被送给其父进程。如果希望从父进程中了解其子进程的状态改变，则应捕捉此信号。信号捕捉函数中通常要调用wait()函数以取得子进程ID和其终止状态。 |
| SIGCONT | 18   | 此作业控制信号送给需要继续运行的处于停止状态的进程。如果接收到此信号的进程处于停止状态，则操作系统的默认动作是使该停止的进程继续运行，否则默认动作是忽略此信号。 |
| SIGSTOP | 19   | 这是一个作业控制信号，它停止一个进程。                       |
| SIGTSTP | 20   | 交互停止信号，当用户在终端上按挂起键(一般采用Ctrl+Z) 时，终端驱动程序产生此信号。 |
| SIGTTIN | 21   | 当一个后台进程组进程试图读其控制终端时，终端驱动程序产生此信号。 |
| SIGTTOU | 22   | 当一个后台进程组进程试图写其控制终端时产生此信号。           |
| SIGIO   | 23   | 此信号指示一个异步IO事件。                                   |










**信号量（Semaphores）**：

- 信号量是一种用于控制多个进程对共享资源的访问的IPC机制。
- 它们可以用来解决竞态条件和进程同步问题。

**互斥锁和条件变量（Mutexes and Condition Variables）**：

- 互斥锁用于确保在多个进程之间对共享资源的互斥访问。
- 条件变量用于实现线程间的协作，以便某个条件得到满足时唤醒等待的线程。

**套接字（Sockets）**：

- 套接字是一种IPC机制，通常用于在不同主机之间进行进程通信，例如网络通信。
- 它们可以用于实现各种通信协议，如TCP和UDP。

**文件锁（File Locking）**：

- 文件锁允许多个进程协调对文件的访问，以防止多个进程同时写入或读取同一文件。

这些IPC机制提供了不同的抽象层次和用途，可以根据应用程序的需求选择合适的机制。IPC在操作系统和分布式系统中起着重要作用，帮助不同进程或线程之间协作，共享资源，以及实现各种应用程序。


原文链接：https://blog.csdn.net/weixin_47077788/article/details/128100959





## 10. 网络编程



1 网络基础概念

1.1 协议
概念:协议实现约定好，大家共同遵守的一组规则，协议可以理解为数据传输和数据解释的规则。
1.2 分层模型
OSI 7层模型：物数网传会表应

    应用层：主要就是应用程序，ftp ssh email http
    表示层：进行编解码和翻译工作
    会话层：建立会话和保持会话
    传输层：定义了端到端的传输，TCP UDP协议
    网络层：定义了点到点的传输，IP协议 --路由器
    数据链路层：数据校验，定义了数据格式 --帧，ARP协议 RARP协议
    物理层：通信介质-双绞线，光纤，调制解调器modemn

TCP四层模型：

    应用层：对应会话层，表示层，应用层
    传输层：对应传输层
    网络层：对应网络层
    网络接口层：对应于物理层和数据链路层

1.3数据通信过程
发送端层层打包，接收方层层解包
在这里插入图片描述
1.4网络应用程序的设计模式
C/S设计模式的优缺点：
优点：可以安装在本地，可以缓存数据，协议的选择灵活
缺点：客户端工具需要由程序员开发，开发周期长工作量大；需要本地安装，对客户的电脑安全有一定影响。
B/S模式：
优点：浏览器不用开发，开发周期短，工作量小
缺点，只能选择http协议，协议选择受限制，不能缓存数据，效率受影响。
1.5 以太网帧格式
以太网帧格式就是包装在网络接口层(数据链路层)的协议
ARP协议：
在这里插入图片描述
IP协议：在网络层
在这里插入图片描述
协议版本: ipv4, ipv6
16位总长度: 最大65536
8位生存时间ttl(网络连接下一跳的次数): 为了防止网络阻塞
32位源ip地址, 共个4字节！我们熟悉的ip都是点分十进制的，4字节, 每字节对应一个点分位，最大为255 ，实际上就是整形数！
32位目的ip地址
8位协议: 用来区分上层协议是TCP, UDP, ICMP还是IGMP协议.
16位首部校验和: 只校验IP首部, 数据的校验由更高层协议负责.

UDP数据报格式：面向无连接的、不安全的、不可靠的数据报传输。
在这里插入图片描述
通过IP地址来确定网络环境中的唯一的一台主机;
主机上使用端口号来区分不同的应用程序.
IP+端口唯一确定唯一一台主机上的一个应用程序.

TCP数据流格式：面向连接的、安全的、可靠的数据流传输协议
在这里插入图片描述
序号: TCP是安全可靠的, 每个数据包都带有序号, 当数据包丢失的时候, 需要重传, 要使用序号进行重传. 控制数据有序, 丢包重传.
确认序号: 使用确认序号可以知道对方是否已经收到了, 通过确认序号可以知道哪个序号的数据需要重传.
16位窗口大小–滑动窗口(主要进行流量控制)
2 SOCKET编程

传统的进程间通信借助内核提供的IPC机制进行，但是只能限于本机通信。若要跨机通信，就必须使用网络通信，这就需要用到内核提供给用户的socket API函数库。
2.1 网络字节序
大端字节序：也叫高端字节序(网络字节序)，是高端地址存放低位数据，低端地址存放高位数据
小端字节序：也叫低端字节序，是低地址存放低位数据，高地址存放高位数据。

大小端进行转换的函数：
#include<arpa/inet.h>
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
h表示主机host，n表示网络nework，s表示short，l表示long

    1
    2
    3
    4
    5
    6
    7

IP地址转化函数：
p->表示点分十进制的字符串形式
to->到
n->表示network网络

int inet_pton(int af,const char *src,woid *dst);
	函数说明:将字符串形式的点分十进制IP转换为大端模式的网络IP
	参数说明:
		af:AF_INET
		src:字符串形式的点分十进制的IP地址
		dst:存放转换后的变量的地址
例如:int_pton(AF_INET,"127.0.0.1",&serv.sin_addr.s_addr);
手工也可以计算: 
	如192.168.232.145, 先将4个正数分别转换为16进制数, 
	192--->0xC0  168--->0xA8   232--->0xE8   145--->0x91
	最后按照大端字节序存放: 0x91E8A8C0, 这个就是4字节的整形值.

const char *inet_ntop(int af,const void *src,char *dst,socklen_t size);
	函数说明:网络IP转换为字符串形式的点分十进制IP
	af:AF_INET
	src:网络的整形的IP地址
	dst:转换后的IP地址，一般为字符串数组
	size:dst的长度
	返回值:成功--返回指向dst的指针
		   失败--返回null，并设置errno
例如: IP地址为010aa8c0, 转换为点分十进制的格式:
	01---->1    0a---->10   a8---->168   c0---->192
	由于从网络中的IP地址是高端模式, 所以转换为点分十进制后应该为: 192.168.10.1

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29

2.2 SOCKET编程主要的API函数

int socket(int domain,int type,int protocol);
	函数描述:创建socket
	参数说明:
		domain:协议版本
		AF_INET IPV4
		AF_INET6 IPV6
		AF_UNIX AF_LOCAL 本低套接字使用
	type:协议类型
		SOCK_STREAM 流式,默认使用的协议是TCP协议
		SOCK_DGRAM  报式,默认使用的是UDP协议
	protocol:
		一般填0，表示使用对应类型的默认协议
	返回值:成功:返回一个大于0的文件描述符
		   失败返回-1，并设置errno
当调用socket函数以后，返回一个文件描述符，内核会提供与该文件描述符相对于的读和写缓冲区，同时还有两个队列，分别是请求队列和已连接队列。

int bind(int sockfd,const struct sockaddr *addr,socklen_t addrlen);
	函数描述:将socket文件描述符和IP,PORT绑定
	参数说明:
		socket:调用socket函数返回的文件描述符
		addr:本地服务器的IP地址和PORT
			struct sockaddr_in serv;
			serv.sin_family = AF_INET;
			serv.sin_port = htons(8888);
			serv.sin_addr.s_addr = htonl(INADDR_ANY); INADDR_ANY表示使用本机任意有效的可以IP
		addrlen:addr变量的占用的内存大小
	返回值:成功:返回0;
		   失败:返回-1，并设置errno

int listen(int sockfd,int backlog);
	函数描述:将套接字由主动态变为被动态
	参数说明:
		sockfd:调用socket函数返回的文件描述符	
		backlog:同时请求连接的最大个数
	返回值:	成功:返回0;
		   失败:返回-1，并设置errno

int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);
	函数说明:获得一个连接，若当前没有连接则会阻塞等待
	函数参数:
		sockfd:调用socket函数返回的文件描述符
		addr:传出参数，保存客户端的地址信息
		addrlen:传入传出参数，addr变量所占内存空间大小
	返回值:
		成功:返回一个新的文件描述符，用于与客户端通信
		失败:返回-1，并设置errno值
accept函数是一个阻塞函数, 若没有新的连接请求, 则一直阻塞.
	从已连接队列中获取一个新的连接, 并获得一个新的文件描述符, 该文件描述符用于和客户端通信.  (内核会负责将请求队列中的连接拿到已连接队列中)

int connect(int sockfd,const struct sockaddr *addr,socklen_t addrlen);
	函数说明:连接服务器
	函数参数:
		sockfd:调用socket函数返回的文件描述符
		addr:服务端的地址信息
		addrlen:addr变量的内存大小
	返回值:
		成功:返回0
		失败:返回-1，并设置errno值

接下来就可以使用write和read函数进行读写操作了
读取数据和发送数据:
	ssize_t read(int fd, void *buf, size_t count);
	ssize_t write(int fd, const void *buf, size_t count);
	ssize_t recv(int sockfd, void *buf, size_t len, int flags);
	ssize_t send(int sockfd, const void *buf, size_t len, int flags);	
	对应recv和send这两个函数flags直接填0就可以了.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67

2.3 使用socket的API函数编写服务端和客户端程序步骤：
在这里插入图片描述
服务端：

    创建socket，返回一个文件描述符lfd --socket() 该文件描述符用于监听客户端连接
    将lfd和IP PORT进行绑定 – bind()
    将lfd由主动变为被动监听 --listen()
    接受一个新的连接，得到一个文件描述符cfd --accept() – 该文件描述符是用于和客户端进行通信的
    while(1){ 接收数据–read或者recv；发送数据–write或者send；}
    关闭文件描述符 --close(lfd) close(cfd)

int main(){
	//创建socket用于和服务端进行通信
	int lfd = socket(AF_INET,SOCK_STREAM,0);
	if(lfd<0){
		perror("socket error");
		return -1;
	}
	
	struct sockaddr_in serv;
	//初始化将前n个字节清零
	bzero(&serv,sizeof(serv));
	serv.sin_family =AF_INET;
	serv.sin_port = htons(8888);
	//标识适用本机任意可用IP
	serv.sin_addr.s_addr = htonl(INADDR_ANY);
	int ret = bind(lfd,(struct sockaddr *)&serv,sizeof(serv));
	if(ret<0){
		perror("bind error");
		return -1;
	}
	//最大是128
	listen(lfd,128);
	struct sockaddr_in client;
	socklen_t len = sizeof(client);
	int cfd = accept(lfd ,(struct sockaddr *)&client,&len);
	
	//获取client端的IP和port端口
	char sIP[16];
	memset(sIP,0x00,sizeof(sIP));
	printf("client-->IP:[%s],PORT:[%d]\n",inet_ntop(AF_INET,&client.sin_addr.s_addr,sIP,sizeof(sIP)),ntohs(client.sin_port));
	printf("lfd==[%d], cfd==[%d] n", lfd,cfd);
	
	int n = 0;
	char buf[1024];
	int i = 0;
	while(1){
		//读数据
		memset(buf,0x00,sizeof(buf));
		n = read(cfd,buf,sizeof(buf))
		if(n<=0){
			printf("read error or client close,n==[%d]\n",n);
			break;
		}
		printf("n==[%d] , buf==[%s] n",n, buf);
		for(i=0;i<=n;i++){
			buf[i] = toupper(buf[i]);
		}
		// 发送数据
		write(cfd,buf,n);
	}
	//关闭监听文件描述符和通信文件描述符
	close(lfd);
	close(cfd);
	return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55

客户端：

    创建socket，返回一个文件描述符cfd – socket() 该文件描述符是用于和服务端通信
    连接服务端 --connect()
    while(1){ 发送数据write或者send；接收数据 read或者recv；}
    close(cfd);

int main(){
//创建socket用于和服务端进行通信
	int cfd = socket(AF_INET,SOCK_STREAM,0);
	if(cfd<0){
		perror("socket error");
		return -1;
	}
	//连接服务器
	struct sockaddr_in serv;
	serv.sin_family = AF_INET;
	serv.sin_port = htons(8888);
	inet_pton(AF_INET,"127.0.0.1",&serv.sin_addr.s_addr);
	printf("[%p]\n",serv.sin_addr.s_addr);
	int ret = connect(cfd,(struct sockaddr *)&serv,sizeof(serv));
	if(ret<0){
		perror("connect error");
		return -1;
	}
	int n = 0;
	char buf[256];
	while(1){
		//读标准输入数据
		memset(buf,0x00,sizeof(buf));
		n = read(STDIN_FILENO,buf,sizeof(buf));
		//发送数据
		write(cfd,buf,n);
		//读服务端发来的数据
		memset(buf,0x00,sizeof(buf));
		n = read(cfd,buf,sizeof(buf));
		if(n<=0){
			printf("read error or server cosed , n==[%d] n",n);
			break;
		}
		printf("n==[%d], buf==[%s]\n",n, buf);
	}
	close(cfd);
	return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38

得到两个文件描述符lfd和cfd，lfd负责监听连接，不参与收发数据；cfd负责和客户端进行通信，有多少个客户端建立了连接，就有多少个cfd，客户端也有一个cfd负责和服务端通信
2.4 三次握手和四次挥手
在客户端与服务端建立连接的时候要经过三次握手的过程，客户端与服务端断开连接的时候要经历四次挥手
在这里插入图片描述
SYN：表示请求，ACK：表示确认，服务端发送的SYN和客户端发送的SYN本身也会占1位
三次握手：
在这里插入图片描述
通信的时候不再需要SYN标识位了，只有在请求连接的时候需要SYN标识位。
在这里插入图片描述
ACK确认包表示给对方发送数据的一个确认，表示你发送的数据都收到了，同时告诉对方下次发送该序号开始的数据，由于每次发送数据都会受到对方发来的确认包，所以可以确认对方是否收到，若没有收到对方法来的确认包，则会重发。
mss最大报文长度，告诉对方最多一次能收多少，不能超过这个长度；
win表示最大缓存空间
FIN是四次挥手结束时的标志。

2.5 滑动窗口
主要作用是进行流量控制的，如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会导致接收缓冲区满而丢失数据，通过滑动窗口来解决这一问题。
在这里插入图片描述
win表示告诉对方握着比缓冲区大小是多少，mss表示告诉对方我这边最多一次可以接收多少数据。
客户端给服务端发送包的时候，不一定是非要等到对方返回响应包，由于客户端知道服务端的窗口大小，所以可以持续多次发送，当发送数据达到对方窗口大小了就不再发送，需要等对方处理之后，才可以继续发送。

MTU: 最大传输单元
MTU:通信术语最大传输单元（Maximum Transmission Unit，MTU）是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为 单位). 最大传输单元这个参数通常与通信接口有关（网络接口卡、串 口等), 这个值如果设置为太大会导致丢包重传的时候重传的数据量较大, 图中的最大值是1500, 其实是一个经验值.

2.6 粘包
多次数据发送，首尾相连，接收端接收的时候不能正确区分第一次发送多少，第二次发送多少。
在这里插入图片描述

粘包问题解决方法：
方案1：包头＋数据；有四位的数据长度+数据：00100123456789
其中0010表示数据长度，0123456789表示10个字节长度的数据；另外发送端和接收端可以协商更为复杂的报文结构，相当于双方约定的一个协议

方案2：添加结尾标记：如：\n、$等

方案3：数据包定长：如发送方和接收方约定，每次只发送128个字节的内容，接收方接收定长128个字节就可以了

2.7高并发服务器：
如何支持多个客户端–支持多并发的服务器：由于accept和read函数都会阻塞，当read的时候，不能调用accept接受新的连接，当accept阻塞等待的时候不能read读函数
方案1：使用多进程，可以让父进程接受新连接，让子进程处理与客户端通信；父进程accept接受新连接，然后fork子进程，让子进程处理通信，子进程处理完成后退出，父进程使用SIGCHLD信号回收子进程
处理流程:

    创建socket，得到一个监听文件描述符lfd --socket()
    将lfd和IP和端口port进行绑定 – bind()
    设置监听 – listen()
    进入while(1){};

多进程版本的网络服务器：父进程接受新的连接，子进程进行通信

    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/types.h>
    #include <unistd.h>
    #include <arpa/inet.h>
    #include <netinet/in.h>
    #include <ctype.h>
    #include "wrap.h"
    int main()
    	//创建 socket
    	int lfd = Socket(AF_INET,SOCK_STREAM,0);
    	//绑定
    	struct sockaddr_in serv;
    	bzero(&serv,sizeof(serv));
    	serv.sin_family = AF_INET;
    	serv.sin_port = htons(8888);
    	serv.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY表示本机任意可用IP
    	//&serv本地服务器的IP和port
    	Bind(lfd,(struct sockaddr *)&serv,sizeof(serv));
    	//设置监听
    	Listen(lfd,128);
    	pid_t pid;
    	int cfd;
    	char sIP[16];//保存IP
    	socklen_t len;
    	struct sockaddr_in client;
    	while(1){
    		//接受新的连接
    		len = sizeof(client);
    		memset(sIP,0x00,sizeof(sIP));
    		//client保存客户端的地址信息，len是传出参数client所占的内存大小，返回cfd用于与客户端进行通信
    		cfd = Accept(lfd,(struct sockaddr *)&client, &len);
    		printf("client:[%s) [%dJ\n", inet_ntop(AF_INET, &client.sin_addr.s.addr, sIp, sizeofsIP)), ntohs(client.sin_port));
    		//接受一个新的连接，创建一个子进程,让子进程完成数据的收发操作
    		pid = fork();
    		if(pid<0){
    			perror("fork error");
    			exit(-1);
    		}else if(pid>0){
    			//关闭通信文件描述符 cfd
    			close(cfd);
    		}else if(pid==0){
    			//关闭监听文件描述符
    			close(lfd);
    			int i=0;
    			int n;
    			char buf[1024];
    			while(1){
    				//读数据
    				n = Read(cfd，buf，sizeof(buf));
    				if(n<=0)
    					printf("read error or client closed, n==[%d]\n"，n);
    					break;
    				}
    				printf("[%d]---->:n==[%d]， buf==[%s]\n",ntohs(client.sin_port),n, buf);
    				//将小写转换为大写
    				for(i=0; i<n; i++){
    					buf[i] = toupper(buf[i]);
    				}
    				//发送数据
    				Write(cfd，buf，n);
    			}
    			//关闭 cfd
    			close(cfd);
    			exit(0);
    		}
    	}
    	//关闭监听文件描述符
    	close(lfd);
    	return 0;
    }

多线程版本的网络服务器：主线程接受新连接，子线程进行通信

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <ctype.h>
#include "wrap.h"
#include <pthread.h>
void *mythread(void *arg){
	int cfd=*(int *)arg;
	char buf[1024];
	int n;
	int i;
	while(1){
		memset(buf,0x00,sizeof( buf));
		n = Read(cfd,buf,sizeof(buf));
		if(n<=0){
			printf("read error or client closed ,n==[%d] n",n);
			break;
		}
		printf("n==[%d] , buf==[%s] n",n,buf);
		for(i=0;i<n;i++){
			buf[i]=toupper(buf[i]);
		}
		write(cfd,buf,n);
	}
	close(cfd);
	pthread_exit(NULL);
}

int main(){
	int lfd = Socket(AF_INET,SOCK_STREAM,0);
	
	struct sockaddr_in serv;
	bzero(&serv,sizeof(serv));
	serv.sin_family = AF_INET;
	serv.sin_port = htons(8888);
	serv.sin_addr.s_addr = htonl(INADDR_ANY);
	Bind(lfd,(struct sockaddr *)&serv,sizeof(serv));
	
	Listen(lfd,128);
	
	struct sockaddr client;
	socklen_t len;
	int cfd;
	pthread_t pthreadIP;
	while(1){
		cfd = Accept(lfd,(struct sockaddr *)&client,&len);
		//创建子线程
		pthread_create(&pthreadIP,NULL,mythread,&cfd);
		//设置线程分离
		pthread_detach(pthreadIP)
	}
	close(lfd);
	return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58

子线程能否关闭lfd？子线程不能关闭监听文件描述符lfd，子线程和主线程共享文件描述符，而不是复制的
主线程能否关闭cfd？主线程不能关闭cfd，主线程和子线程共享一个cfd，而不是复制的，close之后cfd才被关闭
多个子线程共享cfd，会有什么问题发生？只有最后一个连接能够与服务端进行通信，因为前面的cfd都被覆盖掉。

TCP状态转换图：
在这里插入图片描述

2.8 2MSL
2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次挥手完成后发送了第四次挥手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。

为什么需要2MSL？

    让四次挥手的过程更可靠，确保最后一个发送给对方的ACK到达；若对方没有收到ACK应答，对方会再次发送FIN请求关闭，此时在2MSL时间内被动关闭方仍然可以发送ACK给对方。
    为了保证在２MSL时间内，不能启动相同的SOCKET－PAIR。TIME＿WAIT一定是出现在主动关闭的一方，也就是说２MSL是针对主动关闭一方来说的；由于TCP有可能存在丢包重传，丢包重传若发给了已经断开连接之后相同的socket-pair（新的连接，但与原来的socket－pair相同，双方使用的是相同的IP和端口），这样会对之后的连接造成困扰，引起程序异常。

2.9 端口复用
解决端口复用的问题: bind error: Address already in use, 发生这种情况是在服务端主动关闭连接以后, 接着立刻启动就会报这种错误.

setsockopt函数:
int setsockopt(int sockfd,int level,int optname,const void *optval,socklen_t optlen);
	setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(int));
	setsockopt(lfd,SOL_SOCKET,SO_REUSEport,&opt,sizeof(int));
在bind之前,socket之后调用

    1
    2
    3
    4
    5

2.10 半关闭状态:如果一方close,另一方没有close,则认为是半关闭状态,处于半关闭状态的时候,可以接收数据,但不能发送数据,相当于把文件描述符的写缓冲区操作关闭了
长连接和短链接的概念:
长连接:连接建立之后一直不关闭的
短链接:连接收发数据完毕之后就关闭

shutdown和close的区别:
shutdown能够把文件描述符上的读或者写操作关闭, 而close关闭文件描述符只是将连接的引用计数的值减1, 当减到0就真正关闭文件描述符了.
如: 调用dup函数或者dup2函数可以复制一个文件描述符, close其中一个并不影响另一个文件描述符, 而shutdown就不同了, 一旦shutdown了其中一个文件描述符, 对所有的文件描述符都有影响 .

2.11 心跳包
用于检查与对方的网络连接是否正常.一般心跳包用于长连接
通信双方需要协商规则(协议),如4个字节长度+数据部分
发送心跳过程:服务A个B发送心跳数据AAAA,服务B收到AAAA之后,给A回复BBBB,此时A收到BBBB之后,认为连接正常,假如A连续发送了多次之后,仍然没有收到B的回复,则认为是连接异常,异常之后A应该重新建立连接.
如何让心跳数据和正常的业务数据不混淆?双方协商协议:例如:4个字节长度+具体数据,先收4个字节的报头数据,如何计算长度,若长度为4,且数据为AAAA,则认为是心跳数据,B会返回应答数据:0004BBBB.
3 高并发服务器模型

3.1 多路IO计数select,同时监听多个文件描述符,将监控的操作交给内核去处理.
数据类型fd_set:文件描述符集合,本质是位图

int select(int nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,struct timeval *timeout);
函数介绍:委托内核监控该文件描述符对应的读,写或者错误事件的发生
参数说明:
	nfds:最大的文件描述符+1
	readfds:读集合,是一个传入传出参数
		传入:指的是告诉内核那些文件描述符需要监控
		传出:指的是内核告诉应用程序那些文件描述符发生了变化
	writefds:写文件描述符集合(传入传出参数)
	execptfds:异常文件描述符集合(传入传出参数)
	timeout:
		NULL表示永久阻塞,直到有事件发生
		0   表示不阻塞,立刻返回,不管是否有监控的事件发生
		>0 到指定事件或者有事发生了就返回
返回值:成功返回发生变化的文件描述符的个数
	   失败返回-1,并设置errno值

宏:
void FD_CLR(int fd,fd_set *set);
	功能:将fd从set集合中清除
int FD_ISSET(int fd,fd_set *set);
	功能:判断fd是否在集合中
	返回值:如果fd在set集合中,返回1,否则返回0
void FD_SET(int fd,fd_set *set);
	功能:将fd设置到set集合中
void FD_ZERO(fd_set *set);
	功能:初始化set集合

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26

多客户端连接(在不使用多线程和多进程的情况下)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <ctype.h>
#include "wrap.h"

int main(){
	//创建socket
	int lfd = Socket(AF_INET,SOCK_STREAM,0);
	
	//设置端口复用
	int opt = 1;
	setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(int));
	
	//绑定
	struct sockaddr_in serv;
	bzero(&serv,sizeof(serv));
	serv.sin_family = AF_INET;
	serv.sin_port = htons(8888);
	serv.sin_addr.s_addr = htonl(INADDR_ANY);
	Bind(lfd,(struct sockaddr *)&serv,sizeof(serv));
	
	//监听
	Listen(lfd,128);
	
	//定义fd_set类型的变量
	fd_set readfds;
	fd_set tmpfds;//readfds是传入传出参数,所以需要临时变量来存储
	
	//清空readfds和tmpfds集合
	FD_ZERO(&readfds);
	FD_ZER0(&tmpfds);
	
	//将lfd加入到readfds中,委托内核监控
	FD_SET(lfd,&readfds);
	
	int maxfd = fd;
	int nready;
	int cfd;
	int i=0;
	int sockfd;
	char buf[1024];
	int n=0;
	while(1){
		tmpfds = readfds;
		
		//tmpfds是输入输出参数
		//输入:告诉内核要监测那些文件描述符
		//输出:内核告诉应用程序有哪些文件描述符发生了变化
		nready = select(maxfd+1,&tmpfds,NULL,NULL,NULL);//select返回发生变化的文件描述符个数
		if(nready<0){
			//被信号中断
			if(errno == EINTR){
				continue;
			}
			break;
		}
		
		//有客户端连接请求到来
		if(FD_ISSET(lfd,&tmpfds)){
			//接受新的客户端连接请求
			cfd = Accept(lfd,NULL,NULL);
			//将cfd加入到readfds集合中
			FD_SET(cfd,&readfds);
			//修改内核的监控范围
			if(maxfd<cfd){
				maxfd=cfd;
			}
			if(--nready==0){
				continue;
			}
		}
		
		//有数据发来的情况
		for(i=lfd+1;i<=maxfd;i++){
			sockfd = i;
			//判断sockfds文件描述符是否发生变化
			if(FD_ISSET(sockfd,&tmpfds)){
				//读数据
				memset(buf ,0x00,sizeof(buf));
				n=Read(sockfd,buf,sizeof(buf));
				if(n<=0){
					//关闭连接
					close(sockfd);
					//将sockfd从readfds中删除
					FD_CLR(sockfd,&readfds);
				}else{
					printf("n==[%d], buf==[%s] n",n,buf);
					int k= 0;
					for(k = 0;k<n;k++){
						buf[k]=toupper(buf[k]);
					}
					Write(sockfd,buf,n);
				}
				if(--nready==0){
					break;
				}
			}
		}
	}
	close(lfd);
	return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82
    83
    84
    85
    86
    87
    88
    89
    90
    91
    92
    93
    94
    95
    96
    97
    98
    99
    100
    101
    102
    103
    104
    105
    106
    107

3.2 多路IO-poll

int poll(struct pollfd *fds,nfds_t nfds,int timeout);
函数说明:跟select类似,监控多路IO,但poll不能跨平台
参数说明:
	fds:传入传出参数,实际上是一个结构体数组
		fds.fd:要监控的文件描述符
		fds.events:
			POLLIN:读事件
			POLLOUT:写事件
		fds.revents:返回的事件
	nfds:数组实际有效内容的个数
	timeout:超时时间,单位是毫秒
		-1:永久阻塞,知道监控的事件发生
		0:不管是否有事件发生,立刻返回
		>0:知道监控的事件发生或者超时
返回值:
	成功:返回就绪事件的个数
	失败:返回-1,若timeout=0,poll函数不阻塞,且没有事件发生,此时返回-1,并且errno=EAGAIN,这种情况不应视为错误.

struct pollfd{
	int fd;           //监控的文件描述符
	short events;     //要监控的事件 -- 不会被修改
	short revents;    //返回发生变化的事件 -- 由内核返回
};

当poll函数返回的时候, 结构体当中的fd和events没有发生变化, 究竟有没有事件发生由revents来判断, 所以poll是请求和返回分离.
struct pollfd结构体中的fd成员若赋值为-1, 则poll不会监控.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27

int main(){
	//创建socket
	int lfd = Socket(AF_INET,SOCK_STREAM,0);
	
	//允许端口复用
	int opt = 1;
	setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(int));
	
	//绑定bind
	struct sockaddr_in serv;
	serv.sin_family = AF_INET;
	serv.sin_port = htons(8888);
	serv.sin_addr.s_addr = htonl(INADDR_ANY);
	Bind(lfd,(struct sockaddr *)&serv,sizeof(serv));
	
	//监听listen
	Listen(lfd,128);
	
	struct pollfd client[1024];
	
	//监听文件描述符委托给内核监控 监控读事件
	client[0].fd=lfd;
	client[0].events=POLLIN;
	
	int i=l;
	int nready=0;
	int maxi=0; //内核监控范围
	
	for(i=1;i<1024;i++){
		client[i].fd=-1;
	}
	int k=0;
	int n=0;
	int cfd=0;
	int sockfd=0;
	char buf[1024];
	while(1){
		nready = poll(client,maxi+1,-1);
		if(nready<0){
			if(errno==EINTR){
				continue;
			}
			break;
		}
	
		//有客户端连接请求
		if(client[0].revents==POLLIN){
			cfd = Accept(lfd,NULL,NULL);
			//寻找client数组中的可用位置
			for(i=1;i<1024;i++){
				if(client[i].fd==-1){
					client[i].fd = cfd;
					client[i].events = POLLIN;
					break;
				}
			}
			//没有可用位置,则关闭连接
			if(i==1024){
				Close(cfd);
				continue;
			}
			if(maxi<i){
				maxi = i;
			}
			if(--nready==0){
				continue;
			}
		}
		//有数据到来的情况
		for(i=1;i<=maxi;i++){
			sockfd = client[i].fd;
			memset(buf,0x00,sizeof(buf));
			//若fd为-1,表示连接已经关闭或者没有连接
			if(client[i].fd == -1){
				continue;
			}
			if(client[i].revents==POLLIN){
				n=Read(sockfd,buf,sizeof(buf));
				if(n<=0){
					close(sockfd);
					client[i].fd = -1; //fd=-1,表示不再让内核监控
				}else{
					printf("n==[%d],buf==[%s] n",n, buf);
					write(sockfd,buf,n);
				}
				if(--nready==0){
					break;
				}
			}
		}
	}
	close(lfd);
	return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82
    83
    84
    85
    86
    87
    88
    89
    90
    91
    92
    93
    94
    95

3.3 多路IO-epoll
将检测文件描述符的变化委托给内核去处理,然后内核发生变化的文件描述符对应的事件返回给应用程序.

int epoll_create(int size);
函数说明:创建一个树根
参数:
	size:最大节点数
返回值:
	成功:返回一个大于0的文件描述符,代表整个树的树根
	失败:返回-1,并设置errno值

int epoll_ctl(int epfd,int op,int fd,struct epoll_event *event);
函数说明:将要监听的节点在epoll树上添加,删除和修改
参数:
	epfd:epoll树根
	op:
		EPOLL_CTL_ADD:添加事件节点到树上
		EOPLL_CTL_DEL:从树上删除事件节点
		EOPLL_CTL_MOD:修改树上对应的事件节点
	fd:事件节点对应的文件描述符
	event:要操作的事件节点
	typedef union epoll_data {
               void        *ptr;
               int          fd;
               uint32_t     u32;
               uint64_t     u64;
           } epoll_data_t;
	struct epoll_event {
    	uint32_t     events;      /* Epoll events */
        epoll_data_t data;        /* User data variable */
     };
	event.events常用的有:
	EPOLLIN: 读事件
	EPOLLOUT: 写事件
	EPOLLERR: 错误事件
    EPOLLET: 边缘触发模式
	event.fd: 要监控的事件对应的文件描述符

int epoll_wait(int pefd,struct epoll_event *events,int maxevents,int timeout);
函数说明:等待内核返回事件发生
参数说明:
	epfd:epoll树根
	events:传出参数,时间结构体数组
	maxevents:数组大小
	timeout:
		-1:表示永久阻塞
		0:立即返回
		>0:表示超时等待事件
返回值:
	成功:返回发生事件的个数
	失败:若timeout=0,没有事件发生,则返回;返回-1,设置errno值

epoll_wait的events是一个传出参数, 调用epoll_ctl传递给内核什么值, 当epoll_wait返回的时候, 内核就传回什么值,不会对struct event的结构体变量的值做任何修改.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50

测试代码:

int main(){
	int lfd = Socket(AF_INET,SOCK_STREAM,0);
	
	int opt = 1;
	setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(int));
	
	struct sockaddr_in serv;
	bzero(&serv,sizeof(serv));
	serv.sin_family=AF_INET;
	serv.sin_port=htons(8888);
	serv.sin_addr.s_addr=htonl(INADDR_ANY);
	Bind(lfd,(struct sockaddr *)&serv,sizeof(serv));
	
	Listen(lfd,128);
	
	//创建epoll树
	int epfd = epoll_create(1024);
	
	//将lfd上树
	struct epoll_event ev; 
	ev.events = EPOLLIN;
	ev.data.fd=lfd;
	//要监听的节点添加到epoll树上
	epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&ev);
	
	struct epoll_event events[1024]; //定义一个传出数组
	int nready=0;
	int i=0;
	int n=0;
	char buf[1024];
	int cfd=0;
	int sockfd=0;
	while(1){
		//阻塞,内核等待事件发生,保存修改或者发生事件的文件描述符
		nready = epoll_wait(epfd,events,1024,-1);
		if(nready<0){
			if(errno==EINTR){
				continue;
			}
			break;
		}
		//有事件发生时,有客户端连接请求
		for(i=0;i<nready;i++){
			sockfd = events[i].data.fd;
			//判断是否是lfd,是则accept
			if(sockfd==lfd){
				cfd=Accept(lfd,NULL,NULL);
				ev.data.fd=cfd;
				ev.events = EPOLLIN;
				//cfd上树
				epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&ev);
				continue;
			}
			//有客户端发送数据过来
			memset(buf,0x00,sizeof(buf));
			n = Read(sockfd,buf,sizeof(buf));
			if(n<=0){
				//读不到数据,关闭通信文件描述符,从树上删除
				close(sockfd);
				epoll_ctl(epfd,EPOLL_CTL_DEL,sockfd,NULL);
				perror("read error or client close");
				continue;
			}
			printf("n==[%d], buf==[%s] n",n,buf);
			Write(sockfd,buf,n);
		}
	}
	close(epfd);
	close(lfd);
	return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71

3.4 epoll的两种工作模式
epoll的两种模式ET和LT模式
水平触发LT：高电平代表１，只要缓冲区中有数据，就一直通知,epoll默认情况下是LT模式,在这种模式下若读数据一次性没读完,缓冲区中还有可读数据,则epoll_wait还会再通知.
边缘触发ET：电平有变化就代表１，缓冲区中有数据指挥通知一次，之后再有数据才会通知（若是读数据的时候没有读完，则剩余的数据不会再通知，直到有新的数据到来）epoll设置为ET模式,若读数据的时候一次性没有读完,则epoll_wait不再通知,知道下次有新的数据发来.

在ET模式下,如何在epoll_wait返回一次的情况下读完数据:循环读数据,直到读完数据,但是读完数据之后会阻塞
若一次性读完还需设置什么?将通信文件描述符设置为非阻塞(fcntl函数)

3.5 epoll反应堆
反应堆:一个小事件触发一系列反应
epoll反应堆思想:c++封装思想(把数据和操作封装到一起),将描述符,事件,对应的处理方法封装在一起,当描述符对应的事件发生了,自动调用处理方法.
epoll反应堆的核心思想是:在调用epoll_ctl函数的时候,将events上树的时候,利用epoll_data_t的ptr成员,将一个文件描述符,事件和回调函数封装成一个结构体,然后让ptr指向这个结构体,然后调用epoll_wait函数返回的时候,可用得到具体的events,然后获得events结构体中的events.data.ptr指针,ptr指针指向的结构体中有回调函数,最终可以调用这个回调函数.
4 线程池

线程池:若干个线程组合到一起,形成线程池.
线程池和任务池:任务池相当于共享资源,所以需要使用互斥锁,当任务池中没有任务的时候需要让线程池阻塞,所以需要使用条件变量.
在这里插入图片描述
线程池流程:

    初始化操作:线程数量,任务总数,malloc内存,互斥锁和条件变量初始化,创建指定数量的子线程
    主线程:负责往线程池中添加任务.先加锁,然后判断任务池中是否已满,若满,则调用pthread_cond_wait阻塞等待;若未满,则往任务池中添加任务,添加完成之后调用pthread_cond_signal通知子线程取任务;最后解锁
    子线程:负责从任务池中取任务并处理任务;先加锁,然后判断任务池中是否有任务;若任务池中没有任务,则调用pthread_cond_wait函数等待主线程添加任务;若任务池中有任务,则取任务并处理任务;处理完成之后,通知pthread_cond_signal主线程继续添加任务;若shutdown为1,先解锁,然后自行退出pthread_exit,最后释放锁.

#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include "threadpool.h"

#define DEFAULT_TIME 10                 /*10s检测一次*/
#define MIN_WAIT_TASK_NUM 10            /*如果queue_size > MIN_WAIT_TASK_NUM 添加新的线程到线程池*/ 
#define DEFAULT_THREAD_VARY 10          /*每次创建和销毁线程的个数*/
#define true 1
#define false 0

typedef struct 
{
    void *(*function)(void *);          /* 函数指针，回调函数 */
    void *arg;                          /* 上面函数的参数 */
} threadpool_task_t;                    /* 各子线程任务结构体 */

/* 描述线程池相关信息 */
struct threadpool_t 
{
    pthread_mutex_t lock;               /* 用于锁住本结构体 */    
    pthread_mutex_t thread_counter;     /* 记录忙状态线程个数de琐 -- busy_thr_num */

    pthread_cond_t queue_not_full;      /* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */
    pthread_cond_t queue_not_empty;     /* 任务队列里不为空时，通知等待任务的线程 */
    
    pthread_t *threads;                 /* 存放线程池中每个线程的tid。数组 */
    pthread_t adjust_tid;               /* 存管理线程tid */
    threadpool_task_t *task_queue;      /* 任务队列(数组首地址) */
    
    int min_thr_num;                    /* 线程池最小线程数 */
    int max_thr_num;                    /* 线程池最大线程数 */
    int live_thr_num;                   /* 当前存活线程个数 */
    int busy_thr_num;                   /* 忙状态线程个数 */
    int wait_exit_thr_num;              /* 要销毁的线程个数 */
    
    int queue_front;                    /* task_queue队头下标 */
    int queue_rear;                     /* task_queue队尾下标 */
    int queue_size;                     /* task_queue队中实际任务数 */
    int queue_max_size;                 /* task_queue队列可容纳任务数上限 */
    
    int shutdown;          /* 标志位，线程池使用状态，true或false */
};

void *threadpool_thread(void *threadpool);

void *adjust_thread(void *threadpool);

int is_thread_alive(pthread_t tid);
int threadpool_free(threadpool_t *pool);

//threadpool_create(3,100,100);  
threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size)
{
    int i;
    threadpool_t *pool = NULL;
    do 
	{
        if((pool = (threadpool_t *)malloc(sizeof(threadpool_t))) == NULL) 
		{  
            printf("malloc threadpool fail");
            break;                      /*跳出do while*/
        }

        pool->min_thr_num = min_thr_num;
        pool->max_thr_num = max_thr_num;
        pool->busy_thr_num = 0;
        pool->live_thr_num = min_thr_num;   /* 活着的线程数 初值=最小线程数 */
        pool->wait_exit_thr_num = 0;
        pool->queue_size = 0;                 /* 有0个产品 */
        pool->queue_max_size = queue_max_size;
        pool->queue_front = 0;
        pool->queue_rear = 0;
        pool->shutdown = false;       /* 不关闭线程池 */
    
        /* 根据最大线程上限数， 给工作线程数组开辟空间, 并清零 */
        pool->threads = (pthread_t *)malloc(sizeof(pthread_t)*max_thr_num); 
        if (pool->threads == NULL) 
    	{
            printf("malloc threads fail");
            break;
        }
        memset(pool->threads, 0, sizeof(pthread_t)*max_thr_num);
    
        /* 队列开辟空间 */
        pool->task_queue = (threadpool_task_t *)malloc(sizeof(threadpool_task_t)*queue_max_size);
        if (pool->task_queue == NULL) 
    	{
            printf("malloc task_queue fail\n");
            break;
        }
    
        /* 初始化互斥琐、条件变量 */
        if (pthread_mutex_init(&(pool->lock), NULL) != 0
                || pthread_mutex_init(&(pool->thread_counter), NULL) != 0
                || pthread_cond_init(&(pool->queue_not_empty), NULL) != 0
                || pthread_cond_init(&(pool->queue_not_full), NULL) != 0)
        {
            printf("init the lock or cond fail\n");
            break;
        }
    
    	//启动工作线程
    	pthread_attr_t attr;
    	pthread_attr_init(&attr);
    	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
        for (i = 0; i < min_thr_num; i++) 
    	{
            pthread_create(&(pool->threads[i]), &attr, threadpool_thread, (void *)pool);/*pool指向当前线程池*/
            printf("start thread 0x%x...\n", (unsigned int)pool->threads[i]);
        }
    
    	//创建管理者线程
        pthread_create(&(pool->adjust_tid), &attr, adjust_thread, (void *)pool);
    
        return pool;
    
    } while (0);
    
    /* 前面代码调用失败时,释放poll存储空间 */
    threadpool_free(pool);
    
    return NULL;
}

/* 向线程池中 添加一个任务 */
//threadpool_add(thp, process, (void*)&num[i]);   /* 向线程池中添加任务 process: 小写---->大写*/

int threadpool_add(threadpool_t *pool, void*(*function)(void *arg), void *arg)
{
    pthread_mutex_lock(&(pool->lock));

    /* ==为真，队列已经满， 调wait阻塞 */
    while ((pool->queue_size == pool->queue_max_size) && (!pool->shutdown)) 
    {
        pthread_cond_wait(&(pool->queue_not_full), &(pool->lock));
    }
    
    if (pool->shutdown) 
    {
        pthread_cond_broadcast(&(pool->queue_not_empty));
        pthread_mutex_unlock(&(pool->lock));
        return 0;
    }
    
    /* 清空 工作线程 调用的回调函数 的参数arg */
    if (pool->task_queue[pool->queue_rear].arg != NULL) 
    {
        pool->task_queue[pool->queue_rear].arg = NULL;
    }
    
    /*添加任务到任务队列里*/
    pool->task_queue[pool->queue_rear].function = function;
    pool->task_queue[pool->queue_rear].arg = arg;
    pool->queue_rear = (pool->queue_rear + 1) % pool->queue_max_size;       /* 队尾指针移动, 模拟环形 */
    pool->queue_size++;
    
    /*添加完任务后，队列不为空，唤醒线程池中 等待处理任务的线程*/
    pthread_cond_signal(&(pool->queue_not_empty));
    pthread_mutex_unlock(&(pool->lock));
    
    return 0;
}

/* 线程池中各个工作线程 */
void *threadpool_thread(void *threadpool)
{
    threadpool_t *pool = (threadpool_t *)threadpool;
    threadpool_task_t task;

    while (true) 
    {
        /* Lock must be taken to wait on conditional variable */
        /*刚创建出线程，等待任务队列里有任务，否则阻塞等待任务队列里有任务后再唤醒接收任务*/
        pthread_mutex_lock(&(pool->lock));
    
        /*queue_size == 0 说明没有任务，调 wait 阻塞在条件变量上, 若有任务，跳过该while*/
        while ((pool->queue_size == 0) && (!pool->shutdown)) 
    	{  
            printf("thread 0x%x is waiting\n", (unsigned int)pthread_self());
            pthread_cond_wait(&(pool->queue_not_empty), &(pool->lock));//暂停到这
    
            /*清除指定数目的空闲线程，如果要结束的线程个数大于0，结束线程*/
            if (pool->wait_exit_thr_num > 0) 
    		{
                pool->wait_exit_thr_num--;
    
                /*如果线程池里线程个数大于最小值时可以结束当前线程*/
                if (pool->live_thr_num > pool->min_thr_num) 
    			{
                    printf("thread 0x%x is exiting\n", (unsigned int)pthread_self());
                    pool->live_thr_num--;
                    pthread_mutex_unlock(&(pool->lock));
    				//pthread_detach(pthread_self());
                    pthread_exit(NULL);
                }
            }
        }
    
        /*如果指定了true，要关闭线程池里的每个线程，自行退出处理---销毁线程池*/
        if (pool->shutdown) 
    	{
            pthread_mutex_unlock(&(pool->lock));
            printf("thread 0x%x is exiting\n", (unsigned int)pthread_self());
            //pthread_detach(pthread_self());
            pthread_exit(NULL);     /* 线程自行结束 */
        }
    
        /*从任务队列里获取任务, 是一个出队操作*/
        task.function = pool->task_queue[pool->queue_front].function;
        task.arg = pool->task_queue[pool->queue_front].arg;
    
        pool->queue_front = (pool->queue_front + 1) % pool->queue_max_size;       /* 出队，模拟环形队列 */
        pool->queue_size--;
    
        /*通知可以有新的任务添加进来*/
        pthread_cond_broadcast(&(pool->queue_not_full));
    
        /*任务取出后，立即将 线程池琐 释放*/
        pthread_mutex_unlock(&(pool->lock));
    
        /*执行任务*/ 
        printf("thread 0x%x start working\n", (unsigned int)pthread_self());
        pthread_mutex_lock(&(pool->thread_counter));                            /*忙状态线程数变量琐*/
        pool->busy_thr_num++;                                                   /*忙状态线程数+1*/
        pthread_mutex_unlock(&(pool->thread_counter));
    
        (*(task.function))(task.arg);                                           /*执行回调函数任务*/
        //task.function(task.arg);                                              /*执行回调函数任务*/
    
        /*任务结束处理*/ 
        printf("thread 0x%x end working\n", (unsigned int)pthread_self());
        pthread_mutex_lock(&(pool->thread_counter));
        pool->busy_thr_num--;         /*处理掉一个任务，忙状态数线程数-1*/
        pthread_mutex_unlock(&(pool->thread_counter));
    }
    
    pthread_exit(NULL);
}

/* 管理线程 */
void *adjust_thread(void *threadpool)
{
    int i;
    threadpool_t *pool = (threadpool_t *)threadpool;
    while (!pool->shutdown) 
	{

        sleep(DEFAULT_TIME);             /*定时 对线程池管理*/
    
        pthread_mutex_lock(&(pool->lock));
        int queue_size = pool->queue_size;           /* 关注 任务数 */
        int live_thr_num = pool->live_thr_num;      /* 存活 线程数 */
        pthread_mutex_unlock(&(pool->lock));
    
        pthread_mutex_lock(&(pool->thread_counter));
        int busy_thr_num = pool->busy_thr_num;        /* 忙着的线程数 */
        pthread_mutex_unlock(&(pool->thread_counter));
    
        /* 创建新线程 算法： 任务数大于最小线程池个数, 且存活的线程数少于最大线程个数时 如：30>=10 && 40<100*/
        if (queue_size >= MIN_WAIT_TASK_NUM && live_thr_num < pool->max_thr_num) 
    	{
            pthread_mutex_lock(&(pool->lock));  
            int add = 0;
    
            /*一次增加 DEFAULT_THREAD 个线程*/
            for (i = 0; i < pool->max_thr_num && add < DEFAULT_THREAD_VARY
                    && pool->live_thr_num < pool->max_thr_num; i++) 
    		{
                if (pool->threads[i] == 0 || !is_thread_alive(pool->threads[i])) 
    			{
                    pthread_create(&(pool->threads[i]), NULL, threadpool_thread, (void *)pool);
                    add++;
                    pool->live_thr_num++;
                }
            }
    
            pthread_mutex_unlock(&(pool->lock));
        }
    
        /* 销毁多余的空闲线程 算法：忙线程X2 小于 存活的线程数 且 存活的线程数 大于 最小线程数时*/
        if ((busy_thr_num * 2) < live_thr_num  &&  live_thr_num > pool->min_thr_num) 
    	{
            /* 一次销毁DEFAULT_THREAD个线程, 隨機10個即可 */
            pthread_mutex_lock(&(pool->lock));
            pool->wait_exit_thr_num = DEFAULT_THREAD_VARY;      /* 要销毁的线程数 设置为10 */
            pthread_mutex_unlock(&(pool->lock));
    
            for (i = 0; i < DEFAULT_THREAD_VARY; i++) 
    		{
                /* 通知处在空闲状态的线程, 他们会自行终止*/
                pthread_cond_signal(&(pool->queue_not_empty));
            }
        }
    }
    
    return NULL;
}

int threadpool_destroy(threadpool_t *pool)
{
    int i;
    if (pool == NULL) 
	{
        return -1;
    }
    pool->shutdown = true;

    /*先销毁管理线程*/
    //pthread_join(pool->adjust_tid, NULL);
    
    for (i = 0; i < pool->live_thr_num; i++) 
    {
        /*通知所有的空闲线程*/
        pthread_cond_broadcast(&(pool->queue_not_empty));
    }
    
    /*for (i = 0; i < pool->live_thr_num; i++) 
    {
        pthread_join(pool->threads[i], NULL);
    }*/
    
    threadpool_free(pool);
    
    return 0;
}

int threadpool_free(threadpool_t *pool)
{
    if (pool == NULL) 
	{
        return -1;
    }

    if (pool->task_queue) 
    {
        free(pool->task_queue);
    }
    
    if (pool->threads) 
    {
        free(pool->threads);
        pthread_mutex_lock(&(pool->lock));
        pthread_mutex_destroy(&(pool->lock));
        pthread_mutex_lock(&(pool->thread_counter));
        pthread_mutex_destroy(&(pool->thread_counter));
        pthread_cond_destroy(&(pool->queue_not_empty));
        pthread_cond_destroy(&(pool->queue_not_full));
    }
    
    free(pool);
    pool = NULL;
    
    return 0;
}

int threadpool_all_threadnum(threadpool_t *pool)
{
    int all_threadnum = -1;

    pthread_mutex_lock(&(pool->lock));
    all_threadnum = pool->live_thr_num;
    pthread_mutex_unlock(&(pool->lock));
    
    return all_threadnum;
}

int threadpool_busy_threadnum(threadpool_t *pool)
{
    int busy_threadnum = -1;

    pthread_mutex_lock(&(pool->thread_counter));
    busy_threadnum = pool->busy_thr_num;
    pthread_mutex_unlock(&(pool->thread_counter));
    
    return busy_threadnum;
}

int is_thread_alive(pthread_t tid)
{
    int kill_rc = pthread_kill(tid, 0);     //发0号信号，测试线程是否存活
    if (kill_rc == ESRCH) 
	{
        return false;
    }

    return true;
}

/*测试*/ 
#if 1
/* 线程池中的线程，模拟处理业务 */
void *process(void *arg)
{
    printf("thread 0x%x working on task %d\n ",(unsigned int)pthread_self(),*(int *)arg);
    sleep(1);
    printf("task %d is end\n", *(int *)arg);

    return NULL;
}

int main(void)
{
    /*threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size);*/
    threadpool_t *thp = threadpool_create(3,100,100);   /*创建线程池，池里最小3个线程，最大100，队列最大100*/
    printf("pool inited");

    //int *num = (int *)malloc(sizeof(int)*20);
    int num[20], i;
    for (i = 0; i < 20; i++) 
    {
        num[i]=i;
        printf("add task %d\n",i);
        threadpool_add(thp, process, (void*)&num[i]);   /* 向线程池中添加任务 */
    }
    
    sleep(10);                /* 等子线程完成任务 */
    threadpool_destroy(thp);
    
    return 0;
}
#endif

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82
    83
    84
    85
    86
    87
    88
    89
    90
    91
    92
    93
    94
    95
    96
    97
    98
    99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153
    154
    155
    156
    157
    158
    159
    160
    161
    162
    163
    164
    165
    166
    167
    168
    169
    170
    171
    172
    173
    174
    175
    176
    177
    178
    179
    180
    181
    182
    183
    184
    185
    186
    187
    188
    189
    190
    191
    192
    193
    194
    195
    196
    197
    198
    199
    200
    201
    202
    203
    204
    205
    206
    207
    208
    209
    210
    211
    212
    213
    214
    215
    216
    217
    218
    219
    220
    221
    222
    223
    224
    225
    226
    227
    228
    229
    230
    231
    232
    233
    234
    235
    236
    237
    238
    239
    240
    241
    242
    243
    244
    245
    246
    247
    248
    249
    250
    251
    252
    253
    254
    255
    256
    257
    258
    259
    260
    261
    262
    263
    264
    265
    266
    267
    268
    269
    270
    271
    272
    273
    274
    275
    276
    277
    278
    279
    280
    281
    282
    283
    284
    285
    286
    287
    288
    289
    290
    291
    292
    293
    294
    295
    296
    297
    298
    299
    300
    301
    302
    303
    304
    305
    306
    307
    308
    309
    310
    311
    312
    313
    314
    315
    316
    317
    318
    319
    320
    321
    322
    323
    324
    325
    326
    327
    328
    329
    330
    331
    332
    333
    334
    335
    336
    337
    338
    339
    340
    341
    342
    343
    344
    345
    346
    347
    348
    349
    350
    351
    352
    353
    354
    355
    356
    357
    358
    359
    360
    361
    362
    363
    364
    365
    366
    367
    368
    369
    370
    371
    372
    373
    374
    375
    376
    377
    378
    379
    380
    381
    382
    383
    384
    385
    386
    387
    388
    389
    390
    391
    392
    393
    394
    395
    396
    397
    398
    399
    400
    401
    402
    403
    404
    405
    406
    407
    408
    409
    410
    411
    412
    413
    414
    415
    416
    417
    418
    419
    420
    421
    422
    423
    424
    425
    426
    427

5 UDP通信

TCP：传输控制协议，面向连接的，稳定的，可靠的，安全的数据流传递
稳定和可靠：丢包重传
数据有序：序号和确认序号（SYN和ACK）
流量控制：滑动窗口
UDP：用户数据报协议，面向无连接的，不稳定，不可靠，不安全的数据报传递，更像是收发短信，UDP传输不需要建立连接，传输效率更高，在稳定的局域网环境内相对可靠

UDP通信相关函数：

size_t recvfrom(int sockfd,void *buf,size_t len,int flags,struct sockaddr *src_addr,socklen_t *addrlen);
函数说明:接收消息
参数说明:
	sockfd:套接字(文件描述符)
	buf:要接受的缓冲区
	len:缓冲区的长度
	flags:标志位,一般填0
	src_addr:原地址 传出参数
	addrlen:发送方地址长度
返回值: 成功返回读到的字节数
		失败:返回-1,设置errno
调用该函数相当于TCP通信的recv+accept函数

size_t sendto(int sockfd,const void *buf,size_t len,int flags,const struct sockaddr *dest_addr,socklen_t addrlen);
函数说明:发送数据
参数说明:
	sockfd:套接字
	dest_addr:目的地址
	addrlen:目的地址长度
返回值:成功返回写入的字节数
	   失败:返回-1,设置errno

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

UDP通信服务端流程:

    创建socket,cfd=socket(AF_INET,SOCK_DGREAM,0);
    绑定bind
    while(1){读取数据recvfrom;发送数据sendto;}
    关闭文件

#include<stdio.h>
#include<stdlib.h>
#include <string.h>
#include<sys/types.h>
#include<unistd.h>
#include<arpa/inet.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <netinet/udp.h>
#include <ctype.h>
int main(){
	int cfd = socket(AF_INET,SOCK_DGRAM,0);
	if(cfd<0){
		perror("socket error");
		return -1;
	}
	struct sockaddr in serv;
	struct sockaddr in client;
	bzero(&serv,sizeof(serv));
	serv.sin_family=AF_INET;
	serv.sin_port = htons(8888);
	serv.sin_addr.s_addr = htonl(INADDR_ANY);

	bind(cfd,(struct sockaddr *)&serv,sizeof(serv));
	
	int n;
	char buf[1024];
	socklen_t len;
	int i=0;
	while(1){
		memset(buf,0x00,sizeof(buf));
		len = sizeof(client);
		//读取数据
		n=recvfrom(cfd,buf,sizeof(buf),0,(struct sockaddr *)&client,&len);
		for(i=0;i<n;i++){
			buf[i] = toupper(buf[i]);
		}
		printf("[%d]:n==[%d],buf==[%s]\n",ntohs(client.sin_port),n,buf);
		//发送数据
		sendto(cfd,buf,n,0,(struct sockaddr *)&client,len);
	}
	//关闭套接字
	close(cfd);
	return 0;
}

//可连接多个客户端,当服务端关闭客户端依然建立连接,但是不能发送数据

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47

UDP客户端流程:

    创建套接字:socket,cfd=socket(AF_INET,SOCK_DGREAM,0);
    while(1){收消息recvfrom;发消息sendto;}
    关闭套接字 close

int main(){
	//创建socket
	int cfd = socket(AF_INET,SOCK_DGRAM,0);
	if(cfd<0){
		perror("socket error");
		return -1;
	}
	struct sockaddr_in serv;
	serv.sin_family = AF_INET;
	serv.sin_port = htons(8888);
	inet_pton(AF_INET,"127.0.0.1",&serv.sin_addr.s_addr);
	
	int n;
	char buf[1024];
	socklen_t len;
	int i=0;
	while(1){
		//读标准输入数据
		memset(buf,0x00,sizeof(buf));
		n= read(STDIN_FILENO,buf,sizeof(buf));
		//发送数据
		sendto(cfd,buf,n,0,(struct sockaddr *)&serv,sizeof(serv));
		//读取数据
		memset(buf,0x00,sizeof(buf));
		n=recvfrom(cfd,buf,sizeof(buf),0,NULL,NULL);
		printf("n==[%d], buf==[%s] n",n,buf);
	}
	close(cfd);
	return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30

使用nc命令进行测试: nc -u 127.1 8888

本地socket通信:

man 7 unix

int socket(int domain,int type,int protocol);
函数说明:创建本地域socket
函数参数:
	domain:AF_UNIX or AF_LOCAL
	type:SOCK_STREAM 或者 SOCK_DGRAM
	PROTOCOL:0表示使用默认协议
函数返回值: 成功:返回文件描述符
		   失败:返回-1,并设置errno值
		 
int bind(int sockfd,const struct sockaddr *addr,socklen_t addrlen);
函数说明:绑定套接字
函数参数:
	socket:由socket函数返回的文件描述符
	addr:本地地址
	addlen:本地地址长度
函数返回值:成功:返回文件描述符
			失败:返回-1,并设置errno值
bind函数会自动创建socket文件,若在调用bind函数之前,socket文件已经存在,则调用bind会报错,可用使用unlink函数在bind之前先删除文件

本地套接字服务器的流程：
	可以使用TCP的方式, 必须按照tcp的流程 
	也可以使用UDP的方式, 必须按照udp的流程 

tcp的本地套接字服务器流程：
	创建套接字  socket(AF_UNIX,SOCK_STREAM,0)
	绑定 struct sockaddr_un &强转
	侦听 listen 
	获得新连接 accept 
	循环通信 read-write 
	关闭文件描述符 close

tcp本地套接字客户端流程：
	调用socket创建套接字
	调用bind函数将socket文件描述和socket文件进行绑定.
	不是必须的, 若无显示绑定会进行隐式绑定，但服务器不知道谁连接了.
	调用connect函数连接服务端
	循环通信read-write
	关闭文件描述符 close

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41

服务器端代码:

int main()
{
	//创建socket
	int lfd = socket(AF_UNIX, SOCK_STREAM, 0);
	if(lfd<0)
	{
		perror("socket error");
		return -1;
	}

	//删除socket文件,避免bind失败
	unlink("./server.sock");
	
	//绑定bind
	struct sockaddr_un serv;
	bzero(&serv, sizeof(serv));
	serv.sun_family = AF_UNIX;
	strcpy(serv.sun_path, "./server.sock"); 
	int ret = bind(lfd, (struct sockaddr *)&serv, sizeof(serv));
	if(ret<0)
	{
		perror("bind error");
		return -1;
	}
	
	//监听listen
	listen(lfd, 10);
	
	//接收新的连接-accept
	struct sockaddr_un client;
	bzero(&client, sizeof(client));
	int len = sizeof(client);
	int cfd = accept(lfd, (struct sockaddr *)&client, &len);
	if(cfd<0)
	{
		perror("accept error");	
		return -1;
	}
	printf("client->[%s]\n", client.sun_path);
	
	int n;
	char buf[1024];
	
	while(1)
	{
		//读数据
		memset(buf, 0x00, sizeof(buf));		
		n = read(cfd, buf, sizeof(buf));
		if(n<=0)
		{
			printf("read error or client close, n==[%d]\n", n);
			break;
		}
		printf("n==[%d], buf==[%s]\n", n, buf);
	
		//发送数据
		write(cfd, buf, n);
	}
	close(lfd);
	return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62

客户端代码:

int main()
{
	//创建socket
	int cfd = socket(AF_UNIX, SOCK_STREAM, 0);
	if(cfd<0)
	{
		perror("socket error");
		return -1;
	}

	//删除socket文件,避免bind失败
	unlink("./client.sock");
	
	//绑定bind
	struct sockaddr_un client;
	bzero(&client, sizeof(client));
	client.sun_family = AF_UNIX;
	strcpy(client.sun_path, "./client.sock"); 
	int ret = bind(cfd, (struct sockaddr *)&client, sizeof(client));
	if(ret<0)
	{
		perror("bind error");
		return -1;
	}
	
	struct sockaddr_un serv;
	bzero(&serv, sizeof(serv));
	serv.sun_family = AF_UNIX;
	strcpy(serv.sun_path, "./server.sock");
	ret = connect(cfd, (struct sockaddr *)&serv, sizeof(serv));
	if(ret<0)
	{
		perror("connect error");	
		return -1;
	}
	
	int n;
	char buf[1024];
	
	while(1)
	{
		memset(buf, 0x00, sizeof(buf));
		n = read(STDIN_FILENO, buf, sizeof(buf));
	
		//发送数据
		write(cfd, buf, n);
	
		//读数据
		memset(buf, 0x00, sizeof(buf));		
		n = read(cfd, buf, sizeof(buf));
		if(n<=0)
		{
			printf("read error or client close, n==[%d]\n", n);
			break;
		}
		printf("n==[%d], buf==[%s]\n", n, buf);
	}
	
	close(cfd);
	return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61

TCP和UDP的区别:TCP是建立连接的一对一的服务,类似于打电话,必须对方接听才能进行通话,UDP是无连接的,类似于发短信,无论对方什么状态都可以进行通信.
6 libevent的使用

6.1 libevent的地基event_base:使用libevent函数之前需要分配一个或者多个event_base结构体,每个event_base结构体持有一个事件集合,可以检测以确定哪个事件是激活的,event_base结构相当于epoll红黑树的树根节点,每个event_base都有一种用于检测某种事件已经就绪的方法.

struct event_base *event_base_new(void);
函数说明:获得event_base结构
返回值:成功返回event_base结构
	   失败返回NULL
	 
void event_base_free(struct event_base *);
函数说明:释放event_base指针

int event_reinit(struct event_base *base);
函数说明:如果有子进程,且子进程也要使用base,则子进程需要对event_base重新初始化,此时需要调用event_reinit函数
函数参数:由event_base_new返回的执行event_base结构的指针
返回值:成功返回0,失败返回-1

const char **event_get_supported_methods(void);
函数说明:获得当前系统支持的方法有哪些
返回值:返回二维数组

const char *event_base_get_method(const struct event_base *base);
函数说明:获得当前base节点使用的多路IO方法
函数参数:event_base结构的base指针
返回值:获得当前base节点使用的多路IO方法的指针

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22

查看当前系统支持的多路IO方法和当前所使用的方法:

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<event2/event.h>
int main(){
	int i=0;
	//获取当前系统支持的方法
	const char **p = event_get_supported_methods();
	while(p[i]!=NULL){
		printf("%s \t",p[i++]);
	}
	printf("\n");

	//获取地基节点
	struct event_base*base = event_base_new();
	if(base==NULL){
		printf("event_base_new errorn");
		return -1;
	}
	//获取当前系统使用的方法
	const char *pp = event_base_get_method(base);
	printf("%s\n",pp);
	//释放节点
	event_base_free(base);
}

//ln -s /usr/lib/libevent-2.0.so.5 /usr/lib64/libevent-2.0.so.5

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27

等待事件产生-循环等待event_loop:libevent在地基打好之后,需要等待事件的产生,也就是等待事件被激活,所以程序不能退出,对于epoll来说,我们需要自己控制循环,接口如下:

int event_base_loop(struct event_base *base,int flags);
函数说明:进入循环等待事件
参数说明:
	base:由event_base_new函数返回的指向event_base结构的指针
	flags的取值:
		#define EVLOOP_ONCE 0x01 只触发一次,如果事件没有被触发,阻塞等待
		#define EVLOOP_NONBLOCK 0x02 非阻塞方式检测事件是否被触发,不管事件触发与否,都会立即返回

int event_base_dispatch(struct event_base *base);
函数说明:进入循环等待事件
参数说明:由event_base_neew函数返回的指向event_base结构的指针
调用该函数,相当于没有设置标志位的event_base_loop.程序将会一直运行,直到没有需要检测的事情了,或者被结束循环的API终止.

int event_base_loopexit(struct event_base *base,const struct timeval *tv);
int event_base_loopbreak(struct event_base *base);
struct timeval{
	long tv_sec;
	long tv_usec;
};
两个函数的区别是如果正在执行激活时间的回调函数,那么event_base_loopexit将在事件回调执行结束后终止循环,而event_base_loopbreak会立即终止循环.

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20

使用libevent库的步骤:

    创建根节点 event_base_new
    设置监听事件和数据可读可写的事件的回调函数,设置事件对应的回调函数之后,事件产生时会自动调用回调函数
    事件循环event_base_dispatch,相当于while(1),在循环内部等待事件发生,若事件发生则会触发事件对应的回调函数
    释放根节点event_base_free,释放由event_base_new和event_new创建的资源,分别调用event_base_free和event_free函数.

typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);
struct event *event_new(struct event_base *base, evutil_socket_t fd, short events, event_callback_fn cb, void *arg);
函数说明:event_new负责创建event结构指针,同时指定对应的地基base,还有对应的文件描述符,事件,以及回调函数和回调函数参数
参数说明:
	base:对应的根节点 -- 地基
	fd:要监听的文件描述符
	events:要监听的事件
		#define EV_TIMEOUT 0x01 //超时事件
		#define EV_READ    0x02 //读事件
		#define EV_WRITE   0x04 //写事件
		#define EV_SIGNAL  0x08 //信号事件
		#define EV_PERSIST 0x10 //周期性触发
		#define EV_ET      0x20 //边缘触发,如果底层模型支持设置,则有效,若不支持则无效
		若想设置持续的读事件则:EV_READ | EV_PERSIST
	cd回调函数:
		typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);
		参数:对应于event_new函数的fd, event和arg

int event_add(struct event *ev,const struct timeval *timeout);
函数说明:将非未决态事件转为未决态,相当于调用epoll_ctl函数(EPOLL_CTL_ADD),开始监听事件是否产生,相当于epoll的上树操作
参数说明:
	ev:调用event_new创建的事件
	timeout:限时等待事件的产生,也可以设置NULL,没有限时

int event_del(struct event *ev);
函数说明:将事件从未决态变为非未决态,相当于epoll的下树(epoll_ctl(EPOLL_CTL_DEL))操作
参数说明:
	ev指的是由event_new创建的事件

void event_free(struct event *ev);
函数说明:释放由event_new申请的event节点

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31

编写基于event实现的tcp服务器

    创建socket – socket()
    设置端口复用 – setsockopt(lfd,SOLSOCKET,SO_REUSEADDR,&opt,sizeof(int));
    绑定 – bind()
    设置监听 – listen()
    创建地基:struct event_base *base = event_base_new();
    创建lfd对应的事件struct event *ev = event_new(base,lfd,EV_REAF|EV_PERSIST,conncb,&arg)
    上event_base地基event_add(ev,NULL);
    进入事件循环event_base_dispatch(base);
    释放资源:event_base_free(base);event_free(ev);

//编写libevent服务端
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>
#include <event2/event.h>

struct event *connev = NULL;

//typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);
void readcb(evutil_socket_t fd, short events, void *arg)
{
	int n;
	char buf[1024];
	memset(buf, 0x00, sizeof(buf));
	n = read(fd, buf, sizeof(buf));
	if(n<=0)
	{
		close(fd);
		//将通信文件描述符对应的事件从base地基上删除
		event_del(connev);
	}
	else
	{
		write(fd, buf, n);
	}
}

void conncb(evutil_socket_t fd, short events, void *arg)
{
	struct event_base *base = (struct event_base *)arg;

	//接受新的客户端连接
	int cfd = accept(fd, NULL, NULL);
	if(cfd>0)
	{
		//创建通信文件描述符对应的事件并设置回调函数为readcb
		connev = event_new(base, cfd, EV_READ|EV_PERSIST, readcb, NULL);
		if(connev==NULL)
		{
			//退出循环
			event_base_loopexit(base, NULL);
		}
		
		//将通信文件描述符对应的事件上event_base地基
		event_add(connev, NULL);	
	}	
}

int main()
{
	//创建socket
	int lfd = socket(AF_INET, SOCK_STREAM, 0);

	//设置端口复用
	int opt = 1;
	setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
	
	//绑定
	struct sockaddr_in serv;
	bzero(&serv, sizeof(serv));
	serv.sin_addr.s_addr = htonl(INADDR_ANY);
	serv.sin_port = htons(8888);
	serv.sin_family = AF_INET;
	bind(lfd, (struct sockaddr*)&serv, sizeof(serv));
	
	//监听
	listen(lfd, 120);
	
	//创建地基
	struct event_base *base = event_base_new();
	if(base==NULL)
	{
		printf("event_base_new error\n");
		return -1;
	}
	
	//创建监听文件描述符对应的事件
	//struct event *event_new(struct event_base *base, evutil_socket_t fd, short events, event_callback_fn cb, void *arg);
	struct event *ev = event_new(base, lfd, EV_READ|EV_PERSIST, conncb, base);
	if(ev==NULL)
	{
		printf("event_new error\n");
		return -1;
	}
	
	//将新的事件节点上base地基
	event_add(ev, NULL);
	
	//进入事件循环等待
	event_base_dispatch(base);
	
	//释放资源
	event_base_free(base);
	event_free(ev);
	
	close(lfd);
	return 0;
}
//假如有3个客户端连接,将第一个关闭时,后面两个将不能通信,若直接关闭第三个,则前两个还可以通信.是因为,connev是全局变量,任何进程均可访问,event_del(connev)时会将最后一个下树.
//解决方法:通过事件来判断把那个客户端下树,fd和事件在结构体中是一一对应的

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82
    83
    84
    85
    86
    87
    88
    89
    90
    91
    92
    93
    94
    95
    96
    97
    98
    99
    100
    101
    102
    103
    104

6.2 自带buffer事件,bufferevent内部有两个缓冲区,以及一个文件描述符.一个文件描述符有读和写两个缓冲区,bufferevent同样也带有两个缓冲区,还有就是libevent事件驱动的核心回调函数,四个缓冲区以及触发回调的关系如下:
在这里插入图片描述
一个bufferevent对应两个缓冲区, 三个回调函数, 分别是写回调, 读回调和事件回调.
bufferevent的三个回调函数:

    读回调:当bufferevent将底层读缓冲区的数据读到自身的读缓冲区时触发读事件回调
    写回调:当bufferevent将自身写缓冲的数据写到底层写缓冲区时触发写事件回调,由于数据最终是写入了内核的写缓冲区中,应用程序已经无法控制,这个事件基本只是起到通知功能
    事件回调:当bufferevent绑定socket连接,断开或者异常的时候触发事件回调.

主要函数:

struct bufferevent *bufferevent_socket_new(struct event_base *base,evutil_socket_t fd,int options);
函数说明:bufferevent_socket_new对已经存在socket创建bufferevent事件,可用于后面的连接监听器的回调函数中.
参数说明:
	base:对应根节点
	fd:文件描述符
	options:bufferevent的选项
		BEV_OPT_CLOSE_ON_FREE 释放bufferevent自动关闭底层接口(当bufferevent被释放后,文件描述符也随之被close)
		BEV_OPT_THREADSAFE 使bufferevent能够在多线程下是安全的

int bufferevent_socket_connect(struct bufferevent *bev,struct sockaddr *serv,int socklen);
函数说明:该函数封装了底层的socket与connect接口,通过调用此函数可以将bufferevent事件与通信的socket进行绑定
参数说明:
	bev:需要提前初始化bufferevent事件
	serv:对端的ip地址,端口,协议的结构指针
	socklen:描述serv的长度
说明:调用此函数以后,通信的socket与bufferevent缓冲区做了绑定,
后面调用bufferevent_setcb函数以后,会对bufferevent缓冲区的读写操作的事件设置回调函数,
当往缓冲区中写数据的时候会触发写回调函数,
当数据从socket的内核缓冲区读到bufferevent读缓冲区中的时候会触发读回调函数
	
void bufferevent_free(struct bufferevent *bufev);
函数说明:释放bufferevent

void bufferevent_setcb(struct bufferevent *bufev,
	bufferevent_data_cb readcb,bufferevent_data_cb writecb,
	buffer_event_cb eventcb,void *cbarg);
函数说明:bufferevent_setcb用于设置bufferevent的回调函数,readcb,writecb,eventcb分别对应了读回调,写回调和事件回调,cbarg代表回调函数的参数.

回调函数的原型：
typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);
typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short what, void *ctx);
	What 代表 对应的事件
	BEV_EVENT_EOF--遇到文件结束指示
	BEV_EVENT_ERROR--发生错误
	BEV_EVENT_TIMEOUT--发生超时
	BEV_EVENT_CONNECTED--请求的过程中连接已经完成

int bufferevent_write(struct bufferevent *bufev,const void *data,size_t size);
函数说明:bufferevent_write是将data的数据写到bufferevent的写缓冲区

size_t bufferevent_read(struct bufferevent *bufev,void *data,size_t size);
函数说明:bufferevent_read是将bufferevent的读缓冲区数据读到data中,同时将读到的数据从bufferevent的读缓冲区中清除

int bufferevent_enable(struct bufferevent *bufev,short event);
int bufferevent_disable(struct bufferevent *bufev,short event);
函数说明:bufferevent_enable与bufferevent_disable是设置事件是否生效, 如果设置为disable, 事件回调将不会被触发

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47

6.3 链接监听器evconnlistener
链接监听器封装了底层的socket通信相关函数,比如:socket,bind,listen,accept.链接监听器创建后实际上调用了socket,bind,listen.此时等待新的客户端连接到来,如果有新的客户端连接,那么内部先进性调用accept处理,然后调用用户指定的回调函数.

struct evconnlistener *evconnlistener_new_bind(struct event_base *base,
    evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,
	const struct sockaddr *sa, int socklen);
函数说明:在没有套接字的情况下对连接监听器进行初始化
参数:
	cb:是有新连接之后的回调函数,但是注意这个回调函数触发的时候,链接器已经处理好新连接了,并将与新连接通信的描述符交给回调函数
	ptr是回调函数的参数
	backlog是listen函数的关键参数,若backlog是-1,那么监听器会自动选择一个合适的值,如果填0,那么监听器会认为listen函数已经被调用过了
	sa和socklen是bind函数的参数
	flags:
		LEV_OPT_LEAVE_SOCKETS_BLOCKING   文件描述符为阻塞的
		LEV_OPT_CLOSE_ON_FREE            关闭时自动释放
		LEV_OPT_REUSEABLE                端口复用
		LEV_OPT_THREADSAFE               分配锁, 线程安全

回调函数:
typedef void (*evconnlistener_cb)(struct evconnlistener *evl, evutil_socket_t fd, struct sockaddr *cliaddr, int socklen, void *ptr);
参数:
	fd:与客户端通信的描述符,cliaaddr对应的也是新连接的对端地址信息

void evconnlistener_free(struct evconnlistener *lev);
函数说明: 释放链接监听器

int evconnlistener_enable(struct evconnlistener *lev);
函数说明: 使链接监听器生效

int evconnlistener_disable(struct evconnlistener *lev);
函数说明: 使链接监听器失效

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29

在这里插入图片描述
libevent开发流程图：
在这里插入图片描述
7 HTML超文本标记语言

<html> 开始 和</html> 结束,属于html的根标签
<head></head> 头部标签,头部标签内一般有 <title></title>
<body></body> 主体标签,一般用于显示内容

题目标签：
	共有6种,<h1>,<h2>,…<h6>,其中<h1>最大,<h6>最小
文本标签：
	<font size={1-7} color=red></font>
换行标签：<br/>
水平线：<hr/>
列表标签：
	<ul>和<ol>无序和有序
	<ul>
		<li>列表内容1</li>
		<li>列表内容2</li>
		…
	</ul>
	无序列表可以设置type属性:
	实心圆圈:type=disc
	空心圆圈:type=circle
	小方块:  type=square
	有序列表的格式如下:
	<ol>
		<li>列表内容1</li>
		<li>列表内容2</li>
		…
	</ol>
	有序列表同样可以设置type属性
	数字:type=1,也是默认方式
	英文字母:type=a或type=A
	罗马数字:type=i或type=I
图片标签：
	<img>
	src=”3.gif” 图片来源,必写
	alt=”小岳岳” 图片不显示时,显示的内容
	title=”我的天呐” 鼠标移动到图片上时显示的文字
	width=”600” 图片显示的宽度
	height=”400” 图片显示的高度
超链接：
	<a>
	href="http://www.itcast.cn",前往地址,必填,注意要写http://
	title="百度" 鼠标移动到链接上时显示的文字
	target="_self"或者”_blank”,_self是默认值,在自身页面打开,_blank是新开页面前往连接地址:
<a href="http://www.baidu.com" title="百度" target="_self" >百度</a>

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44

http超文本传输协议：
http请求消息：
分为四部分：

    请求行 说明请求类型,要访问的资源,以及使用的http版本
    请求头 说明服务器使用的附加信息,都是键值对,比如表明浏览器类型
    空行 不能省略-而且是\r\n,包括请求行和请求头都是以\r\n结尾
    请求数据 表明请求的特定数据内容,可以省略-如登陆时,会将用户名和密码内容作为请求数据

请求类型：http协议有很多种请求类型，最多的是get和post请求。
get：请求指定的页面信息，并返回实体主体
post：向指定资源提交数据进行处理请求。数据被包含在请求体中。post请求可能会导致新的资源的建立和/或已有资源的修改。
区别：post方式不显示提交的数据；get会显示，如用户名和密码之类的数据；使用post比get安全。

http响应消息：
响应消息是代表服务器收到请求消息后，给浏览器做的反馈，所以响应消息是服务器发送给浏览器的，响应消息分为四部分：

    状态行 包括http版本号,状态码,状态信息
    消息报头 说明客户端要使用的一些附加信息,也是键值对
    空行 \r\n 同样不能省略
    响应正文 服务器返回给客户端的文本信息

http常见状态码：

    1xx 指示信息–表示请求已接收，继续处理
    2xx 成功–表示请求已被成功接收、理解、接受
    3xx 重定向–要完成请求必须进行更进一步的操作
    4xx 客户端错误–请求有语法错误或请求无法实现
    5xx 服务器端错误–服务器未能实现合法的请求

常见状态码：

    200 OK 客户端请求成功
    301 Moved Permanently 重定向
    400 Bad Request 客户端请求有语法错误，不能被服务器所理解
    401 Unauthorized 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
    403 Forbidden 服务器收到请求，但是拒绝提供服务
    404 Not Found 请求资源不存在，eg：输入了错误的URL
    500 Internal Server Error 服务器发生不可预期的错误
    503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常

web服务器：
使用http协议传送html文件，这只是应用层协议，我们需要一个传输层协议来完成我们的传输数据的工作，可选择TCP+HTTP
在这里插入图片描述
基于epoll的web服务器

//web服务端程序--使用epoll模型
#include <unistd.h>
#include <sys/epoll.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <string.h>
#include <signal.h>
#include <dirent.h>
#include "pub.h"
#include "wrap.h"

int http_request(int cfd);
int main()
{
	//改变当前进程的工作目录
	char path[255] = {0};
	sprintf(path, "%s/%s", getenv("HOME"), "webpath");
	chdir(path);
	
	//创建socket--设置端口复用---bind
	int lfd = tcp4bind(9999, NULL);
	
	//设置监听
	Listen(lfd, 128);
	
	//创建epoll树
	int epfd = epoll_create(1024);
	if(epfd<0)
	{
		perror("epoll_create error");
		close(lfd);
		return -1;
	}
	
	//将监听文件描述符lfd上树
	struct epoll_event ev;
	ev.data.fd = lfd;
	ev.events = EPOLLIN;
	epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);
	
	int i;
	int cfd;
	int nready;
	int sockfd;
	struct epoll_event events[1024];
	while(1)
	{
		//等待事件发生
		nready = epoll_wait(epfd, events, 1024, -1);
		if(nready<0)
		{
			if(errno==EINTR)
			{
				continue;
			}
			break;
		}
		
		for(i=0; i<nready; i++)
		{
			sockfd = events[i].data.fd;
			//有客户端连接请求
			if(sockfd==lfd)
			{
				//接受新的客户端连接
				cfd = Accept(lfd, NULL, NULL);
				
				//设置cfd为非阻塞
				int flag = fcntl(cfd, F_GETFL);
				flag |= O_NONBLOCK;
				fcntl(cfd, F_SETFL, flag);
				
				//将新的cfd上树
				ev.data.fd = cfd;
				ev.events = EPOLLIN;
				epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);
			}
			else 
			{
				//有客户端数据发来
				http_request(cfd);
			}			
		}		
	}
}

int send_header(int cfd, char *code, char *msg, char *fileType, int len)
{
	char buf[1024] = {0};
	sprintf(buf, "HTTP/1.1 %s %s\r\n", code, msg);
	sprintf(buf+strlen(buf), "Content-Type:%s\r\n", fileType);
	if(len>0)
	{
		sprintf(buf+strlen(buf), "Content-Length:%d\r\n", len);
	}
	strcat(buf, "\r\n");
	Write(cfd, buf, strlen(buf));
	return 0;
}

int send_file(int cfd, char *fileName)
{
	//打开文件
	int fd = open(fileName, O_RDONLY);
	if(fd<0)
	{
		perror("open error");
		return -1;
	}
	
	//循环读文件, 然后发送
	int n;
	char buf[1024];
	while(1)
	{
		memset(buf, 0x00, sizeof(buf));
		n = read(fd, buf, sizeof(buf));
		if(n<=0)
		{
			break;
		}
		else 
		{
			Write(cfd, buf, n);
		}
	}
}

int http_request(int cfd)
{
	int n;
	char buf[1024];
	//读取请求行数据, 分析出要请求的资源文件名
	memset(buf, 0x00, sizeof(buf));
	Readline(cfd, buf, sizeof(buf));
	printf("buf==[%s]\n", buf);
	//GET /hanzi.c HTTP/1.1
	char reqType[16] = {0};
	char fileName[255] = {0};
	char protocal[16] = {0};
	sscanf(buf, "%[^ ] %[^ ] %[^ \r\n]", reqType, fileName, protocal);
	printf("[%s]\n", reqType);
	printf("[%s]\n", fileName);
	printf("[%s]\n", protocal);
	
	char *pFile = fileName+1;
	printf("[%s]\n", pFile);
	
	//循环读取完剩余的数据
	while((n=Readline(cfd, buf, sizeof(buf)))>0);
	
	//判断文件是否存在
	struct stat st;
	if(stat(pFile, &st)<0)
	{
		printf("file not exist\n");
		
		//发送头部信息
		send_header(cfd, "404", "NOT FOUND", get_mime_type(".html"), 0);
		
		//发送文件内容
		send_file(cfd, "error.html");	
	}
	else //若文件存在
	{
		//判断文件类型
		//普通文件
		if(S_ISREG(st.st_mode))
		{
			printf("file exist\n");
			//发送头部信息
			send_header(cfd, "200", "OK", get_mime_type(pFile), st.st_size);
			
			//发送文件内容
			send_file(cfd, pFile);
		}
		//目录文件
		else if(S_ISDIR(st.st_mode))
		{
			
		}
	}
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82
    83
    84
    85
    86
    87
    88
    89
    90
    91
    92
    93
    94
    95
    96
    97
    98
    99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153
    154
    155
    156
    157
    158
    159
    160
    161
    162
    163
    164
    165
    166
    167
    168
    169
    170
    171
    172
    173
    174
    175
    176
    177
    178
    179
    180
    181
    182
    183
    184

web服务端开发：

//web服务端程序--使用epoll模型
#include <unistd.h>
#include <sys/epoll.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <string.h>
#include <signal.h>
#include <dirent.h>
#include "pub.h"
#include "wrap.h"

int http_request(int cfd);

int main()
{
	//若客户端请求文件较大，传输过程中客户端关闭，则服务端还在写入，此时会造成管道破裂
	//设置信号，忽略SIGPIPE信号
	struct sigaction act;
    act.sa_handler = SIG_IGN;
    sigemptyset(&act.sa_mask);
    act.sa_flags=0;
    sigaction(SIGPIPE,&act,NULL);
	
	//改变当前进程的工作目录
	char path[255] = {0};
	sprintf(path, "%s/%s", getenv("HOME"), "webpath");
	chdir(path);
	
	//创建socket--设置端口复用---bind
	int lfd = tcp4bind(9999, NULL);
	
	//设置监听
	Listen(lfd, 128);
	
	//创建epoll树
	int epfd = epoll_create(1024);
	if(epfd<0)
	{
		perror("epoll_create error");
		close(lfd);
		return -1;
	}
	
	//将监听文件描述符lfd上树
	struct epoll_event ev;
	ev.data.fd = lfd;
	ev.events = EPOLLIN;
	epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);
	
	int i;
	int cfd;
	int nready;
	int sockfd;
	struct epoll_event events[1024];
	while(1)
	{
		//等待事件发生
		nready = epoll_wait(epfd, events, 1024, -1);
		if(nready<0)
		{
			if(errno==EINTR)
			{
				continue;
			}
			break;
		}
		
		for(i=0; i<nready; i++)
		{
			sockfd = events[i].data.fd;
			//有客户端连接请求
			if(sockfd==lfd)
			{
				//接受新的客户端连接
				cfd = Accept(lfd, NULL, NULL);
				
				//设置cfd为非阻塞
				int flag = fcntl(cfd, F_GETFL);
				flag |= O_NONBLOCK;
				fcntl(cfd, F_SETFL, flag);
				
				//将新的cfd上树
				ev.data.fd = cfd;
				ev.events = EPOLLIN;
				epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);
			}
			else 
			{
				//有客户端数据发来
				http_request(cfd);
			}			
		}		
	}
}

int send_header(int cfd, char *code, char *msg, char *fileType, int len)
{
	char buf[1024] = {0};
	//把格式化的数据写入某个字符串缓冲区。
	sprintf(buf, "HTTP/1.1 %s %s\r\n", code, msg);
	sprintf(buf+strlen(buf), "Content-Type:%s\r\n", fileType);
	if(len>0)
	{
		sprintf(buf+strlen(buf), "Content-Length:%d\r\n", len);
	}
	strcat(buf, "\r\n");
	Write(cfd, buf, strlen(buf));
	return 0;
}

int send_file(int cfd, char *fileName)
{
	//打开文件
	int fd = open(fileName, O_RDONLY);
	if(fd<0)
	{
		perror("open error");
		return -1;
	}
	
	//循环读文件, 然后发送
	int n;
	char buf[1024];
	while(1)
	{
		memset(buf, 0x00, sizeof(buf));
		n = read(fd, buf, sizeof(buf));
		if(n<=0)
		{
			break;
		}
		else 
		{
			Write(cfd, buf, n);
		}
	}
}

int http_request(int cfd)
{
	int n;
	char buf[1024];
	//读取请求行数据, 分析出要请求的资源文件名
	memset(buf, 0x00, sizeof(buf));
	Readline(cfd, buf, sizeof(buf));
	printf("buf==[%s]\n", buf);
	//GET /hanzi.c HTTP/1.1
	char reqType[16] = {0};
	char fileName[255] = {0};
	char protocal[16] = {0};
	sscanf(buf, "%[^ ] %[^ ] %[^ \r\n]", reqType, fileName, protocal);
	printf("[%s]\n", reqType);
	printf("[%s]\n", fileName);
	printf("[%s]\n", protocal);
	
	char *pFile = fileName;
	if(strlen(fileName)<=1){
	    strcpy(pFile,"./");
	}else{
	    pFile = fileName+1;
	}
	//转换汉字编码
	strdecode(pFile,pFile);
	printf("pFile==[%s]\n",pFile);
	
	//循环读取完剩余的数据，避免产生粘包
	while((n=Readline(cfd, buf, sizeof(buf)))>0);
	
	//判断文件是否存在
	struct stat st;
	if(stat(pFile, &st)<0)
	{
		printf("file not exist\n");
		
		//发送头部信息
		send_header(cfd, "404", "NOT FOUND", get_mime_type(".html"), 0);
		
		//发送文件内容
		send_file(cfd, "error.html");	
	}
	else //若文件存在
	{
		//判断文件类型
		//普通文件
		if(S_ISREG(st.st_mode))
		{
			printf("file exist\n");
			//发送头部信息
			send_header(cfd, "200", "OK", get_mime_type(pFile), st.st_size);
			
			//发送文件内容
			send_file(cfd, pFile);
		}
		//目录文件
		else if(S_ISDIR(st.st_mode))
		{
			printf("***********dir file******************\n");
			//发送头部信息
	        send_header(cfd,"200","OK",get_mime_type(".html"),0);
			
			//发送html文件头部
	        send_file(cfd,"html/dir_header.html");
	        char buffer[1024];
	        //文件列表信息
	        struct dirent **namelist;
	        int num;
			//返回目录下满足条件的文件，并返回保存在namelist中
	        num = scandir(pFile, &namelist, NULL, alphasort);
	        if (num == -1) {
	            perror("scandir");
	            close(cfd);
	            epoll_ctl(epfd,EPOLL_CTL_DEL,cfd,NULL);
	            return -1;
	        }else{
	            while (num--) {
	                printf("%s\n", namelist[num]->d_name);
	                memset(buffer,0x00,sizeof(buffer));
	                if(namelist[num]->d_type==DT_DIR){
	                	//href=%s比下面多一个/
	                    sprintf(buffer,"<li><a href=%s/>%s</a></li>",namelist[num]->d_name,namelist[num]->d_name);
	                }else{
	                    sprintf(buffer,"<li><a href=%s>%s</a></li>",namelist[num]->d_name,namelist[num]->d_name);
	                }
	                free(namelist[num]);
	                write(cfd,buffer,strlen(buffer));
	            }
	            free(namelist);
	        }
	        //发送html尾部
			send_file(cfd,"html/dir_tail.html");
		}
	}
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82
    83
    84
    85
    86
    87
    88
    89
    90
    91
    92
    93
    94
    95
    96
    97
    98
    99
    100
    101
    102
    103
    104
    105
    106
    107
    108
    109
    110
    111
    112
    113
    114
    115
    116
    117
    118
    119
    120
    121
    122
    123
    124
    125
    126
    127
    128
    129
    130
    131
    132
    133
    134
    135
    136
    137
    138
    139
    140
    141
    142
    143
    144
    145
    146
    147
    148
    149
    150
    151
    152
    153
    154
    155
    156
    157
    158
    159
    160
    161
    162
    163
    164
    165
    166
    167
    168
    169
    170
    171
    172
    173
    174
    175
    176
    177
    178
    179
    180
    181
    182
    183
    184
    185
    186
    187
    188
    189
    190
    191
    192
    193
    194
    195
    196
    197
    198
    199
    200
    201
    202
    203
    204
    205
    206
    207
    208
    209
    210
    211
    212
    213
    214
    215
    216
    217
    218
    219
    220
    221
    222
    223
    224
    225
    226
    227
    228
    229
    230
    231
    232
    233
    234

————————————————
版权声明：本文为CSDN博主「ChenXuuuu～」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_41874746/article/details/130529174



# 第三章：软件调试

## 1. GDB 

## **一、GDB是什么**

**调试程序**

程序中出现的语法错误可以借助编译器解决；但逻辑错误则只能靠自己解决。实际场景中解决逻辑错误最高效的方法，就是借助调试工具对程序进行调试。

所谓调试（Debug），就是让代码一步一步慢慢执行，跟踪程序的运行过程。比如，可以让程序停在某个地方，查看当前所有变量的值，或者内存中的数据；也可以让程序一次只执行一条或者几条语句，看看程序到底执行了哪些代码。

也就是说，通过调试程序，我们可以监控程序执行的每一个细节，包括变量的值、函数的调用过程、内存中数据、线程的调度等，从而发现隐藏的错误或者低效的代码。



## 二、GDB的作用

GDB 全称“GNU symbolic debugger”，从名称上不难看出，它诞生于 GNU 计划（同时诞生的还有 GCC、Emacs 等），是  Linux 下常用的程序调试器。发展至今，GDB 已经迭代了诸多个版本，当下的 GDB 支持调试多种编程语言编写的程序，包括  C、C++、Go、Objective-C、OpenCL、Ada等。实际场景中，GDB 更常用来调试 C 和 C++程序。

总的来说，借助 GDB调试器可以实现以下几个功能：

程序启动时，可以按照我们自定义的要求运行程序，例如设置参数和环境变量；

可使被调试程序在指定代码处暂停运行，并查看当前程序的运行状态（例如当前变量的值，函数的执行结果等），即支持断点调试；

程序执行过程中，可以改变某个变量的值，还可以改变代码的执行顺序，从而尝试修改程序中出现的逻辑错误。



## 三、GDB安装

1、通过包管理器进行安装

$ yum -y install gdb

2、源码安装GDB

在gdb源码包上面下载相应的版本进行安装即可。

3、查看GDB版本

输入`gdb -v`,即可查看当前安装的`gdb`的版本。

```text
$ gdb -v
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<Bugs in GDB>.
```

如果显示出gdb的版本，也说明了安装成功。



## 四、GDB的用法

**常用调试命令**

GDB 的主要功能就是监控程序的执行流程。这也就意味着，只有当源程序文件编译为可执行文件并执行时，并且该文件中必须包含必要的调试信息（比如各行代码所在的行号、包含程序中所有变量名称的列表（又称为符号表）等），GDB才会派上用场。

所以在编译时需要使用 gcc/g++ -g 选项编译源文件，才可生成满足 GDB 要求的可执行文件

![img](https://pic1.zhimg.com/80/v2-5f51a4d4b86a188c05b5195ed093980c_720w.webp)

**安案例分析**

```text
$ ls
main.cpp
$ g++ -g -o test main.cpp
$ ls
main.cpp  test
$ gdb test         <-- 启动gdb进行调试
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<Bugs in GDB>...
Reading symbols from /home/zhuyong/project/linux/blog/gdb/test...done.
(gdb)
```



`gdb`启动时会默认打印一堆免责条款，通过添加 `--silent`（或者 `-q`、`--quiet`）选项，可将这部分信息屏蔽掉。

下面先用个例子运行下上述调试命令

```text
$ gdb test -q      <-- 启动gdb进行调试
Reading symbols from /home/zhudi/project/linux/blog/gdb/test...done.
(gdb) l            <-- 显示带行号的源代码
1	#include <iostream>
2	using namespace std;
3
4	int main() {
5	    int sum = 0;
6	    int n = 1;
7	    while (n <= 100) {
8	        sum += n;
9	        n++;
10	    }
(gdb)              <-- 默认情况下，l 选项只显示 10 行源代码，如果查看后续代码，按 Enter 回车键即可
11	    cout << "sum = " << sum << endl;
12
13	    return 0;
14	}
15
(gdb) b 7          <-- 在第7行源代码处打断点
Breakpoint 1 at 0x4008d3: file main.cpp, line 7.
(gdb) r            <-- 运行程序，遇到断点停止
Starting program: /home/zhudi/project/linux/blog/gdb/test

Breakpoint 1, main () at main.cpp:7
7	    while (n <= 100) {
Missing separate debuginfos, use: debuginfo-install glibc-2.17-307.el7.1.x86_64 libgcc-4.8.5-39.el7.x86_64 libstdc++-4.8.5-39.el7.x86_64
(gdb) print n      <-- 查看代码中变量 n 的值
$1 = 1             <-- 当前 n 的值为 1，$1 表示该变量 表示该变量所在存储区的名称
(gdb) b 13
Breakpoint 2 at 0x40090e: file main.cpp, line 13.
(gdb) n            <-- 单步执行程序
8	        sum += n;
(gdb) n            <-- 单步执行程序
9	        n++;
(gdb) c            <-- 继续执行程序
Continuing.
sum = 5050

Breakpoint 2, main () at main.cpp:13
13	    return 0;
(gdb) print sum     <-- 查看 sum 的值    
$2 = 5050           <-- 当前 sum 的值为 5050
(gdb) q             <-- 退出调试
A debugging session is active.

	Inferior 1 [process 8449] will be killed.

Quit anyway? (y or n) y     <-- 确认是否退出调试，y 为退出，n 为不退出
```

接下来分别介绍下各个命令的用法



## 五、GDB 断点调试

**启动程序**

根据不同场景的需要，GDB 调试器提供了多种方式来启动目标程序，其中最常用的就是run 指令，其次为 start 指令。也就是说，run和 start 指令都可以用来在 GDB 调试器中启动程序，它们之间的区别是：

默认情况下，run 指令会一直执行程序，直到执行结束。如果程序中手动设置有断点，则 run指令会执行程序至第一个断点处；

start 指令会执行程序至main()主函数的起始位置，即在main()函数的第一行语句处停止执行（该行代码尚未执行）。

**break命令**

break 命令（可以用b 代替）常用的语法格式有以下 2 种。

```text
1、(gdb) break location      // b location
2、(gdb) break ... if cond   // b .. if cond
```

1、第一种格式中，`location` 用于指定打断点的具体位置，其表示方式有多种，如表 1 所示。

![img](https://pic4.zhimg.com/80/v2-6cc366031f1fc6f71a8a86a4b4f29167_720w.webp)

2、第二种格式中，… 可以是表 1 中所有参数的值，用于指定打断点的具体位置；cond 为某个表达式。整体的含义为：每次程序执行到 … 位置时都计算 cond  的值，如果为 True，则程序在该位置暂停；反之，程序继续执行。另外也可以用condition 为断点设置命中条件。

**tbreak和rbreak命令**

tbreak 命令可以看到是 break 命令的另一个版本，tbreak 和 break 命令的用法和功能都非常相似，唯一的不同在于，使用 tbreak 命令打的断点仅会作用 1 次，即使程序暂停之后，该断点就会自动消失。

和 break 和 tbreak 命令不同，rbreak命令的作用对象是 C、C++ 程序中的函数，它会在指定函数的开头位置打断点。语法格式

(gdb) tbreak regex

其中`regex`为一个正则表达式，程序中函数的函数名只要满足`regex`条件，`tbreak`命令就会其内部的开头位置打断点。值得一提的是，`tbreak`命令打的断点和`break`命令打断点的效果是一样的，会一直存在，不会自动消失。

**案例分析：**

```text
$ gdb test -q
Reading symbols from /home/zhudi/project/linux/blog/gdb/test...done.
(gdb) l
4	
5	void cb_one() {
6	    cout << "cb_one" << endl;
7	}
8	void cb_second() {
9	    cout << "cb_second" << endl;
10	}
11	
12	int main() {
13	    int sum = 0;
(gdb) 
14	    int n = 1;
15	    while (sum < 100) {
16	        sum += n;
17	        n++;
18	        cout << "sum = " << sum << endl;
19	        sleep(1);
20	        cb_one();
21	        cb_second();
22	    }
23	    cout << "sum = " << sum << endl;
(gdb) b 16                  <-- 在第16行打断点
Breakpoint 1 at 0x400959: file main.cpp, line 16.
(gdb) r                     <-- 启动程序
Starting program: /home/zhudi/project/linux/blog/gdb/test 

Breakpoint 1, main () at main.cpp:16
16	        sum += n;       <-- 在16行暂停
(gdb) b +2                  <--在当前位置之后的2行处设置断点
Breakpoint 2 at 0x400963: file main.cpp, line 18.
(gdb) c
Continuing.

Breakpoint 2, main () at main.cpp:18
18	        cout << "sum = " << sum << endl;
(gdb) b 19 if sum>2         <-- 条件断点
Breakpoint 3 at 0x40098c: file main.cpp, line 19.
(gdb) c
Continuing.
sum = 1
cb_one
cb_second

Breakpoint 1, main () at main.cpp:16
16	        sum += n;
(gdb) c
Continuing.

Breakpoint 2, main () at main.cpp:18
18	        cout << "sum = " << sum << endl;
(gdb) c
Continuing.
sum = 3

Breakpoint 3, main () at main.cpp:19
19	        sleep(1);
(gdb) p sum
$1 = 3
(gdb) rbreak cb_*            <-- 匹配所有以cb_开头的函数
Breakpoint 4 at 0x400901: file main.cpp, line 6.
void cb_one();
Breakpoint 5 at 0x400923: file main.cpp, line 9.
void cb_second();
Breakpoint 6 at 0x400a17: file main.cpp, line 26.
(gdb) c
Continuing.

Breakpoint 4, cb_one () at main.cpp:6
6	    cout << "cb_one" << endl;     <-- 在cb_one函数的第一行暂停
(gdb) c
Continuing.
cb_one

Breakpoint 5, cb_second () at main.cpp:9
9	    cout << "cb_second" << endl;  <-- 在cb_second函数的第一行暂停
```

## 六、删除或禁用断点

**删除断点**

如果之前建立的断点不再需要或者暂时不需要，该如何删除或者禁用呢？常用的方式有 2 种：

1、使用 quit 命令退出调试，然后重新对目标程序启动调试，此方法会将消除上一次调试操作中建立的所有断点；

2、使用专门删除或禁用断点的命令，既可以删除某一个断点，也可以删除全部断点。

无论是普通断点、观察断点还是捕捉断点，都可以使用 clear 或者 delete 命令进行删除。

clear 命令可以删除指定位置处的所有断点，常用的语法格式如下所示：

```text
(gdb) clear location
```

参数`location` 通常为某一行代码的行号或者某个具体的函数名。当 `location` 参数为某个函数的函数名时，表示删除位于该函数入口处的所有断点。

`delete` 命令（可以缩写为 `d`）通常用来删除所有断点，也可以删除指定编号的各类型断点，语法格式如下：

```text
delete [breakpoints] [num]
```

其中，`breakpoints` 参数可有可无，`num` 参数为指定断点的编号，其可以是`delete` 删除某一个断点，而非全部。

如果不指定 `num`参数，则 `delete` 命令会删除当前程序中存在的所有断点。

**禁用断点**

禁用断点可以使用 `disable` 命令，语法格式如下：

```text
disable [breakpoints] [num...]
```

breakpoints 参数可有可无；num...表示可以有多个参数，每个参数都为要禁用断点的编号。如果指定 num...，disable 命令会禁用指定编号的断点；反之若不设定 num...，则 disable 会禁用当前程序中所有的断点。

对于禁用的断点，可以使用enable 命令激活，该命令的语法格式有多种，分别对应有不同的功能：

```text
enable [breakpoints] [num...]                        激活用 num... 参数指定的多个断点，如果不设定 num...，表示激活所有禁用的断点
enable [breakpoints] once num…                 临时激活以 num... 为编号的多个断点，但断点只能使用 1 次，之后会自动回到禁用状态
enable [breakpoints] count num...      临时激活以 num... 为编号的多个断点，断点可以使用 count 次，之后进入禁用状态
enable [breakpoints] delete num…               激活 num.. 为编号的多个断点，但断点只能使用 1 次，之后会被永久删除。
```

其中，breakpoints 参数可有可无；num...表示可以提供多个断点的编号，enable命令可以同时激活多个断点。

## 七、观察断点监控变量值的变化

**观察断点**

要知道，GDB 调试器支持在程序中打 3 种断点，分别为普通断点、观察断点和捕捉断点。其中 break 命令打的就是普通断点，而 watch 命令打的为观察断点。

使用 GDB 调试程序的过程中，借助观察断点可以监控程序中某个变量或者表达式的值，只要发生改变，程序就会停止执行。相比普通断点，观察断点不需要我们预测变量（表达式）值发生改变的具体位置

(gdb) watch cond

和 `watch` 命令功能相似的，还有 `rwatch` 和`awatch` 命令。其中：

- `rwatch` 命令：只要程序中出现读取目标变量（表达式）的值的操作，程序就会停止运行；
- `awatch` 命令：只要程序中出现读取目标变量（表达式）的值或者改变值的操作，程序就会停止运行。

**案例分析：**

```text
$ gdb test -q
Reading symbols from /home/zhudi/project/linux/blog/gdb/test...done.
(gdb) start
Temporary breakpoint 1 at 0x400949: file main.cpp, line 13.
Starting program: /home/zhuyong/project/linux/blog/gdb/test 

Temporary breakpoint 1, main () at main.cpp:13
13	    int sum = 0;
(gdb) l
8	void cb_second() {
9	    cout << "cb_second" << endl;
10	}
11	
12	int main() {
13	    int sum = 0;
14	    int n = 1;
15	    while (sum < 100) {
16	        sum += n;
17	        n++;
(gdb) watch sum        <-- 设置观察断点
Hardware watchpoint 2: sum
(gdb) c
Continuing.
Hardware watchpoint 2: sum

Old value = 0
New value = 1
main () at main.cpp:17
17	        n++;       <-- sum值发生变化，程序暂停
```

## 八、查看变量或表达式的值

对于在调试期间查看某个变量或表达式的值，GDB 调试器提供有 2 种方法，即使用 print 命令或者 display命令。

**print 命令**

它的功能就是在 GDB 调试程序的过程中，输出或者修改指定变量或者表达式的值。

print 命令可以缩写为 p，最常用的语法格式如下所示：

```text
(gdb) print num
(gdb) p num
```

其中，参数 `num` 用来代指要查看或者修改的目标变量或者表达式。

当程序中包含多个作用域不同但名称相同的变量或表达式时，可以借助`::`运算符明确指定要查看的目标变量或表达式。`::`运算符的语法格式如下：

```text
(gdb) print file::variable
(gdb) print function::variable
```

其中 file用于指定具体的文件名，funciton 用于指定具体所在函数的函数名，variable表示要查看的目标变量或表达式。

另外，print也可以打印出类或者结构体变量的值。

**####　display 命令**

和 print 命令一样，display 命令也用于调试阶段查看某个变量或表达式的值，它们的区别是，使用 display 命令查看变量或表达式的值，每当程序暂停执行（例如单步执行）时，GDB 调试器都会自动帮我们打印出来，而 print 命令则不会。

也就是说，使用 1 次 print 命令只能查看 1 次某个变量或表达式的值，而同样使用 1 次 display  命令，每次程序暂停执行时都会自动打印出目标变量或表达式的值。因此，当我们想频繁查看某个变量或表达式的值从而观察它的变化情况时，使用  display 命令可以一劳永逸。

display 命令没有缩写形式，常用的语法格式如下 2 种：

```text
(gdb) display expr
(gdb) display/fmt expr
```

注意，display 命令和 /fmt 之间不要留有空格。以 /x 为例，应写为 (gdb)display/x expr。

## 九、GDB单步调试

根据实际场景的需要，GDB 调试器共提供了 3 种可实现单步调试程序的方法，即使用 next、step 和 until 命令。换句话说，这 3 个命令都可以控制 GDB调试器每次仅执行 1 行代码，但除此之外，它们各自还有不同的功能。

**next命令**

next 是最常用来进行单步调试的命令，其最大的特点是当遇到包含调用函数的语句时，无论函数内部包含多少行代码，next 指令都会一步执行完。也就是说，对于调用的函数来说，next 命令只会将其视作一行代码。

next 命令可以缩写为n 命令，使用方法也很简单，语法格式如下：

(gdb) next count

**step命令**

通常情况下，`step` 命令和`next`命令的功能相同，都是单步执行程序。不同之处在于，当`step` 命令所执行的代码行中包含函数时，会进入该函数内部，并在函数第一行代码处停止执行。

`step` 命令可以缩写为 `s`命令，用法和 `next` 命令相同，语法格式如下：

```text
(gdb) step count
```

**until命令**

`until` 命令可以简写为 `u` 命令，有 2 种语法格式，如下所示：

```text
1、(gdb) until
2、(gdb) until location
```

其中，参数 location为某一行代码的行号。

不带参数的 until命令，可以使 GDB调试器快速运行完当前的循环体，并运行至循环体外停止。注意，until  命令并非任何情况下都会发挥这个作用，只有当执行至循环体尾部（最后一行代码）时，until命令才会发生此作用；反之，until命令和 next  命令的功能一样，只是单步执行程序。

**return命令**

实际调试时，在某个函数中调试一段时间后，可能不需要再一步步执行到函数返回处，希望直接执行完当前函数，这时可以使用 finish命令。与finish 命令类似的还有 return 命令，它们都可以结束当前执行的函数。

**finish命令**

finish 命令和 return命令的区别是，finish命令会执行函数到正常退出；而 return  命令是立即结束执行当前函数并返回，也就是说，如果当前函数还有剩余的代码未执行完毕，也不会执行了。除此之外，return命令还有一个功能，即可以指定该函数的返回值。

**jump命令**

jump 命令的功能是直接跳到指定行继续执行程序，其语法格式为：

```text
(gdb) jump location
```

其中，location 通常为某一行代码的行号。



也就是说，jump 命令可以略过某些代码，直接跳到  location处的代码继续执行程序。这意味着，如果你跳过了某个变量（对象）的初始化代码，直接执行操作该变量（对象）的代码，很可能会导致程序崩溃或出现其它 Bug。另外，如果 jump跳转到的位置后续没有断点，那么 GDB会直接执行自跳转处开始的后续代码。

**GDB search 命令**

调试文件时，某些时候可能会去找寻找某一行或者是某一部分的代码。可以使用 list  显示全部的源码，然后进行查看。当源文件的代码量较少时，我们可以使用这种方式搜索。如果源文件的代码量很大，使用这种方式寻找效率会很低。所以  GDB中提供了相关的源代码搜索的的search命令。

search 命令的语法格式为：

```text
search <regexp>
reverse-search <regexp>
```

第一项命令格式表示从当前行的开始向前搜索，后一项表示从当前行开始向后搜索。其中regexp  就是正则表达式，正则表达式描述了一种字符串匹配的模式，可以用来检查一个串中是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串。很多的编程语言都支持使用正则表达式。

查看堆栈信息

**backtrace 命令**

backtrace 命令用于打印当前调试环境中所有栈帧的信息，常用的语法格式如下：

```text
(gdb) backtrace [-full] [n]
```

其中，用 [ ] 括起来的参数为可选项，它们的含义分别为：

n：一个整数值，当为正整数时，表示打印最里层的 n 个栈帧的信息；n为负整数时，那么表示打印最外层n个栈帧的信息；

-full：打印栈帧信息的同时，打印出局部变量的值。

注意，当调试多线程程序时，该命令仅用于打印当前线程中所有栈帧的信息。如果想要打印所有线程的栈帧信息，应执行thread apply all backtrace命令。

**frame 命令**

frame命令的常用形式有 2 个：

根据栈帧编号或者栈帧地址，选定要查看的栈帧，语法格式如下：

```text
(gdb) frame spec
```

该命令可以将 spec 参数指定的栈帧选定为当前栈帧。spec 参数的值，常用的指定方法有 3 种：

通过栈帧的编号指定。0 为当前被调用函数对应的栈帧号，最大编号的栈帧对应的函数通常就是 main() 主函数；

借助栈帧的地址指定。栈帧地址可以通过 info frame 命令（后续会讲）打印出的信息中看到；

通过函数的函数名指定。注意，如果是类似递归函数，其对应多个栈帧的话，通过此方法指定的是编号最小的那个栈帧。

除此之外，对于选定一个栈帧作为当前栈帧，GDB 调试器还提供有up 和down两个命令。其中，up命令的语法格式为：

```text
(gdb) up n
```

其中 `n`为整数，默认值为 1。该命令表示在当前栈帧编号（假设为 `m`）的基础上，选定 `m+n`为编号的栈帧作为新的当前栈帧。

相对地，`down` 命令的语法格式为：

(gdb) down n

其中`n`为整数，默认值为 1。该命令表示在当前栈帧编号（假设为 `m`）的基础上，选定`m-n` 为编号的栈帧作为新的当前栈帧。

1. 借助如下命令，我们可以查看当前栈帧中存储的信息：

```text
(gdb) info frame
```

该命令会依次打印出当前栈帧的如下信息：

当前栈帧的编号，以及栈帧的地址；

当前栈帧对应函数的存储地址，以及该函数被调用时的代码存储的地址

当前函数的调用者，对应的栈帧的地址；

编写此栈帧所用的编程语言；

函数参数的存储地址以及值；

函数中局部变量的存储地址；

栈帧中存储的寄存器变量，例如指令寄存器（64位环境中用 rip 表示，32为环境中用eip 表示）、堆栈基指针寄存器（64位环境用 rbp表示，32位环境用 ebp表示）等。

除此之外，还可以使用info args命令查看当前函数各个参数的值；使用info locals命令查看当前函数中各局部变量的值。

**调试正在执行的程序**

如果调试正在执行中的程序，首先需要找到正在运行程序的进程号PID，之后可以用下面三个命令进行调试，进入正常的调试流程。

```text
1) gdb attach PID
2) gdb 文件名 PID
3) gdb -p PID
```

**案例分析**

```text
# ps -aux | grep test           <-- 找到正在运行程序的进程号PID
root     17997  0.0  0.0  12540  1064 pts/0    S+   10:19   0:00 ./test
root     18088  0.0  0.0 112812   972 pts/1    S+   10:20   0:00 grep --color=auto test
    
# gdb attach 17997 -q           <-- 用gdb进行调试
attach: No such file or directory.
Attaching to process 17997
Reading symbols from /root/project/blog/gdb/test...done.
Reading symbols from /lib64/libstdc++.so.6...(no debugging symbols found)...done.
Loaded symbols for /lib64/libstdc++.so.6
Reading symbols from /lib64/libm.so.6...(no debugging symbols found)...done.
Loaded symbols for /lib64/libm.so.6
Reading symbols from /lib64/libgcc_s.so.1...(no debugging symbols found)...done.
Loaded symbols for /lib64/libgcc_s.so.1
Reading symbols from /lib64/libc.so.6...(no debugging symbols found)...done.
Loaded symbols for /lib64/libc.so.6
Reading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.
Loaded symbols for /lib64/ld-linux-x86-64.so.2
0x00007f61ea02b840 in __nanosleep_nocancel () from /lib64/libc.so.6
```

注意，当`GDB`调试器成功连接到指定进程上时，程序执行会暂停。如上所示，程序暂停至第 6 行代码`num++`的位置，此时可以通过断点调试、逐步运行等方式监控程序的执行过程。例如：

```text
(gdb) l                        
warning: Source file is more recent than executable.
1	#include <iostream>
2	#include <unistd.h>
3	using namespace std;
4	
5	int main() {
6	    int sum = 0;
7	    int n = 1;
8	    while (true) {
9	        sum += n;
10	        n++;
(gdb) 
11	        cout << "sum = " << sum << endl;
12	        sleep(1);
13	    }
14	    cout << "sum = " << sum << endl;
15	
16	    return 0;
17	}
18
    
    
(gdb) b 10
Breakpoint 1 at 0x400869: file main.cpp, line 10.
(gdb) c
Continuing.

Breakpoint 1, main () at main.cpp:10
10	        n++;
(gdb) p sum
$1 = 2145
(gdb) c
Continuing.

Breakpoint 1, main () at main.cpp:10
10	        n++;
(gdb) p sum
$2 = 2211
(gdb)
```

注意，当调试完成后，如果想令当前程序进行执行，消除调试操作对它的影响，需手动将 GDB 调试器与程序分离，分离过程分为 2 步：

执行 detach 指令，使GDB调试器和程序分离；

执行 quit（或q）指令，退出GDB调试。

**调试执行异常崩溃的程序**

在Linux操作系统中，当程序执行发生异常崩溃时，系统可以将发生崩溃时的内存数据、调用堆栈情况等信息自动记录下载，并存储到一个文件中，该文件通常称为core 文件，Linux 系统所具备的这种功能又称为核心转储（core dump）。幸运的是，GDB 对core  文件的分析和调试提供有非常强大的功能支持，当程序发生异常崩溃时，通过GDB 调试产生的 core文件，往往可以更快速的解决问题。

**这里就先不写如何设置core dump文件目录了，可以自行了解。**

**写个程序验证一下：**

```text
#include <stdio.h>

int main() {
    char *a = NULL;
    *a = 2;
    
    return 0;
}
```

**编译运行**

```text
$ g++ -g -o test core.cpp 
$ ./test
Segmentation fault (core dumped)      <-- 发生段错误，并生成了 core 文件
```

可以根据生成时间查找`core dump`文件

```text
ls /home/homework/coresave -hl | grep test
-rw-rw-rw- 1 root      root      400K Mar 13 15:08 core.test.27725.1615619332
-rw-rw-rw- 1 root      root      400K Mar 13 15:26 core.test.7791.1615620408
-rw-rw-rw- 1 root      root      540K Mar 11 10:29 core.test.1868.1615429740
-rw-rw-rw- 1 root      root      400K Mar 13 15:07 core.test.26880.1615619264
-rw-rw-rw- 1 root      root      404K Mar  3 19:42 core.test.28802.1614771771
```

**用`gdb`进行调试**

```text
$ gdb test /home/homework/coresave/core.test1.7791.1615620408 -q
Reading symbols from /home/zhudi/project/linux/blog/gdb/test...done.

warning: core file may not match specified executable file.
[New LWP 7791]
Core was generated by `./test'.
Program terminated with signal 11, Segmentation fault.
#0  0x00000000004005bd in main () at core.cpp:5
5	    *a = 2;
```

由此可见，程序崩溃了在第五行，定位到了出现问题的代码位置。

参考博主：

[GDB调试命令详解_小桥流水人家_的博客-CSDN博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_28351609/article/details/114855630%3Fspm%3D1001.2101.3001.6650.2%26utm_medium%3Ddistribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-114855630-blog-80102076.235%5Ev38%5Epc_relevant_sort_base2%26depth_1-utm_source%3Ddistribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-114855630-blog-80102076.235%5Ev38%5Epc_relevant_sort_base2%26utm_relevant_index%3D3)

https://zhuanlan.zhihu.com/p/652799381

## 2. Linux 栈回溯

## 1、ELF

### 1-1、简介

> `ELF, Executable and Linking Format`, 是一种用于可执行文件、目标文件、共享库和核心转储的标准文件格式。  `ELF`格式是是`UNIX`系统实验室作为`ABI（Application Binary Interface）`而开发和发布的。

这里简单介绍一下相关历史:  

- `UNIX`:  最初采用的格式为`a.out`，之后被`System V`中的`COFF`取代，最后则被`SVR4`中的`ELF`格式所取代。
- `Windows`: 采用的则是`COFF`格式的变种`PE格式` 
- `MAC OS X`: 采用的是`Mach-O`格式

`ELF`有四种不同的类型:  

- 可重定位文件(`Relocatable`): 编译器和汇编器产生的`.o`文件，需要被`Linker`进一步处理  
- 可执行文件(`Executable`): 用于提供程序的进程映像，加载的内存执行。
- 共享对象文件(`Shared Object`): 即动态库文件(`.so`)  ，连接器可将它与其它可重定位文件和共享目标文件连接成其它的目标文件，动态连接器又可将它与可执行文件和其它共享目标文件结合起来创建一个进程映像。
- 核心转储文件(`Core File`)

### 1-2、文件格式

为了方便和高效，`ELF`文件内容有两个平行的视角:一个是程序连接角度，另一个是程序运行角度，如图所示。

![img](https://pic1.zhimg.com/80/v2-7491ea6b31a4734d96dd5611c54b3530_720w.webp)

- `ELF header`在文件开始处描述了整个文件的组织，
- `Section`提供了目标文件的各项信息（如指令、数据、符号表、重定位信息等）
- `Program header table`指出怎样创建进程映像，含有每个`program header`的入口
- `section header table`包含每一个`section`的入口，给出名字、大小等信息。

### 1-3、 `elf_header` 

```cpp
//在这个include/linux/elf.h文件中，根据系统使用的框架结构来决定使用 32 位还是 64 位的elf header结构。
#if ELF_CLASS == ELFCLASS32
   extern Elf32_Dyn _DYNAMIC [];
   #define elfhdr          elf32_hdr
   #define elf_phdr        elf32_phdr
   #define elf_shdr        elf32_shdr
   #define elf_note        elf32_note
   #define elf_addr_t      Elf32_Off
   #define Elf_Half        Elf32_Half
#else
   extern Elf64_Dyn _DYNAMIC [];
   #define elfhdr          elf64_hdr
   #define elf_phdr        elf64_phdr
   #define elf_shdr        elf64_shdr
   #define elf_note        elf64_note
   #define elf_addr_t      Elf64_Off
   #define Elf_Half        Elf64_Half
#endif

//详细描述如下：
typedef struct elf32_hdr{
  unsigned char e_ident[EI_NIDENT]; /* ELF "magic number" */
  Elf32_Half    e_type;
  Elf32_Half    e_machine;
  Elf32_Word    e_version;
  Elf32_Addr    e_entry;            /* Entry point */
  Elf32_Off     e_phoff;
  Elf32_Off     e_shoff;
  Elf32_Word    e_flags;
  Elf32_Half    e_ehsize;
  Elf32_Half    e_phentsize;
  Elf32_Half    e_phnum;
  Elf32_Half    e_shentsize;
  Elf32_Half    e_shnum;
  Elf32_Half    e_shstrndx;
} Elf32_Ehdr;

/* ELF "magic number" */
#define ELFMAG0         0x7f            /* EI_MAG */
#define ELFMAG1         'E'
#define ELFMAG2         'L'
#define ELFMAG3         'F'
#define ELFMAG          "\177ELF"
#define SELFMAG         4
```

- `elf32_hdr`(一个52个字节)：

![img](https://pic3.zhimg.com/80/v2-3d84b5bd43345d54128f0564c4a82062_720w.webp)

- `e_ident`:`ident`估计是`identity`的缩写,身份识别的意思. 这是一个总大小为16字节的数据,每个元素是占一个字节的`unsigned char` 

![img](https://pic2.zhimg.com/80/v2-72143512ea7e7b7c00d956a0cf214809_720w.webp)

- `e_type`:表示文件属于下面的哪一种类型

![img](https://pic1.zhimg.com/80/v2-be4aecf09271062c98bc709e09958d7c_720w.webp)

### 1-4、`Section` 

- `.text`: 可执行代码
- `.data`: 已初始化的全局变量
- `.rodata`：只读数据
- `.bss`:  未初始化全局变量，运行时会置0
- `.rel.text, .rel.data, and .rel.rodata`：静态链接的重定位信息
- `.rel.plt`: `The list of elements in the PLT, which are liable to the relocatio during the dynamic linking(if PLT is used)` 
- `.rel.dyn`: `The relocation for dynamically linked functions(if PLT is not used)` 
- `.symtab`: 符号表.记录的则是函数和变量(符号), 主要用于链接时目标文件之间对地址的引用
- `.strtab`: 字符串表.就是记录`ELF`文件中的字符串常量，变量名等等 
- `.shstrtab`: `Section String Table` 段名表
- `.init, .fini`:  程序初始化与终结代码段
- `.interp`: `This section holds the pathname of a program interpreter.For present,this is used to run the run-time dynamic linker to load the program and to link in any required shared libraries.` 
- `.got, .plt`: 动态链接的跳转表和全局入口表.

### 1-5、`loader`程序

```cpp
//输入：ELF文件
//输出：程序入口地址
-1 读入ELF头
-2 程序入口地址 = entry
-3 定位程序头表
-4 for (程序头表中的每一项){
-5     if (Type == Load){
-6        执行装载到内存
-7     }
-8 }
-9 return 程序入口地址

//程序员的自我修养
fork
    -->execve()
        //----kenerl space---------------
        sys_execve()  /*arch\i386\kernel\process*/
            -->do_execve
                -->1.根据名字查找可执行文件
                -->2.读前128bytes，判断格式，search_binary_handle()
                -->3.load_elf_binary (fs\binfmt_elf.c)
                    -->elf文件有效性检测
                    -->寻找interp段，设置动态链接路径
                    -->根据elf程序头表映射
                    -->初始化elf环境
                    -->修改系统调用返回地址为elf可执行文件入口
                -->return
        //----user space---------------
        -->执行指定的elf文件
```

## 2、`binutils` 

1-1、简介

- `GNU Binary Utilities`或`binutils`是一整套的编程语言工具程序，用来处理许多格式的目标文件。当前的版本原本由在`Cygnus Solutions`的程序员以`Binary File Descriptor library（libbfd）`所撰写。这个工具程序通常搭配`GCC`、`make`、和`GDB`这些程序来使用。
- 刚开始时，这个包内只有几个程序，但后来，由于功能需求近似，陆续加入了`GNU`汇编器（`GAS`）和`GNU`链接器（`GLD`）。一般来说，这些程序都很简单，大部分的复杂性都存在于`Binary File Descriptor library`和`libopcodes`这些库里头。

```cpp
//以最简单的源码举例g++ -g -o out helloworld.cpp
#include <iostream>

int g_data = 2022;
char g_bss;
void print_hello() {
	std::cout << "hello world" << std::endl;
	return;
}
int main() {
	print_hello();
	return 0;
}
```

### 2-1、`nm` 

- `nm`用来列出目标文件中的符号，可以帮助程序员定位和分析执行程序和目标文件中的符号信息和它的属性。
- 查看`.data`和`.bss`：`nm --format=sysv hello.so | grep -w .data` 

```bash
gnu nm lists the symbols from object files objfile.... If no object files are listed as arguments, nm assumes the file a.out.

For each symbol, nm shows:

The symbol value, in the radix selected by options (see below), or hexadecimal by default.
The symbol type. At least the following types are used; others are, as well, depending on the object file format. If lowercase, the symbol is usually local; if uppercase, the symbol is global (external). There are however a few lowercase symbols that are shown for special global symbols (u, v and w).

# 过滤出全局变量，可以看到char g_bss占一个字节，int g_data占4个字节;
$ nm --format=sysv ./out | grep -e .bss -e data
...
g_bss               |0000000000004151|   B  |            OBJECT|0000000000000001|     |.bss
g_data              |0000000000004010|   D  |            OBJECT|0000000000000004|     |.data

$ nm --format=sysv ./out | grep -e main -e print_hello
main                |00000000000011dc|   T  |              FUNC|0000000000000014|     |.text
_Z11print_hellov    |00000000000011a9|   T  |              FUNC|0000000000000033|     |.text
```

### 2-2、`objdump` 

- `objdump`用来显示目标文件的信息。可以通过选项控制显示那些特定信息。
- `objdump`一个最大的用处恐怕就是将`C/C++`代码反汇编了. 

```bash
objdump displays information about one or more object files. The options control what particular information to display. This information is mostly useful to programmers who are working on the compilation tools, as opposed to programmers who just want their program to compile and work.

objfile... are the object files to be examined. When you specify archives, objdump shows information on each of the member object files.
The long and short forms of options, shown here as alternatives, are equivalent. At least one option from the list -a,-d,-D,-e,-f,-g,-G,-h,-H,-p,-P,-r,-R,-s,-S,-t,-T,-V,-x must be given.

# 可以看到函数一开始先入栈(push   %rbp, mov    %rsp,%rbp), 结束后再出栈(pop    %rbp)
$ objdump -d out
...
00000000000011a9 <_Z11print_hellov>:
    11a9:       f3 0f 1e fa             endbr64
    11ad:       55                      push   %rbp
    11ae:       48 89 e5                mov    %rsp,%rbp
    11b1:       48 8d 35 4d 0e 00 00    lea    0xe4d(%rip),%rsi        # 2005 <_ZStL19piecewise_construct+0x1>
    11b8:       48 8d 3d 81 2e 00 00    lea    0x2e81(%rip),%rdi        # 4040 <_ZSt4cout@@GLIBCXX_3.4>
    11bf:       e8 cc fe ff ff          callq  1090 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
    11c4:       48 89 c2                mov    %rax,%rdx
    11c7:       48 8b 05 02 2e 00 00    mov    0x2e02(%rip),%rax        # 3fd0 <_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@GLIBCXX_3.4>
    11ce:       48 89 c6                mov    %rax,%rsi
    11d1:       48 89 d7                mov    %rdx,%rdi
    11d4:       e8 c7 fe ff ff          callq  10a0 <_ZNSolsEPFRSoS_E@plt>
    11d9:       90                      nop
    11da:       5d                      pop    %rbp
    11db:       c3                      retq

00000000000011dc <main>:
    11dc:       f3 0f 1e fa             endbr64
    11e0:       55                      push   %rbp
    11e1:       48 89 e5                mov    %rsp,%rbp
    11e4:       e8 c0 ff ff ff          callq  11a9 <_Z11print_hellov>
    11e9:       b8 00 00 00 00          mov    $0x0,%eax
    11ee:       5d                      pop    %rbp
    11ef:       c3                      retq
...
```

### **2-3、`readelf`** 

- `readelf`用来显示`ELF`格式目标文件的信息。可通过参数选项来控制显示哪些特定信息。
- 注意: `readelf`不支持显示`静态库`, 也不支持64位的`ELF`文件。

```bash
readelf displays information about one or more ELF format object files. The options control what particular information to display.

elffile... are the object files to be examined. 32-bit and 64-bit ELF files are supported, as are archives containing ELF files.

This program performs a similar function to objdump but it goes into more detail and it exists independently of the bfd library, so if there is a bug in bfd then readelf will not be affected.
The long and short forms of options, shown here as alternatives, are equivalent. At least one option besides `-v' or `-H' must be given.

# readelf -S -W
-a 查看所有
-h ELF头
-l 程序表头
-S 节头表
-s 符号表

$ readelf -S -W out
There are 31 section headers, starting at offset 0x3c50:

Section Headers:
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        0000000000000318 000318 00001c 00   A  0   0  1
  [ 2] .note.gnu.property NOTE           0000000000000338 000338 000020 00   A  0   0  8
  [ 3] .note.gnu.build-id NOTE           0000000000000358 000358 000024 00   A  0   0  4
  [ 4] .note.ABI-tag     NOTE            000000000000037c 00037c 000020 00   A  0   0  4
  [ 5] .gnu.hash         GNU_HASH        00000000000003a0 0003a0 000028 00   A  6   0  8
  [ 6] .dynsym           DYNSYM          00000000000003c8 0003c8 000138 18   A  7   1  8
  [ 7] .dynstr           STRTAB          0000000000000500 000500 000163 00   A  0   0  1
  [ 8] .gnu.version      VERSYM          0000000000000664 000664 00001a 02   A  6   0  2
  [ 9] .gnu.version_r    VERNEED         0000000000000680 000680 000040 00   A  7   2  8
  [10] .rela.dyn         RELA            00000000000006c0 0006c0 000120 18   A  6   0  8
  [11] .rela.plt         RELA            00000000000007e0 0007e0 000060 18  AI  6  24  8
  [12] .init             PROGBITS        0000000000001000 001000 00001b 00  AX  0   0  4
  [13] .plt              PROGBITS        0000000000001020 001020 000050 10  AX  0   0 16
  [14] .plt.got          PROGBITS        0000000000001070 001070 000010 10  AX  0   0 16
  [15] .plt.sec          PROGBITS        0000000000001080 001080 000040 10  AX  0   0 16
  [16] .text             PROGBITS        00000000000010c0 0010c0 000215 00  AX  0   0 16
  [17] .fini             PROGBITS        00000000000012d8 0012d8 00000d 00  AX  0   0  4
  [18] .rodata           PROGBITS        0000000000002000 002000 000011 00   A  0   0  4
  [19] .eh_frame_hdr     PROGBITS        0000000000002014 002014 00005c 00   A  0   0  4
  [20] .eh_frame         PROGBITS        0000000000002070 002070 000168 00   A  0   0  8
  [21] .init_array       INIT_ARRAY      0000000000003d78 002d78 000010 08  WA  0   0  8
  [22] .fini_array       FINI_ARRAY      0000000000003d88 002d88 000008 08  WA  0   0  8
  [23] .dynamic          DYNAMIC         0000000000003d90 002d90 000200 10  WA  7   0  8
  [24] .got              PROGBITS        0000000000003f90 002f90 000070 08  WA  0   0  8
  [25] .data             PROGBITS        0000000000004000 003000 000014 00  WA  0   0  8
  [26] .bss              NOBITS          0000000000004040 003014 000118 00  WA  0   0 64
  [27] .comment          PROGBITS        0000000000000000 003014 00002a 01  MS  0   0  1
  [28] .symtab           SYMTAB          0000000000000000 003040 000750 18     29  50  8
  [29] .strtab           STRTAB          0000000000000000 003790 0003a5 00      0   0  1
  [30] .shstrtab         STRTAB          0000000000000000 003b35 00011a 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)
```

### **2-4、`addr2line`** 

- 在崩库或者存在需要分析程序调用堆栈的情况下非常有用，`addr2line`可以反编译到代码的特定行。

```bash
addr2line translates addresses into file names and line numbers. Given an address in an executable or an offset in a section of a relocatable object, it uses the debugging information to figure out which file name and line number are associated with it.

The executable or relocatable object to use is specified with the -e option. The default is the file a.out. The section in the relocatable object to use is specified with the -j option.

addr2line has two modes of operation.

In the first, hexadecimal addresses are specified on the command line, and addr2line displays the file name and line number for each address.

In the second, addr2line reads hexadecimal addresses from standard input, and prints the file name and line number for each address on standard output. In this mode, addr2line may be used in a pipe to convert dynamically chosen addresses.

# objdump:  00000000000011a9 <_Z11print_hellov>:
#           00000000000011dc <main>:
# nm:       main                |00000000000011dc|   T  |              FUNC|0000000000000014|     |.text
#           _Z11print_hellov    |00000000000011a9|   T  |              FUNC|0000000000000033|     |.text
$ addr2line -C -f -e out 0x11a9
print_hello()
...
$ addr2line -C -f -e out 0x11dc
main
...
```

### 2-5、`strip` 

- 通过剥离符号表，来达到程序瘦身的效果。

```bash
gnu strip discards all symbols from object files objfile. The list of object files may include archives. At least one object file must be given.

strip modifies the files named in its argument, rather than writing modified copies under different names.

# 瘦身前后，如果你用nm去观察，可以看到少了symbol的部分. 
# 如果用readelf看，少了很多.debug* 和 .symtab 的段
# 不要随便strip，不然core的时候无法调试。可以用objcopy来剥离符号表。
$ ls -l | grep out
-rwxrwxrwx 1 zht2020 zht2020 17424 Jan 24 12:30 out

$ nm --format=sysv ./out | grep g_bss
g_bss               |0000000000004151|   B  |            OBJECT|0000000000000001|     |.bss

$ ls -l | grep out
-rwxrwxrwx 1 zht2020 zht2020 14472 Jan 24 12:51 out

$ nm --format=sysv ./out | grep g_bss
nm: ./out: no symbols
```

### **2-6、objcopy** 

- 将目标文件的一部分或者全部内容拷贝到另外一个目标文件中，或者实现目标文件的格式转换。

```bash
# --only-keep-debug             Strip everything but the debug information
# --strip-debug                 Remove all debugging symbols & sections
# --add-gnu-debuglink=<file>    Add section .gnu_debuglink linking to <file>

# 1、生成调试信息文件out.symbol
objcopy --only-keep-debug out out.symbol

# 2、生成不含调试信息的可执行文件out.strip
objcopy --strip-debug out out.strip

# 3、为不含调试信息的可执行文件,添加调试信息. 
objcopy --add-gnu-debuglink=out.symbol out.strip
```

### **2-6、`ar`** 

- `ar`用于建立、修改、提取静态库文件(`archive`)。`archive`是一个包含多个被包含文件的单一文件（也称之为库文件），其结构保证了可以从中检索并得到原始的被包含文件（称之为`archive`中的`member`）。`member`的原始文件内容、模式（权限）、时间戳、所有者和组等属性都被保存在 `archive`中。`member`被提取后，他们的属性被恢复到初始状态。
- `ar`主要用于创建`C`库文件。典型用法如：`$ ar rv libNAME.a file1.o file2.o`

```bash
     ar [-]p[mod] [--plugin name] [--target bfdname] [relpos] [count] archive [member...]
     ar -M [ <mri-script ]
The gnu ar program creates, modifies, and extracts from archives. 
An archive is a single file holding a collection of other files in a structure that 
makes it possible to retrieve the original individual files (called members of the archive). 

#创建静态库：
ar -rcs test.a *.o
#查看静态库：
ar -tv test.a
#解压静态库：
ar -x test.a
 
#查看程序依赖的动态库：
readelf -a xxx|grep library
#如：可以看到，下面的交叉程序hello执行依赖于如下两个动态库。
rebi@ubuntu:~/test$ arm-none-linux-gnueabi-readelf -a hello|grep "library"
 0x00000001 (NEEDED)                     Shared library: [libgcc_s.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
```

### **2-7、`ld`** 

- `ld`是链接器，通常由`GCC/G++`调用。外部基本不可见。

### **2-8、`c++filt`** 

- 用于反混淆`c++`变量或函数名称的，可以还原为人类可读的格式。通常这个过程称为反混淆`-demangle`。

```bash
# 00000000000011a9 <_Z11print_hellov>:
$ c++filt _Z11print_hellov
print_hello()
```

### 2-9、`size` 

```bash
The gnu size utility lists the section sizes—and the total size—for each of the object or archive files objfile in its argument list. By default, one line of output is generated for each object file or each module in an archive.

objfile... are the object files to be examined. If none are specified, the file a.out will be used.

# 可以看到out的分布，对裁剪flash有参考价值；
$ size out
   text    data     bss     dec     hex filename
   2511     668     280    3459     d83 out
```

## 3、栈回溯原理

```cpp
int main() {
	print_hello();
}
//MOV AX，BX；将BX寄存器的16位数据传送到AX寄存器
00000000000011a9 <_Z11print_hellov>:
    11a9:       f3 0f 1e fa             endbr64
    11ad:       55                      push   %rbp
    11ae:       48 89 e5                mov    %rsp,%rbp
...
    11da:       5d                      pop    %rbp
    11db:       c3                      retq
00000000000011dc <main>:
    11dc:       f3 0f 1e fa             endbr64
    11e0:       55                      push   %rbp
    11e1:       48 89 e5                mov    %rsp,%rbp
    11e4:       e8 c0 ff ff ff          callq  11a9 <_Z11print_hellov>
    11e9:       b8 00 00 00 00          mov    $0x0,%eax
    11ee:       5d                      pop    %rbp
    11ef:       c3                      retq
```

![img](https://pic1.zhimg.com/80/v2-23d43ffa42b4b0e61f34c636011c6c14_720w.webp)

### 3-1、`frame pointer` 

- 在调试的时候经常需要进行堆栈回溯。最简单的方式是使用一个独立的寄存器(`ebp`)来保存每层函数调用的堆栈栈顶(`frame pointer`)

![img](https://pic3.zhimg.com/80/v2-a4bb8a923bf06e732965c45e1fa5e83a_720w.webp)

x86_64的frame point模式

![img](https://pic1.zhimg.com/80/v2-a5bbcfba5357f9189d652ce9763ba8b0_720w.webp)

arm64的frame point模式

这种方式在堆栈回溯时非常方便快捷。但是这种方法也有自己的不足：

- 需要一个专门寄存器`ebp`来保存`frame poniter`。
- 保存`ebp`寄存器即保存回溯信息(`unwind info`)的动作会被编译成代码，有指令开销。
- 在回溯堆栈时，除了恢复`sp`，不知道怎么恢复其他的寄存器。(例如`gdb`中的 `frame n, info reg`)
- 没有源语言信息。

### 3-2、`.debug_frame (DWARF)` 

调试信息标准`DWARF(Debugging With Attributed Record Formats)`定义了一个`.debug_frame` section用来解决上述的难题。

- 可以把`ebp`当成常规寄存器使用。
- 但是当保存`esp`时，它必须在`.debug_frame`节中产生一条注释，告知调试器它将其保存在什么位置以及存放在何处。
- 这种机制还有的好处是它不仅仅是用来恢复`ebp`，还可以用来恢复其他寄存器。
- 而且是带外的，不消耗任何指令周期，没有任何性能开销。

这种机制也有其不足：

- 没有源语言信息。
- 不支持在程序加载时同时加载调试信息。

### 3-3、`.eh_frame (LSB)` 

现代`Linux`操作系统在`LSB(Linux Standard Base)`标准中定义了一个`.eh_frame` section来解决上述的难题。这个section和`.debug_frame`非常类似，但是它解决了上述难题：

- 拥有源语言信息。
- 编码紧凑，并随程序一起加载。

但是`.debug_frame`和`.eh_frame`同时面临一个难题：怎么样生成堆栈信息表？

### 3-4、`CFI directives` 

- 为了解决上述难题，`GAS(GCC Assembler)`汇编编译器定义了一组伪指令来协助生成调用栈信息`CFI(Call Frame Information)`。
- `CFI directives`伪指令是一组生成`CFI`调试信息的高级语言
- 关于汇编器利用这些伪指令来生成`.debug_frame`还是`.debug_frame`，在`.cfi_sections`指令中定义。如果只是调试需求可以生成`.debug_frame`，如果需要在运行时调用需要生成`.eh_frame`。

### 3-5、`.eh_frame`基础 

- 使用`gcc -g`生成的`DWARF`信息存储在`debug_*`类型的`section`，
- 我们可以使用`readelf -wi xxx`查看`debug_info`段，或者`dwarfdump xxx`查看`debug`信息。
- 无论是否有`-g`选项，`gcc`默认都会生成`.eh_frame`和`.eh_frame_hdr` `section`。
- `-fno-asynchronous-unwind-tables`选项可以禁止生成`.eh_frame`和`.eh_frame_hdr` `section`。

```bash
$ readelf -S -W out
...
  [19] .eh_frame_hdr     PROGBITS        0000000000002014 002014 00005c 00   A  0   0  4
  [20] .eh_frame         PROGBITS        0000000000002070 002070 000168 00   A  0   0  8
...
```

- 在`LSB(Linux Standard Base)`中对`.eh_frame`格式有详细的描述。
- `.eh_frame section` 包含一个或者多个`CFI(Call Frame Information)`记录。每个`CFI`包含一个`CIE(Common Information Entry Record)`记录，每个`CIE`包含一个或者多个`FDE(Frame Description Entry)`记录。
- 通常情况下，`CIE`对应一个文件，`FDE`对应一个函数。

### 3-6、`.eh_frame` 解析信息

- 可以看到`.eh_frame`总体架构就是由`CIE`和`FDE`组成的。
- 其中最核心的就是`FDE`的组织，读懂它条目的所有字段基本就理解了`unwind`的含义
- `CFA (Canonical Frame Address, which is the address of %rsp in the caller frame)`，`CFA`就是上一级调用者的堆栈指针。

```bash
$ readelf -wF a.out 
Contents of the .eh_frame section:

00000000 0000000000000014 00000000 CIE "zR" cf=1 df=-8 ra=16
   LOC           CFA      ra    
0000000000000000 rsp+8    u     
...
000000c8 0000000000000044 0000009c FDE cie=00000030 pc=00000000000006b0..0000000000000715
   LOC           CFA      rbx   rbp   r12   r13   r14   r15   ra    
00000000000006b0 rsp+8    u     u     u     u     u     u     c-8   
00000000000006b2 rsp+16   u     u     u     u     u     c-16  c-8   
00000000000006b4 rsp+24   u     u     u     u     c-24  c-16  c-8   
00000000000006b9 rsp+32   u     u     u     c-32  c-24  c-16  c-8     
...   
0000000000000714 rsp+8    c-56  c-48  c-40  c-32  c-24  c-16  c-8 
```

![img](https://pic4.zhimg.com/80/v2-6b618711995dadfd18b6cc7b294b1853_720w.webp)

上图详细说明了怎么样利用`.eh_frame`来进行栈回溯：

- 根据当前的`PC`在`.eh_frame`中找到对应的条目，根据条目提供的各种偏移计算其他信息。
- 首先根据`CFA = rsp+8`，把当前`rsp+8`得到`CFA`的值。再根据`CFA`的值计算出通用寄存器和返回地址在堆栈中的位置。
- 通用寄存器栈位置计算。例如：`rbx = CFA-56`。
- 返回地址`ra`的栈位置计算。`ra = CFA-8`。
- 根据`ra`的值，重复步骤1到4，就形成了完整的栈回溯。

### 3-7、`.eh_frame`原始信息

```bash
# 也可以使用readelf -wf xxx命令来查看elf文件中的.eh_frame原始信息
$ readelf -wf a.out 
...
 
000000c8 0000000000000044 0000009c FDE cie=00000030 pc=00000000000006b0..0000000000000715
  DW_CFA_advance_loc: 2 to 00000000000006b2
  DW_CFA_def_cfa_offset: 16
  DW_CFA_offset: r15 (r15) at cfa-16
...
```

- 使用`readelf -wF xxx`命令解析了这些信息，我们初步看看对应关系：

![img](https://pic3.zhimg.com/80/v2-4d4909aaa53d4f32e70abc0e2588fc32_720w.webp)

### 3-8、`.eh_frame`的加载

- 内核`vmlinux`也是一个`elf`文件，它编译完成后默认也生成了`.eh_frame`和`.eh_frame_hdr`section。这两个段运行的时候被一起加载到内存，运行的时候需要有方法能找到它们。
- 内核在链接脚本`vmlinux.lds.h`中制定了定义：`__start_unwind_hdr`和`__end_unwind_hdr`变量用来标识`.eh_frame_hdr`的位置，`__start_unwind`和`__end_unwind`变量用来标识`.eh_frame`的位置。
- 在系统启动时，把内核的`.eh_frame`和`.eh_frame_hdr`section当成一张`table`管理起来
- 驱动模块在加载的时候也需要把自己的`.eh_frame`加进来，接口函数`unwind_add_table()`，这样就形成了一张`unwind`信息`table`链表
- 通常我们调用`dump_stack()`来打印出内核的当前调用栈

```cpp
//kernel\include\asm-generic\vmlinux.lds.h
#ifdef CONFIG_STACK_UNWIND
#define EH_FRAME							\
		/* Unwind data binary search table */			\
		. = ALIGN(8);						\
		.eh_frame_hdr : AT(ADDR(.eh_frame_hdr) - LOAD_OFFSET) {	\
			VMLINUX_SYMBOL(__start_unwind_hdr) = .;		\
			*(.eh_frame_hdr)				\
			VMLINUX_SYMBOL(__end_unwind_hdr) = .;		\
		}							\
		/* Unwind data */					\
		. = ALIGN(8);						\
		.eh_frame : AT(ADDR(.eh_frame) - LOAD_OFFSET) {		\
			VMLINUX_SYMBOL(__start_unwind) = .;		\
			*(.eh_frame)					\
			VMLINUX_SYMBOL(__end_unwind) = .;		\
		}
#else
#define EH_FRAME
#endif

//start_kernel()
void __init unwind_init(void)
{
	init_unwind_table(&root_table, "kernel",
	                  _text, _end - _text,
	                  NULL, 0,
	                  __start_unwind, __end_unwind - __start_unwind,
	                  __start_unwind_hdr, __end_unwind_hdr - __start_unwind_hdr);
}
```

## 4、栈回溯方式

- `gcc`的`-g`，应该没有人不知道它是一个调试选项，因此在一般需要进行程序调试的场景下，我们都会加上该选项，并且根据调试工具的不同，还能直接选择更有针对性的说明，比如`-g gdb`。`-g`是一个编译选项，即在源代码编译的过程中起作用，让`gcc`把更多调试信息（也就包括符号信息）收集起来并将存放到最终的可执行文件内。
- `-rdynamic`却是一个连接选项，它将指示连接器把所有符号（而不仅仅只是程序已使用到的外部符号，但不包括静态符号，比如被`static`修饰的函数）都添加到动态符号表（即`.dynsym`表）里，以便那些通过`dlopen()`或`backtrace()`（这一系列函数使用`.dynsym`表内符号）这样的函数使用。

### 4-1、注册信号 

- 关于信号处理`signal()`、`sigaction()`等的使用。 一个常见陷阱：**信号处理函数必须是可重入函数。如果信号处理函数不可重入，那么可能导致很多诡异问题**。

> 《UNIX环境高级编程》`可重入函数`章节中这样写道：
> 但在信号处理程序中，不能判断捕捉到信号时进程在何处执行。如果进程正在执行`malloc`，在其堆中分配另外的存储空间，而此时由于捕捉到信号而插入执行该信号处理程序，其中又调用`malloc`，这时会发生什么？

- 关于`可重入函数`相信其概念并不难理解，但真正使用信号时，很多人都忽略了这一点，特别是一些比较隐晦的`不可重入函数`。在项目中可能遇到信号处理函数中调用不可重入函数导致的[死锁](https://link.zhihu.com/?target=https%3A//so.csdn.net/so/search%3Fq%3D%E6%AD%BB%E9%94%81%26spm%3D1001.2101.3001.7020)：某项目运行一段时间后，进程基本停止响应各种外界命令，日志也基本停止打印(只有个别简单轮询线程定时打印些信息)，但`ps`命令看到进程还在运行。看到这个问题，第一反应就是进程死锁，`gdb attach`到进程上，查看各个线程的堆栈，果然, 很多线程都卡在`malloc`调用上.

```cpp
#include <signal.h>

//忽略部分信息信号
static void signalIgnore(void)
{
    (void)signal(SIGPIPE, SIG_IGN); 
    (void)signal(SIGTTIN, SIG_IGN);
    (void)signal(SIGTTOU, SIG_IGN);
}

//回调处理
static void stop_proc(int SIGNO, siginfo_t *info, void *ctx)
{
     do_backtrace();
     ...
}

//拦截信号处理
static void signalCap(void)
{
    struct sigaction sa;
    sa.sa_sigaction = stop_proc;
    sa.sa_flags = SA_SIGINFO;
    sigemptyset(&sa.sa_mask);
    
    sigaction(SIGINT, &sa, nullptr);
    sigaction(SIGSEGV, &sa, nullptr);
    sigaction(SIGTERM, &sa, nullptr);
    sigaction(SIGBUS, &sa, nullptr);  
}
int main()
{
    signalIgnore();
    signalCap();
    ...
    return 0;
}

//SIGINT     2     /* Interrupt (ANSI).  */                     终止进程     中断进程 Ctrl+C
//SIGBUS     7     /* BUS error (4.2 BSD).  */                  建立CORE文件,总线错误
//SIGFPE     8     /* Floating-point exception (ANSI).  */      建立CORE文件,浮点异常
//SIGSEGV    11    /* Segmentation violation (ANSI).  */        建立CORE文件,段非法错误
//SIGPIPE    13    /* Broken pipe (POSIX).  */                  终止进程     向一个没有读进程的管道写数据
//SIGTERM    15    /* Termination (ANSI).  */                   终止进程     软件终止信号
//SIGTTIN    21    /* Background read from tty (POSIX).  */     停止进程     后台进程读终端
//SIGTTOU    22    /* Background write to tty (POSIX).  */      停止进程     后台进程写终端
```

### 4-2、gcc

```cpp
//gcc提供了__builtin_return_address() 宏来做栈的回溯
void do_backtrace()
{
    void *pc0 = __builtin_return_address(1);
    void *pc1 = __builtin_frame_address(0);
    ...
}
```

### 4-3、`glibc` 

```cpp
//glibc提供了一对函数backtrace()和backtrace_symbols()来回溯栈信息：
//backtrace函数是通过读取操作系统的一个全局信息区，在多线程并发调用时，会造成严重的锁冲突。
#include <execinfo.h>
 
#define BACKTRACE_SIZ   20
void do_backtrace()
{
    void    *array[BACKTRACE_SIZ];
    size_t   size;
    char   **strings = nullptr;
 
    size = backtrace(array, BACKTRACE_SIZ);

    //推荐直接写文件：backtrace_symbols_fd(array, size, 2); (dladdr)
    strings = backtrace_symbols(array, size);
 
    for (size_t i = 0; i < size; i++) {
        printf("%p : %s\n", array[i], strings[i]);
    }
 
    free(strings);  // malloced by backtrace_symbols
}
```

### 4-4、`libunwind` 

```cpp
//https://github.com/ehsan/libunwind
//./configure --prefix=./install --host=aarch64-linux-gnu
//make
//make install
// FLAGS += -lunwind
// FLAGS += -lunwind-aarch64 
#include <libunwind.h>
 
void do_backtrace()
{
    unw_cursor_t    cursor;
    unw_context_t   uc;
    unw_word_t  offset, ip, sp;
    
    char name[256] = {0};

    unw_getcontext(&uc);
    unw_init_local(&cursor, &uc);

    do
    {
        unw_get_reg(&cursor, UNW_REG_IP, &ip);
        unw_get_reg(&cursor, UNW_REG_SP, &sp);
        buf[0] = '\0';

        (void) unw_get_proc_name(&cursor, name, sizeof(name), &offset);
        printf ("%p : (%s+0x%x) [%p]\n", ip, name, offset, sp);

        (void) unw_get_proc_info(&cursor, &pi);
        printf("start(0x%x) end(0x%x) handler(0x%x) lsda(0x%x) gp(0x%x)\n",
               (long)pi.start_ip, pi.end_ip, pi.handler, pi.lsda, pi.gp);
    } while (unw_step(&cursor) > 0);
}
```

### 4-5、自定义回溯

```cpp
//如果源代码编译时使用了-O1或-O2优化选项，可执行代码会把ebp/rbp/rsp寄存器当作普通寄存器使用，导致backtrace失败。
//为了防止这种情况发生，可以在编译时使用-O2  -fno-omit-frame-pointer  或-Og 来避免优化中使用上述寄存器。
#define STACKCALL __attribute__((regparm(1),noinline))  
void ** STACKCALL getEBP(void){  
        void **ebp=NULL;  
        __asm__ __volatile__("mov %%rbp, %0;\n\t"  
                    :"=m"(ebp)      /* 输出 */  
                    :               /* 输入 */  
                    :"memory");     /* 不受影响的寄存器 */  
        return (void **)(*ebp);  
}  
  
int my_backtrace(void **buffer,int size)
{        
    int frame=0;  
    void ** ebp;  
    void **ret=NULL;  
    unsigned long long func_frame_distance=0;  

    if (buffer != NULL && size > 0)  
    {  
        ebp = getEBP();  
        func_frame_distance = (unsigned long long)(*ebp) - (unsigned long long)ebp;  
        while(ebp && frame < size &&
              (func_frame_distance < (1ULL << 24)) &&  //assume function ebp more than 16M  
              (func_frame_distance > 0))  
        {  
            ret = ebp + 1;  
            buffer[frame++] = *ret;  
            ebp = (void**)(*ebp);  
            func_frame_distance = (unsigned long long)(*ebp) - (unsigned long long)ebp;  
        }  
    }  
    return frame;  
}  
```

### 4-6、根据地址找到函数

```bash
# 1、拿到地址

# 2、获取maps
cat /proc/<pid>/maps

# 3、根据地址找到对应的库(如libapp.so), 并计算偏移地址<offset>

# 4-1、根据地址在符号表(程序)中找到函数
addr2line -C -f -e libapp.so.symbol <offset>

# 4-2、或获取符号表的消息，全局搜<offset>
nm -a libapp.so.symbol | grep <offset>

# 4-3、或者反汇编程序app，然后全局搜<offset>
aarch64-linux-gun-objdump -d app | grep <offset>
```

## 5、参考

[GNU Binutils简介及基本用法](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/tocy/p/gnu-binutils-simple-usage.html)

[www.cnblogs.com/tocy/p/gnu-binutils-simple-usage.html](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/tocy/p/gnu-binutils-simple-usage.html)

[GNU Binary Utilities](https://link.zhihu.com/?target=https%3A//sourceware.org/binutils/docs-2.28/binutils/index.html)

[sourceware.org/binutils/docs-2.28/binutils/index.html](https://link.zhihu.com/?target=https%3A//sourceware.org/binutils/docs-2.28/binutils/index.html)

[http://www.skyfree.org/linux/references/ELF_Format.pdf](https://link.zhihu.com/?target=http%3A//www.skyfree.org/linux/references/ELF_Format.pdf)

[www.skyfree.org/linux/references/ELF_Format.pdf](https://link.zhihu.com/?target=http%3A//www.skyfree.org/linux/references/ELF_Format.pdf)

[Linux ELF格式分析 - zzfx - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/feng9exe/p/6899351.html)

[www.cnblogs.com/feng9exe/p/6899351.html![img](https://pic1.zhimg.com/v2-2d619cde2ab01846aaa0d6c262a40c0c_180x120.jpg)](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/feng9exe/p/6899351.html)

[Linux ELF文件格式分析_谢健的专栏-CSDN博客_elf linux](https://link.zhihu.com/?target=https%3A//blog.csdn.net/xj178926426/article/details/72825630)

[blog.csdn.net/xj178926426/article/details/72825630![img](https://pic1.zhimg.com/v2-dce3b4ee6faf8685a64ca2e5cfe6a824_ipico.jpg)](https://link.zhihu.com/?target=https%3A//blog.csdn.net/xj178926426/article/details/72825630)

[Unwind 栈回溯详解：libunwind](https://link.zhihu.com/?target=https%3A//blog.csdn.net/Rong_Toa/article/details/110846509)

[blog.csdn.net/Rong_Toa/article/details/110846509![img](https://pic1.zhimg.com/v2-8bfc7607490a17f5a9ea79ee5c29160c_180x120.jpg)](https://link.zhihu.com/?target=https%3A//blog.csdn.net/Rong_Toa/article/details/110846509)

[高效获得Linux函数调用栈/backtrace的方法_颇锐克-CSDN博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/prike/article/details/49965113)

[blog.csdn.net/prike/article/details/49965113![img](https://pic4.zhimg.com/v2-5be23e9ad9bbd7ede7cbaa1fed20fe57_ipico.jpg)](https://link.zhihu.com/?target=https%3A//blog.csdn.net/prike/article/details/49965113)

[The libunwind project](https://link.zhihu.com/?target=https%3A//www.nongnu.org/libunwind/)

[www.nongnu.org/libunwind/](https://link.zhihu.com/?target=https%3A//www.nongnu.org/libunwind/)

[ARM Linux 手写实现栈回溯](https://link.zhihu.com/?target=https%3A//blog.csdn.net/Chasing_Chasing/article/details/87161427)

[blog.csdn.net/Chasing_Chasing/article/details/87161427![img](https://pic4.zhimg.com/v2-73b7bc674caa5289995e5c25db13dcc3_120x160.jpg)](https://link.zhihu.com/?target=https%3A//blog.csdn.net/Chasing_Chasing/article/details/87161427)

[谈谈Linux的栈回溯与妙用_函数](https://link.zhihu.com/?target=https%3A//www.sohu.com/a/256793414_467784)

[www.sohu.com/a/256793414_467784![img](https://pic1.zhimg.com/v2-885bc8ca5f9a7618065509db856ae8d8_180x120.jpg)](https://link.zhihu.com/?target=https%3A//www.sohu.com/a/256793414_467784)



https://zhuanlan.zhihu.com/p/460686470



# 第四章：图形显示

## 1. Framebuffer 概念

前言

这一章主要学习的了解FrameBuffer的使用，熟悉字符的编码格式，以及如何在LCD上显示一个字符和一行字符串。（本文并没有使用开发板，所有图片均来自网络）
一、为什么要使用FrameBuffer

Linux下的FrameBuffer是一种图形显示子系统，它允许用户对图形硬件进行低级别的访问，以便在屏幕上显示图形。FrameBuffer支持许多不同类型的图形硬件，并提供了一个称为/dev/fb的设备节点，用户可以通过该节点与硬件进行交互。FrameBuffer控制屏幕上的每个像素，允许图形应用程序在屏幕上绘制图像。它也支持像素级的操作，例如图像旋转、缩放和移动。由于FrameBuffer在硬件级别操作，因此它比传统的X窗口系统更快和更稳定，特别是在较慢的嵌入式设备上。总之，Linux FrameBuffer提供了一种在Linux系统上直接控制图形硬件的方法，使用户能够更快、更准确地将图形输出到屏幕上。
FrameBuffer的操作原理

LCD Framebuffer 就是一块显存，在嵌入式系统中，显存是被包含在内存中。LCD Framebuffer里的若干字节（根据驱动程序对LCD控制器的配置而定）表示LCD屏幕中的一个像素点，一一对应整个LCD屏幕。举个例子，LCD屏幕是800*600的分辨率，即LCD屏幕存在480000个像素点，若每个像素点4个字节表示，那么LCD Framebuffer显存大小为480000 *4=960000字节，即1.92MB。因此我们的内存将会分割至少1.92MB的空间用作显存。具体地址在哪里，这个就是又驱动程序去定，应用程序只需直接使用即可，硬件相关操作已由驱动程序封装好。
在这里插入图片描述
 如上图，我们只需要往Framebuffer中填入不同的值，驱动程序和硬件控制器就会把这些数据传输到对应LCD屏幕上的像素点，从而显示不同的颜色。由此可知，我们应用程序只需要针对Framebuffer操作即可，其他交给驱动程序和硬件。
常用的API函数接口：
1.open

在这里插入图片描述
在上一章已经讲解过这个函数的作用了，具体参数以及返回值不再叙述。
文件IO
2.ioctl函数

在这里插入图片描述
参数	说明
fd	表示文件描述符
request	表示与驱动程序交互的命令，用不同的命令控制驱动程序输出我们需要的数据
…	表示可变参数arg，根据request命令，设备驱动程序返回输出的数据

在Linux系统中，ioctl()函数是用来发送控制命令给设备的系统调用接口。它是设备驱动程序的一个重要部分，通过该函数进行设备的初始化、控制、配置以及获取设备状态等相关操作。在使用FrameBuffer时，可以利用ioctl()函数发送一些控制命令，来设置FrameBuffer的一些属性，例如分辨率、颜色格式、可见区域等，从而实现对图形输出的控制。
3.mmap函数

在这里插入图片描述
参数	说明
addr	表示指定映射的內存起始地址，通常设为 NULL表示让系统自动选定地址，并在成功映射后返回该地址；
length	表示将文件中多大的内容映射到内存中
prot	表示映射区域的保护方式
Flags	表示影响映射区域的不同特性

prot :
①PROT_EXEC 映射区域可被执行
②PROT_READ 映射区域可被读写
③PROT_WRITE 映射区域可被写入
④PROT_NONE 映射区域不能存取
Flags :
①MAP_SHARED 表示对映射区域写入的数据会复制回文件内，原来的文件会改变。
②MAP_PRIVATE 表示对映射区域的操作会产生一个映射文件的复制，对此区域的任何修改都不会写回原来的文件内容中。
返回值：若成功映射，将返回指向映射的区域的指针，失败将返回-1。

在 Linux 中，mmap() 函数用于将一个文件或者其它对象映射到内存中，以便可以使用指针进行访问。它提供了一种非常高效的文件 I/O 方法，使用它可以避免大量的磁盘 I/O 操作，提高系统的 I/O 性能。
二、LCD描点步骤
点阵理论基础

在这里插入图片描述
如上图，当我们需要显示一个字母‘A’时，是通过判断点阵的每一个位数值状态，来填充颜色，达到显示字符效果。其中‘1’表示一种颜色，‘0’表示填充另一种颜色。上图的是8*16的点阵，我们也可以用其他不同大小点阵，只要有这个点阵，我们就可以在LCD上面描点，达到显示字符的效果。
获取fb_var_screeninfo结构体
在用点阵显示字符之前，我们需要先从设备fb0中获取相关的LCD信息
在这里插入图片描述
通过系统调用ioctl，获取xres(x方向总像素点)，yres（y方向总像素点），bits_per_pixel（每个像素点占据的位数），根据获取的三个资源，外加点阵，根据这四个资源，我们就可以显示一个字符。
知道了这些信息后，我们就可以实现显示字符了。代码如下:

	fd_fb = open("/dev/fb0", O_RDWR);
	if (fd_fb < 0)
	{
		printf("can't open /dev/fb0\n");
		return -1;
	}
	if (ioctl(fd_fb, FBIOGET_VSCREENINFO, &var))
	{
		printf("can't get var\n");
		return -1;
	}	
	
	1
	2
	3
	4
	5
	6
	7
	8
	9
	10
	11

先打开LCD设备（fb0），获得文件描述符，再通过ioctl获取fb_var_screeninfo信息并保存在var变量，后续只需访问var这个结构体，就可以获得xres(x方向总像素点)，yres（y方向总像素点），bits_per_pixel（每个像素点占据的位数）这三个关于fb0的资源
接下来就是根据这些信息计算变量
根据fb_var_screeninfo计算变量

fb_var_screeninfo已保存在var结构体变量中，接着来访问var结构体变量即可
根据xres与bits_per_pixel算出每行像素点所占据的字节数

line_width  = var.xres * var.bits_per_pixel / 8;
//line_width 也就是行宽度，也就是x的分辨率*字节，这就算出了每行像素点所占据的字节数

    1
    2

根据bits_per_pixel算出每个像素点所占据的字节数

 pixel_width = var.bits_per_pixel / 8;
 //pixel_width 也就是像素点的宽度，每一个像素点占多少位/8即为字节

    1
    2

最后根据xres，yres，bits_per_pixel算出全部像素点所占据的字节总和

 screen_size = var.xres * var.yres * var.bits_per_pixel / 8;
 //screen_size 屏幕所需字节大小
 //var.xres * var.yres这个是求面积公式，获得整个屏幕所需多大，与var.bits_per_pixel / 8相乘计算出屏幕所需多少字节

    1
    2
    3

获得屏幕参数和求出了所需的字节大小了，我们接下来就对内存操作，也就是真正意义上操作FrameBuffer

fbmem = (unsigned char *)mmap(NULL , screen_size, PROT_READ | 			PROT_WRITE, MAP_SHARED, fd_fb, 0);
	if (fbmem == (unsigned char *)-1)
	{
		printf("can't mmap\n");
		return -1;
	}
	/* 清屏: 全部设为黑色 */
	memset(fbmem, 0, screen_size);

    1
    2
    3
    4
    5
    6
    7
    8

调用mmap将显存映射在内存中，以可读可写（PROT_READ | PROT_WRITE）及内存回写（MAP_SHARED）的方式映射，从而获得一个指向映射在内存空间的首地址fbmem，后续操作就是在这个首地址的基础上计算各种不同的偏移量，填充颜色值。
到这里就是已经可以控制内存来显示我们所要展示的字符了，接下来看一下描点函数。
描点函数编写

描点函数有3个参数，x坐标，y坐标，像素点颜色值。

    void lcd_put_pixel(int x, int y, unsigned int color)

unsigned char *pen_8 = fbmem+y*line_width+x*pixel_width;
unsigned short *pen_16;	
unsigned int *pen_32;	
unsigned int red, green, blue;	
pen_16 = (unsigned short *)pen_8;
pen_32 = (unsigned int *)pen_8;

    1
    2
    3
    4
    5
    6
    7

在此处函数参数x与y表示的是像素点的坐标，而单个像素点所占据的显存大小可能会有不同的情况出现，如1字节表示一个像素点，2字节表示一个像素点，4字节表示一个像素点等，为了更多的兼容不同的情况，因此申请3个指针，pen_8指向的是占据1个字节的像素点空间, pen_16指向的是占据2个字节的像素点空间，pen_32指向的是占据4个字节的像素点空间。
fbmem是系统调用mmap返回的显存首地址，根据fbmem计算填充颜色的内存空间
当像素点占据1个字节空间时
对应描点地址= fbmem+Y * 一行所占据的字节数 + x * 每个像素点所占据的字节数

	switch (var.bits_per_pixel)
		{
			case 8:
			{
				*pen_8 = color;
				break;
			}
			case 16:
			{
				/* 565 */
				red   = (color >> 16) & 0xff;
				green = (color >> 8) & 0xff;
				blue  = (color >> 0) & 0xff;
				color = ((red >> 3) << 11) | ((green >> 2) << 5) | (blue >> 3);
				*pen_16 = color;
				break;
			}
			case 32:
			{
				*pen_32 = color;
				break;
			}
			default:
			{
				printf("can't surport %dbpp\n", var.bits_per_pixel);
				break;
			}
		}
	}
	
	1
	2
	3
	4
	5
	6
	7
	8
	9
	10
	11
	12
	13
	14
	15
	16
	17
	18
	19
	20
	21
	22
	23
	24
	25
	26
	27
	28
	29

根据设备fb0实际的bits_per_pixel值，选择对应的pen（pen_8，pen_16，pen_32其中一个），最后把color颜色变量传入选择的pen中，这就完成了对LCD描点的操作。
三、在LCD上使用点阵写字
在LCD上显示英文字母

①找出英文字母在点阵数组中的地址，c所代表的是一个英文字母（ASCII值）。(英文的点阵数组在Linux中已经存在了，所以无需下载)

unsigned char *dots = (unsigned char *)&fontdata_8x16[c*16];
//fontdata_8x16就是存在在Linux中的点阵数组，c是要显示的字符，因为每一个字符需要16个字节来显示，所以用c*16确定字符的位置

    1
    2

②根据获得的英文字母点阵，每一位依次判断，描点，‘1’表示白色，‘0’表示黑色。
在这里插入图片描述
根据上图，我们分析下如何利用点阵在LCD上显示一个英文字母，因为有十六行，所以首先要有一个循环16次的大循环，然后每一行里有8位，那么在每一个大循环里也需要一个循环8次的小循环，小循环里的判断单行的描点情况，如果是1，就填充白色，如果是0就填充黑色，如此一来，就可以显示出黑色底，白色轮廓的英文字母

	for (i = 0; i < 16; i++)
		{
			byte = dots[i];
			for (b = 7; b >= 0; b--)
			{
				if (byte & (1<<b))
				{
					/* show */
					lcd_put_pixel(x+7-b, y+i, 0xffffff); /* 白 */
				}
				else
				{
					/* hide */
					lcd_put_pixel(x+7-b, y+i, 0); /* 黑 */
				}
			}
	}
	
	1
	2
	3
	4
	5
	6
	7
	8
	9
	10
	11
	12
	13
	14
	15
	16
	17

③调用我们编写的lcd_put_ascii函数

lcd_put_ascii(var.xres/2, var.yres/2, 'A'); /*在屏幕中间显示8*16的字母A*/

    1

④编译c文件show_ascii.c
编译命令：arm-linux-gnueabihf-gcc -o show_ascii show_ascii.c
交叉编译工具链的知识
在linux上gcc编译出来的适用于x86架构，不适用的ARM架构的
所以要想让代码运行在ARM架构，我们需要使用不同的编译工具链
⑤将编译出来的show_ascii传输到开发板，并进入show_ascii的目录下
执行命令：./show_ascii
如果实验成功，我们将看到屏幕中间会显示出一个白色的字母‘A’。
在LCD上显示汉字

在这里插入图片描述
与显示英文字母有点不同，因为汉字的点阵我们是需要通过汉字库提取出来，并没有直接提供点阵数组，因此我们程序开头需要打开汉字库文件(HZK16)，然后再找到相应的位置，提取出汉字的点阵，最后再按显示英文字母一样显示它，不过这个汉字是16*16的。
① 打开汉字库文件

fd_hzk16 = open("HZK16", O_RDONLY);

    1

② 获取汉字库文件的属性，存在hzk_stat结构体变量中

if(fstat(fd_hzk16, &hzk_stat))
//获取文件的大小，存储在hzk_stat变量中

    1
    2

③使用mmap系统调用

hzkmem = (unsigned char *)mmap(NULL , hzk_stat.st_size, 		

    1

hzkmem与fbmem类似，也是一个指向映射内存的指针，但是它是指向汉字库，方便后续计算汉字点阵偏移位置用。接下来就是调用汉字点阵库来显示汉字。但是我们需要先了解一下字符的编码格式。
字符的编码格式

不同的字符有不同的编码格式，格式不同，显示出来有可能就是乱码，我们主要了解一下英文，汉字的编码格式。
ASCII码（American Standard Code for Information Interchange，美国信息交换标准代码）是一个7位编码，规定了128个字符（包括数字、字母、标点符号和一些控制字符）及其对应的二进制数值，其中前7位的取值范围为 0~127，最高位为 0。由于它的本质是定长编码，所以不具备国际化能力。
ANSI码（American National Standards Institute，美国国家标准化组织）是对 ASCII 码的扩充，增加了一些控制字符和国际字符，但是ANSI码并没有规定字符集编码方式，因此 ANSI 码对于国际化的支持不够完善。
Unicode编码是一种编码方案，它为世界上所有符号都分配了一个唯一的二进制编码，不仅包括 ASCII 码和 ANSI 码中的字符，还包括了世界上各种语言中存在的符号，甚至包括一些图形符号。Unicode 编码是一个多字节编码，使用不同的字节序列表示不同的符号，并提供了多种编码方式，例如 UTF-8、UTF-16、UTF-32 等。
UTF-8编码是一种可变长的 Unicode 编码方式，使用1~4个字节表示不同的字符，可以节省空间，兼容ASCII码并且支持多语言字符。UTF-8 在网络传输和存储中使用广泛，是当前最常用的 Unicode 编码之一。
GB2312 是一个早期的中文字符集标准，由中国国家标准化委员会于 1980 年发布。它规定了一套单字节字符和 94 个汉字字符，使用了类似 ASCII 码的单字节编码方式，包括了大多数简体中文字符。GB2312 是一个简单、小巧并且有效的编码方法，适合存储和传输中文信息，开创了中文计算机应用的先河。它的编码范围为 0x00~0xFF，其中 0x00~0x7F 与 ASCII 码兼容，0xA1~0xFE 是汉字区。
但是，GB2312 编码方式的缺陷也是显而易见的，它不能覆盖所有的汉字和中文字符，例如繁体汉字、部分方言文字、外来语等无法编码。因此，GB2312 在 1990 年代后期就逐渐被 GBK、GB18030 等更为完善的编码方式所取代。

总体而言，ASCII 码和 ANSI 码是历史编码方式，虽然现在仍然有一些应用，但是由于其不支持国际化等限制，已经逐渐被 Unicode 编码所取代。而 Unicode 编码采用多字节表示一个字符，能够包含世界上各种语言的字符，尤其是亚洲国家的文字和符号，在国际化应用中得到了广泛的应用。而 UTF-8 则是使用最广泛的一种 Unicode 编码，其具有以下特点：兼容 ASCII 码、可变长编码和节省空间，它在现代计算机系统、网络和大规模数据存储等方面具有广泛的应用。、

准确来说呢：ASCII码和ANSI常用于显示英文字符，一个字节对应一个字符，所以有些中文是不能显示的。使用UNICODE码统一编码使用三个字符来显示中文就可以，但是这就会存在浪费。其具有多种编码方式，使用最多的就是UTF-8编码，这能够支持多语言字符，还能变长节省空间，在网络传输数据的时候如果发现丢包的情况下不会导致后面的字符混乱。所以通常使用UTF-8，当然GB2312也是可以显示中文的。

④使用汉字库，调出点阵显示汉字
HZK16 字库是符合GB2312标准的16×16点阵字库HZK16的编码，每个字需要32个字节的点阵来表示，例如我们将要显示的‘中’字，编码是D6D0，难道就是2个字节表示吗？不是说32字节吗？D6D0编码是一个类似于索引码，D6是区码，D0是位码，先要找到D6-A1才是真正区，在D6-A1区里找到D0-A1的真正位置，这才是‘中’字点阵的起始位置（减去A1是为了兼容ascii），每一个区有94个汉字。

unsigned int area  = str[0] - 0xA1;
unsigned int where = str[1] - 0xA1;
//兼容ASCII码
unsigned char *dots = hzkmem + (area * 94 + where)*32;
//(area区码算出来+where在区的位置)*32(共有32个字节)

    1
    2
    3
    4
    5

在这里插入图片描述
上图是汉字点阵排布的示意图，总共有十六行，因此需要一个循环16次的大循环，考虑到一行有两个字节，我们大循环中加入一个循环2次的循环用于区分是哪个字节，最后判断当前字节的每一位，如果为 ‘1’描白色，如果为‘0’描黑色

	for (i = 0; i < 16; i++)
			for (j = 0; j < 2; j++)
			{
				byte = dots[i*2 + j];
				for (b = 7; b >=0; b--)
				{
					if (byte & (1<<b))
					{
						/* show */
						lcd_put_pixel(x+j*8+7-b, y+i, 0xffffff); /* 白 */
					}
					else
					{
						/* hide */
						lcd_put_pixel(x+j*8+7-b, y+i, 0); /* 黑 */
					}	
				}
			}
	
	1
	2
	3
	4
	5
	6
	7
	8
	9
	10
	11
	12
	13
	14
	15
	16
	17
	18
	19

⑤调用我们编写的lcd_put_chinese函数

printf("chinese code: %02x %02x\n", str[0], str[1]);
lcd_put_chinese(var.xres/2 + 8,  var.yres/2, str);

    1
    2

⑥编译c文件show_font.c
编译命令：arm-linux-gnueabihf-gcc -o show_font show_font.c
注：使用此命令HZK16文件必须与show_font.C在同一目录下。
⑦将编译出来的show_font传输到开发板，并进入show_font的目录下
执行命令：./show_font
如果实验成功，我们将看到屏幕中间会显示出一个白色的字母‘A’与汉字‘中’，同时在串口打印信息中看到‘中’对应的编码。
chinese code: d6 d0
四、使用freetype来显示汉字
freetype是什么，为什么要使用freetype

FreeType 是一个开源的字体渲染库，它可以用于将矢量字体文件（如 TrueType、PostScript 和 OpenType 等）渲染成位图或者折线形式，以便在屏幕、打印机等输出设备上显示，同时还能提供一些字体处理的相关函数。
在计算机科学的领域中，字体常用于表示文本和符号，如今也广泛应用于各种应用程序中，例如图形界面、Web 浏览器、手机应用等。字体渲染是字体应用的基础，其中的字体设计、字形排版、字体特效等等都需要借助字体渲染库来实现。
常见的文字渲染实现有两种，一种是在运行时将字体文件转换为位图，以点阵的形式显示在屏幕上，即所谓的“位图字体”；另一种是使用折线算法对字体文件进行转换，以矢量图的形式进行高清渲染，即所谓的“矢量字体”。FreeType 就是一种常见的实现矢量字体渲染的库，它可以根据不同的字体文件进行字形排版、识别和渲染等操作，生成高清的矢量字形图案。
在实际应用中，使用 FreeType 可以适应不同平台和操作系统的要求，处理字符编码、字符大小、字符样式等复杂问题，而且它支持 TrueType、PostScript、OpenType 等多种字体格式，使用起来非常方便。因此，FreeType 被广泛应用于文字处理、操作系统、图形界面等领域。

准确来说，使用点阵显示中文字符的话，放大看会有锯齿的情况出现，并且不支持调节大小，使用freetype可以自定义调节字体的大小。
交叉编译freetype，并安装

文件去官网下载，然后通过FileZilla
①解压freetype源文件

tar xjf freetype-2.4.10.tar.bz2 

    1

②进入解压后的freetype-2.4.10目录

cd freetype-2.4.10

    1

③配置freetype-2.4.10

./configure --host=arm-linux-gnueabihf --prefix=/home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/

    1

④建个目录，避免后面安装出错提示缺少这个internal目录

mkdir /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include/freetype2/freetype/internal -p

    1

⑤编译

make

    1

⑥安装

make install

    1

最后移动freetype头文件，避免以后编译总是需要指定头文件路径

mv /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include/freetype2/freetype /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include/

    1

由于100ask开发板已经有freetype相关的库和头文件，因此不需要移植，如果开发板没有freetype库和头文件就需要按以下方法移植

/home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include/* 复制到开发板的头文件目录中

/home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib/so 复制到开发板的库文件目录中
矢量字体引入

点阵显示英文字母，汉字时，大小固定，如果放大会有锯齿出现，为了解决这个问题，引用矢量字体。矢量字体形成分三步，若干的关键点，数学曲线（贝塞尔曲线），填充颜色组合而成。
①假设A字母的关键点如图中的黄色圈圈，确定关键点。
在这里插入图片描述②用数学曲线将关键点都连接起来，成为封闭的曲线。
在这里插入图片描述
③最后把封闭空间填满颜色，就显示出一个A字母。
在这里插入图片描述
如果需要放大或者缩小字体，关键点的相对位置是不变的，跟进放大比例放大或缩小，但是相对位置不变，好像分数中的1/2 和 2/4，比例是不变的，但是值却大了，类似这个味道。
Freetype理论介绍

开源的Freetype字体引擎库它提供统一的接口来访问多种字体格式文件，从而实现矢量字体显示。我们只需要移植这个字体引擎，调用对应的API接口，提供字体关键点，就可以让freetype库帮我们实现闭合曲线，填充颜色，达到显示矢量字体的目的。
关键点（glyph）存在字体文件中，Windows使用的字体文件在FONTS目录下，扩展名为TTF的都是矢量字库，本次使用实验使用的是新宋字体simsun.ttc。
说白了就是我们要提供字体的关键点，freetype库会帮我们实现闭合曲线那些操作。
在这里插入图片描述
字体文件结构如上图
Charmaps表示字符映射表(通过这个字符映射找到字符的位置，获取它的关键点)，字体文件可能支持哪一些编码，GBK，UNICODE，BIG5还是别的编码，如果字体文件支持该编码，跟进编码，通过charmap，找到对应的glyph，一般而言都支持UNICODE码。
因此一个文字的显示过程大概如下

    ①给定一个文字吗‘A’（0x41），‘中’（GBK，UNICODE ,BIG5）可以确定它的编码值；
    ②跟进编码值，从枝头文件中通过charmap找到对应的关键点（glyph）；
    ③设置字体大；
    ④用某些函数把关键点（glyph）缩放为我们设置的字体大小；
    ⑤转换为位图点阵
    ⑥在LCD上显示出来
    在这里插入图片描述
    如上图，参照step1，step2，step3里的内容，可以学习如何使用freetype库，大致总结下，为如下步骤。

①初始化：FT_InitFreetype
②加载（打开）字体Face：FT_New_Face
③设置字体大小：FT_Set_Char_Sizes 或 FT_Set_Pixel_Sizes
④选择charmap：FT_Select_Charmap
⑤根据编码值charcode找到glyph : glyph_index = FT_Get_Char_Index（face，charcode）
⑥根据glyph_index取出glyph：FT_Load_Glyph（face，glyph_index）
⑦转为位图：FT_Render_Glyph
⑧移动或旋转:FT_Set_Transform
在这里插入图片描述
在LCD上显示字符

我们可以参考上图位置的c程序，编写程序。
①初始化freetype库

error = FT_Init_FreeType( &library );

    1

②用freetype库中的FT_New_Face函数创建一个face字体文件对象，保存在&face中

error = FT_New_Face( library, argv[1], 0, &face );

    1

③提取face对象中的glyph，即关键点集

slot = face->glyph;

    1

④设置像素点大小，24*24

FT_Set_Pixel_Sizes(face, 24, 0);

    1

⑤确定坐标
目前我们前面所用的都是LCD的坐标系对应的x与y坐标，然后在freetype上却是使用的笛卡尔坐标系，因此我们还需要转换x与y坐标。
在这里插入图片描述
我们将要显示的是‘繁’字，根据上图可知，先计算在lcd坐标系的情况下‘繁’字的左下角的x坐标与y坐标，因为在笛卡尔坐标中左下角为字符的原点，‘A’是的左上角为整个屏幕的中心点，即（xres/2，yres/2）。在这里插入图片描述

    lcd_x = var.xres/2 + 8 + 16；
    lcd_y = var.yres/2 + 16

则笛卡尔座标系:x = lcd_x = var.xres/2 + 8 + 16 ； y = var.yres - lcd_y = var.yres/2 – 16
单位是1/64像素，所以需要乘以64

pen.x = (var.xres/2 + 8 + 16) * 64;
pen.y = (var.yres/2 - 16) * 64;
FT_Set_Transform( face, 0, &pen);

    1
    2
    3

⑥找到glyph的位置，然后取出，并转换为位图

error = FT_Load_Char( face, chinese_str[0], FT_LOAD_RENDER );
	if (error)
	{
		printf("FT_Load_Char error\n");
		return -1;
	}

    1
    2
    3
    4
    5
    6

在这里插入图片描述
FT_Load_Char函数调用替代了上图这3步。最后把转换出来的位图打印出来，也是参考example1.c编写

draw_bitmap( &slot->bitmap,slot->bitmap_left,var.yres - slot->bitmap_top);

    1

在这里插入图片描述

修改上图3处位置
Width宽度：因为在LCD上显示，宽度自然就是x方向的像素点数，var.xres；
Height高度：因为在LCD上显示，高度自然就是y方向的像素点数，var.yres；
用点阵实验中的的描点函数lcd_put_pixel替代image数组：lcd_put_pixel(i, j, bitmap->buffer[q * bitmap->width + p]);
⑥编译C程序文件freetype_show_font.c
编译命令：

    arm-linux-gnueabihf-gcc -finput-charset=GBK -fexec-charset=GBK -o freetype_show_font freetype_show_font.c -lfreetype -lm

⑦将编译好的freetype_show_font的文件与simsun.ttc字体文件拷贝至开发板，simsun.ttc字体文件放在freetype_show_font执行文件的上一层目录下，执行以下命令。
执行命令：

    ./freetype_show_font …/simsun.ttc

如果实验成功，我们将看到屏幕中间会比之前实验多出一个蓝色的‘繁’字。
在LCD上令矢量字体旋转某个角度

在实现显示一个矢量字体后，我们可以添加让该字旋转某个角度的功能。我们根据输入的第二个参数，判断其旋转角度，主要代码还是参照example1.c
在这里插入图片描述
根据上图，增加旋转角度功能，旋转的角度由执行命令的第二个参数指定。

angle = ( 1.0 * strtoul(argv[2], NULL, 0) / 360 ) * 3.14159 * 2;
matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );
matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );
matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );
matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );
FT_Set_Transform( face, &matrix, &pen);

    1
    2
    3
    4
    5
    6

最后编译，在开发板上运行
编译命令如下：
编译命令：

    arm-linux-gnueabihf-gcc -finput-charset=GBK -fexec-charset=GBK -o freetype_show_font_angle freetype_show_font_angle.c -lfreetype -lm

编译出的文件名为freetype_show_font_angle，将文件拷贝至开发板
在含有该文件的目录下执行以下命令，以下命令正确执行前提是执行文件freetype_show_font在此目录，而且字体文件simsun.ttc，在上一级目录：
执行命令：

    ./freetype_show_font_angle …/simsun.ttc 90

如果实验成功，我们将看到屏幕中间的蓝色‘繁’字，旋转了90度。
在LCD上使用freetype显示一行文字

在LCD上指定一个左上角坐标(x, y)，把一行文字显示出来。下图中，文字的外框用虚线表示，外框的左上角坐标就是(x, y)。
上面我们已经了解了LCD使用的是笛卡尔坐标系。我们需要注意到每个字符的大小可能不同，在使用FT_Set_Pixel_Sizes函数设置字体大小时，这只是“期望值”。比如“百问网www.100ask.net”，如果把“.”显示得跟其他汉字一样大，不好看。所以在显示一行文字时，后面文字的位置会受到前面文字的影响。幸好，freetype帮我们考虑到了这些影响。对于freetype字体的尺寸(freetype Metrics)，需要参考下图这个文档。
在这里插入图片描述在这里插入图片描述
在显示一行文字时，这些文字会基于同一个基线来绘制位图：baseline。
在baseline上，每一个字符都有它的原点(origin)，比如上图中baseline左边的黑色圆点就是字母“g”的原点。当前origin加上advance就可以得到下一个字符的origin，比如上图中baseline右边的黑色圆点。在显示一行中多个文件字时，后一个文字的原点依赖于前一个文字的原点及advance。
字符的位图是有可能越过baseline的，比如上图中字母“g”在baseline下方还有图像。
上图中红色方框内就是字母“g”所点据的位图，它的四个角落不一定与原点重合。
上图中那些xMin、xMax、yMin、yMax如何获得？可以使用FT_Glyph_Get_CBox函数获得一个字体的这些参数，将会保存在一个FT_BBox结构体中，以后想计算一行文字的外框时要用到这些信息：
在这里插入图片描述
在指定位置显示一行文字

要显示一行文字时，每一个字符都有自己外框：xMin、xMax、yMin、yMax。把这些字符的xMin、yMin中的最小值取出来，把这些字符的xMax、yMax中的最大值取出来，就可以确定这行文字的外框了。要想在指定位置(x, y)显示一行文字，步骤如下图所示：
在这里插入图片描述① 先指定第1个字符的原点pen坐标为(0, 0)，计算出它的外框
② 再计算右边字符的原点，也计算出它的外框
把所有字符都处理完后就可以得到一行文字的整体外框：假设外框左上角坐标为(x’, y’)。
③ 想在(x, y)处显示这行文字，调整一下pen坐标即可
怎么调整？
pen为(0, 0)时对应左上角(x’, y’)；
那么左上角为(x, y)时就可以算出pen为(x-x’, y-y’)。
freetype的几个重要数据结构

要想形象地理解程序，需要先介绍一下freetype中几个数据结构：
FT_Library
对应freetype库，使用freetype之前要先调用以下代码：

FT_Library  library; /* 对应freetype库 */
error = FT_Init_FreeType( &library ); /* 初始化freetype库 */

    1
    2

FT_Face
它对应一个矢量字体文件，在源码中使用FT_New_Face函数打开字体文件后，就可以得到一个face。
为什么称之为face？估计是文字都是写在二维平面上的吧，正对着人脸？不用管原因了，总之认为它对应一个字体文件就可以。
代码如下：

error = FT_New_Face(library, font_file, 0, &face ); /* 加载字体文件 */

    1

FT_GlyphSlot
插槽？用来保存字符的处理结果：比如转换后的glyph、位图，如下图：
在这里插入图片描述
一个face中有很多字符，生成一个字符的点阵位图时，位图保存在哪里？保存在插槽中：face->glyph。生成第1个字符位图时，它保存在face->glyph中；生成第2个字符位图时，也会保存在face->glyph中，会覆盖第1个字符的位图。
代码如下：

FT_GlyphSlot  slot = face->glyph; /* 插槽: 字体的处理结果保存在这里 */

    1

FT_Glyph
字体文件中保存有字符的原始关键点信息，使用freetype的函数可以放大、缩小、旋转，这些新的关键点保存在插槽中(注意：位图也是保存在插槽中)。
新的关键点使用FT_Glyph来表示，可以使用这样的代码从slot中获得glyph：

error = FT_Get_Glyph(slot , &glyph);

    1

FT_BBox
FT_BBox结构体定义如下，它表示一个字符的外框，即新glyph的外框：
在这里插入图片描述
可以使用以下代码从glyph中获得这些信息：

FT_Glyph_Get_CBox(glyph, FT_GLYPH_BBOX_TRUNCATE, &bbox );

    1

上述流程如下：
在这里插入图片描述计算一行文字的外框
前面提到过，一行文字中：后一个字符的原点=前一个字符的原点+advance。
所以要计算一行文字的外框，需要按照排列顺序处理其中的每一个字符。
代码如下，注释写得很清楚了

int compute_string_bbox(FT_Face       face, wchar_t *wstr, FT_BBox  *abbox)
{
	 int i;
     int error;
     FT_BBox bbox;
     FT_BBox glyph_bbox;
     FT_Vector pen;
     FT_Glyph  glyph;
     FT_GlyphSlot slot = face->glyph;

     /* 初始化 */
     bbox.xMin = bbox.yMin = 32000;
     bbox.xMax = bbox.yMax = -32000;
    
     /* 指定原点为(0, 0) */
     pen.x = 0;
     pen.y = 0;
    
     /* 计算每个字符的bounding box */
     /* 先translate, 再load char, 就可以得到它的外框了 */
     for (i = 0; i < wcslen(wstr); i++)
     {
        /* 转换：transformation */
        FT_Set_Transform(face, 0, &pen);
    
         /* 加载位图: load glyph image into the slot (erase previous one) */
        error = FT_Load_Char(face, wstr[i], FT_LOAD_RENDER);
         if (error)
         {
             printf("FT_Load_Char error\n");
             return -1;
         }
    
         /* 取出glyph */
         error = FT_Get_Glyph(face->glyph, &glyph);
         if (error)
         {
             printf("FT_Get_Glyph error!\n");
             return -1;
         }
    
         /* 从glyph得到外框: bbox */
         FT_Glyph_Get_CBox(glyph, FT_GLYPH_BBOX_TRUNCATE, &glyph_bbox);
    
         /* 更新外框 */
        if ( glyph_bbox.xMin < bbox.xMin )
             bbox.xMin = glyph_bbox.xMin;
    
         if ( glyph_bbox.yMin < bbox.yMin )
             bbox.yMin = glyph_bbox.yMin;
    
         if ( glyph_bbox.xMax > bbox.xMax )
             bbox.xMax = glyph_bbox.xMax;
    
         if ( glyph_bbox.yMax > bbox.yMax )
             bbox.yMax = glyph_bbox.yMax;
    
         /* 计算下一个字符的原点: increment pen position */
         pen.x += slot->advance.x;
         pen.y += slot->advance.y;
     }
    
     /* return string bbox */
     *abbox = bbox;
 }

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47
    48
    49
    50
    51
    52
    53
    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    64
    65
    66

调整原点并绘制

int display_string(FT_Face     face, wchar_t *wstr, int lcd_x, int lcd_y)
{
    int i;
    int error;
    FT_BBox bbox;
    FT_Vector pen;
    FT_Glyph  glyph;
    FT_GlyphSlot slot = face->glyph;

    /* 把LCD坐标转换为笛卡尔坐标 */
    int x = lcd_x;
    int y = var.yres - lcd_y;
    
    /* 计算外框 */
    compute_string_bbox(face, wstr, &bbox);
    
    /* 反推原点 */
    pen.x = (x - bbox.xMin) * 64; /* 单位: 1/64像素 */
    pen.y = (y - bbox.yMax) * 64; /* 单位: 1/64像素 */
    
    /* 处理每个字符 */
    for (i = 0; i < wcslen(wstr); i++)
    {
    	/* 转换：transformation */
    	FT_Set_Transform(face, 0, &pen);
    
    	/* 加载位图: load glyph image into the slot (erase previous one) */
    	error = FT_Load_Char(face, wstr[i], FT_LOAD_RENDER);
    	if (error)
    	{
    		printf("FT_Load_Char error\n");
    		return -1;
    	}
    
    	/* 在LCD上绘制: 使用LCD坐标 */
    	draw_bitmap( &slot->bitmap,
    	slot->bitmap_left,
    	var.yres - slot->bitmap_top);
    	
    	/* 计算下一个字符的原点: increment pen position */
    	pen.x += slot->advance.x;
    	pen.y += slot->advance.y;
    }
    
    return 0;
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47

编译命令(如果你使用的交叉编译链前缀不是arm-buildroot-linux-gnueabihf，请自行修改命令)：

    $ arm-buildroot-linux-gnueabihf-gcc -o show_line show_line.c -lfreetype

将编译好的show_line文件与simsun.ttc字体文件拷贝至开发板，这2个文件放在同一个目录下，然后执行以下命令(其中的3个数字分别表示LCD的X坐标、Y坐标、字体大小)：

    [root@board:~]# ./show_line ./simsun.ttc 10 200 80

如果实验成功，可以在LCD上看到一行文字“百问网www.100ask.net”。
总结

本文主要记录了FrameBuffer应用编程，介绍了其概念，使用LCD显示字符，中文，一行中文，还介绍了字符的不同的编码格式。最后使用freetype库显示单个矢量文字和显示一行矢量文字。
————————————————
版权声明：本文为CSDN博主「QRS_HL」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_65525149/article/details/131145814

## 2. GUI 概念

Github Pages：[Modern Graphics Engine Guide](https://link.zhihu.com/?target=https%3A//italink.github.io/ModernGraphicsEngineGuide/00-C%2B%2B/6.GUI/)

> 图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。
> 图形用户界面是一种人与[计算机通信](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1/8082711%3FfromModule%3Dlemma_inlink)的界面显示[格式](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%A0%BC%E5%BC%8F/2406%3FfromModule%3Dlemma_inlink)，允许用户使用[鼠标](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E9%BC%A0%E6%A0%87/122323%3FfromModule%3Dlemma_inlink)等输入设备操纵[屏幕](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%B1%8F%E5%B9%95/3750314%3FfromModule%3Dlemma_inlink)上的[图标](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%9B%BE%E6%A0%87/3823326%3FfromModule%3Dlemma_inlink)或菜单选项，以选择命令、调用文件、启动程序或执行其它一些[日常任务](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%97%A5%E5%B8%B8%E4%BB%BB%E5%8A%A1/10744783%3FfromModule%3Dlemma_inlink)。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。图形用户界面由窗口、下拉菜单、对话框及其相应的控制机制构成，在各种新式应用程序中都是标准化的，即相同的操作总是以同样的方式来完成，在图形用户界面，用户看到和操作的都是图形对象，应用的是计算机图形学的技术。
> ——《[百度百科](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/GUI/479966)》

如果你厌倦了跟控制台斗智斗勇的日子，那么这篇文章或许能帮上忙。

## **概览**

GUI的划分主要有两个大类，分别是：

- **Native UI** ：传统的原生App开发模式，使用系统平台上的接口进行开发
- **Web UI** ：特定运行在浏览器上的网站应用

这里有一个更详细的介绍：

- [知乎：什么是 Native、Web App、Hybrid？](https://zhuanlan.zhihu.com/p/40705635)

> Hybrid 指使用 Native UI 和 Web UI 混合开发

关于它们的争论，可以查看：

- [知乎：Web App 和 Native App，哪个是趋势？](https://www.zhihu.com/question/19558750)

Web UI 由于成本低，开发快，在互联网市场上占据主导地位，而使用 Native UI 的原因无外乎：高性能、定制化、硬件交互.

虽然 [Web GPU](https://www.zhihu.com/question/315103318) 现在已经趋于稳定，对于 Web 程序员而言有更大的提升空间，但对于图形、引擎方向的同学，笔者建议最好是走Native 方向，这样有更多的可控空间

而 Native UI方案，根据语言来划分，主要有：

C/C++: [Qt](https://link.zhihu.com/?target=https%3A//www.qt.io/product/framework)、    [WxWidget](https://link.zhihu.com/?target=https%3A//www.wxwidgets.org/)、[GTK](https://link.zhihu.com/?target=https%3A//www.gtk.org/)、     [FLTK](https://link.zhihu.com/?target=https%3A//www.fltk.org/)、    [DearImGUI](https://link.zhihu.com/?target=https%3A//github.com/ocornut/imgui/wiki)、[Nuklear](https://link.zhihu.com/?target=https%3A//github.com/vurtun/nuklear)、[duilib](https://link.zhihu.com/?target=https%3A//github.com/duilib/duilib)、[C++ Builder](https://link.zhihu.com/?target=https%3A//alfasoft.com/software/development-tools/programming/embarcadero/cppbuilder/)、[MFC](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/en-us/cpp/mfc/mfc-desktop-applications)、[EasyX](https://link.zhihu.com/?target=https%3A//easyx.cn/)

Python:  [PyQt](https://link.zhihu.com/?target=https%3A//riverbankcomputing.com/software/pyqt/)、[WxPython](https://link.zhihu.com/?target=https%3A//www.wxpython.org/)、[PyGTK](https://link.zhihu.com/?target=https%3A//www.gtk.org/)、[PyFLTK](https://link.zhihu.com/?target=https%3A//pyfltk.sourceforge.io/)、[DearPyGUI](https://link.zhihu.com/?target=https%3A//github.com/hoffstadt/DearPyGui/wiki)、[Tkinter](https://link.zhihu.com/?target=https%3A//docs.python.org/3/library/tkinter.html)、[PyGame](https://link.zhihu.com/?target=https%3A//www.pygame.org/news)

C#：  [WPF](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/en-us/dotnet/desktop/wpf/overview/)、[WinForm](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/en-us/dotnet/desktop/winforms/overview)

Java：     Swing、[JavaFx](https://link.zhihu.com/?target=https%3A//openjfx.io/)

在上面的框架中，使用 C/C++ 具有天然的优势，当然如果你是一个 Python 或者 C# 开发者，没有强制的工作需求，倒也不必大费周章为了GUI 去学 C++

- [知乎：什么语言最适合做 GUI？](https://www.zhihu.com/question/276815517)

在这些C++GUI框架中，又该如何选择呢？

笔者依次学过：EasyX - Tkinter - PyGame - JavaFx - FLTK - Qt - ImGUI - UE Slate

整体用下来发现：GUI无非就是：

- 处理一下系统的交互事件（比如键盘按键，鼠标点击）
- 在屏幕上填充像素画几个图形

这些是 操作系统 或者说 每个GUI框架 都至少提供的功能，试想一下，都有这两个功能了，就是在交互操作上绑个回调函数，用循环在屏幕像素上填充RGB，什么狂拽酷炫的图形界面它做不出来？无非就是时间精力的问题，比如说这样的程序：

```cpp
#include <conio.h>      //控制台IO
#include <iostream>

int main() {
    char currentChar = '\0';
    const int width = 20;
    const int height = 20;
    while (true) {
        if (kbhit()) {              //kbhit能判断当前是否有按键输入
            currentChar = getch();  //getch为不回显输入函数，于getchar不同的是，输入的按键不会显示在控制台上
        }
        system("cls");              //控制台清屏
        std::cout << "Please enter key:" << std::endl;
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                std::cout << currentChar;
            }
            std::cout << std::endl;
        }
    }
    return 0;
}
```

![img](https://pic2.zhimg.com/80/v2-9c5522ee30a4fae6d63384da9507f091_720w.webp)

控制台程序在运行过程中会疯狂闪烁，这一点会在下文解决

GUI相较于上面的控制台程序，无非就是将键鼠输入封装一层接口，`width`和`height`为窗口尺寸，只是在对应坐标的像素填充颜色而已

真正决定选什么框架，最关键的还是生态，具体体现在：

- 使用的人多，队友多，更容易招聘
- 框架覆盖面广，工具库多，文档齐全
- 官方长期维护，迭代频率高，坑少

而上述框架中，做的最好的，毫无疑问 — Qt

Qt中的大部分模块遵循 LGPL 协议，这允许我们可以以动态链接的形式使用模块，并发布商业软件，每个模块的开源协议，请查阅：

- [https://doc.qt.io/qt-6/licenses-used-in-qt.html](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/licenses-used-in-qt.html)

如果想修改Qt源码或使用一些商业模块，你需要购买Qt的商业许可证，具体请查阅：

- [https://www.qt.io/licensing/open-source-lgpl-obligations](https://link.zhihu.com/?target=https%3A//www.qt.io/licensing/open-source-lgpl-obligations)

由于Qt开源协议比较严格，独立于C++标准，且体量庞大，很多团队可能还是会选择WxWidget、C++ Builder、duilib、GTK等框架，而 MFC、FLTK、EasyX  或许是一个不错的GUI框架，但它的开发生态却不容乐观，如果有的选，笔者建议不要去碰

Dear ImGUI 和 Nuklear 是一种轻量、便携且遵循 **Immediate Mode** 的GUI工具包，它本质上是提供一些控件接口给开发者来完成一帧图形的绘制，以ImGUI 为例，使用如下代码：

```cpp
ImGui::Text("Hello Dear ImGUI");
static bool CheckState;
ImGui::Checkbox("CheckBox ", &CheckState);
```

能生成这样的界面：

![img](https://pic2.zhimg.com/80/v2-5e954faba9c8ec850bafc95380573321_720w.webp)

**Immediate Mode（立即模式）** 主要体现在它将变量 `CheckState` 的指针传递到了 “控件” 之中，而传统的 **Retained Mode（保留模式）**，比如在Qt中，它的代码可能是这样的：

```cpp
static bool CheckState;
QCheckBox* CheckBox = new QCheckBox;
CheckBox->setCheckState( CheckState? Qt::Checked : Qt::Unchecked);      //初始化
QObject::connect(CheckBox,&QCheckBox::stateChanged,[&](int state){      //绑定signal-slot
    CheckState = state == Qt::Checked;
});
```

可以看到 **QCheckBox** 并没有使用 `CheckState` 的指针，而是通过`CheckState`设置控件的初始状态，当控件`stateChanged`时，再设置 `CheckState` 的值，也就是说控件本身是持有自己的State， **Immediate Mode 则强调无状态**，将状态嵌入到了控件之中

在开发过程中，存储过多的局部状态需要编写很多代码保持同步，可能一不小心就弄出了个Bug，比如很容易导致某些事件多次执行 甚至 死循环

打个比方，对一个Color调色：

![img](https://pic1.zhimg.com/80/v2-7afd9d8b15980457522dd03396189758_720w.webp)

使用调色盘，拖拽或输入通道数值，十六进制输入，屏幕取色等多种方式都可以对同一个颜色值进行调整，如果使用保留模式，在通过某种方式修改了颜色之后，还得手动调整其他控件来保证颜色同步，虽然遵循一些设计模式可以解决这个问题，但立即模式在这种应用场景下具有天然优势

关于它们的差异的争论，请查阅：

- [知乎：Retained 和 IMGUI 有何联系和区别？](https://www.zhihu.com/question/39093254/answer/1351958747)

那么这是否意味着 Dear ImGUI 比 Qt 好? 不尽然，笔者的观点如下：

- **Immediate Mode 更适用于游戏引擎，但  Dear ImGUI  还不够。** 它仅仅只是一个小巧的GUI工具包，虽然它确实很容易上手，也能做出不错的界面效果，但大型软件系统的开发是一门工程艺术，较低的门槛会带来更多的问题，除非有足够的人手和精力去不断迭代，否则使用原生Dear ImGUI 开发简直就是一场灾难...
  这里有个回答，虽然不是说 Dear ImGUI，但很好地暴露了这类框架的问题：https://www.zhihu.com/question/66934513/answer/248036488
- **Retained Mode 只是一种控件架构的方式，Qt != Retained Mode。** 虽然基本上Native UI框架的官方控件都是使用 Retained Mode，但只要你想，你也可以在这些框架上使用 Immediate Mode
  [Why Qt and not IMGUI?](https://link.zhihu.com/?target=https%3A//deplinenoise.wordpress.com/2017/03/05/why-qt-and-not-imgui/)

那么是否就意味着Qt更好呢？也不尽然，使用Qt意味着要把它整个Core和Widget模块及moc给引入进来，且由于开源许可导致我们不能去修改它的源代码，所以它在游戏引擎中，大多是做为编辑器存在，例如：

- [O3DE](https://link.zhihu.com/?target=https%3A//www.o3de.org/)：[https://github.com/o3de/o3de](https://link.zhihu.com/?target=https%3A//github.com/o3de/o3de)

目前它并不适用于游戏内的UI方案：

- 云风的 BLOG — 游戏 UI 模块的选择：[https://blog.codingnow.com/2020/07/game_ui.html](https://link.zhihu.com/?target=https%3A//blog.codingnow.com/2020/07/game_ui.html)

UE中的Slate是一个非常优秀的底层UI框架：

- [https://docs.unrealengine.com/5.1/en-US/understanding-the-slate-ui-architecture-in-unreal-engine/](https://link.zhihu.com/?target=https%3A//docs.unrealengine.com/5.1/en-US/understanding-the-slate-ui-architecture-in-unreal-engine/)

但在本系列文章接下来图形相关的教程，将会使用 Qt 作为主编辑器，内嵌 ImGUI 用于场景编辑，主要原因如下：

- Qt拥有跨平台的Window封装，可以拿到 Handle 使用 Native API 做一些特殊处理
- Qt拥有一套优雅的反射系统，便于搭建编辑器，使用Signal-Slot可以很好的给逻辑解耦，增加可读性
- Qt拥有独立的容器库，使用它可以免受STL的摧残
- Qt拥有很多接口风格统一的扩展库，例如基础数学库，图片编解码库，多媒体库，可以让学习成果更容易变现
- Qt 6.0 以后推出了支持OpenGL、DX11、Vulkan、Metal的RHI（Render Hardware  Interface），使用上远比OpenGL容易，架构上使用 Vulkan风格的 glsl 和  现代图形API，没有像bgfx那样进行魔改，最重要的是，使用Qt的RHI可以很好的兼容 Native  API，这样以便于使用图形API或者硬件提供的高级特性
- Qt中的很多体系结构可以映射到 Unreal Engine 里面，如果你的目标是它，Qt绝对是最好的跳板，因为Qt的官方代码可读性高，且拥有大量的文档、Demo、教程

## **平台基础**

GUI程序将显示在屏幕上，为了能够系统地管理屏幕上的像素，操作系统提供了名为 Window 的结构，在Windows10上，一个标准的Window如下，它带有一个标题栏（图标，标题文本，最小化按钮，最大化按钮，关闭按钮）：

![img](https://pic1.zhimg.com/80/v2-9ba6e001e9b9945b7c76e2009bea86e8_720w.webp)

你可以按如下的方式来创建一个Window：

- 新建一个 `CMakeLists.txt` 和 `main.cpp` 文件
- `CMakeLists.txt`中填入：

```cmake
cmake_minimum_required(VERSION 3.12)
project(Window)
add_executable(Window WIN32 main.cpp)
```

Win32 表明该executable为Win32窗口，具体对应Visual Studio的`项目设置` - `链接器` - `系统` - `子系统` - `窗口` ：

![img](https://pic2.zhimg.com/80/v2-53037dac365bc591ac394a08b4fa9f5d_720w.webp)

- 在`main.cpp` 中填入：

```cpp
#ifndef UNICODE
#define UNICODE
#endif 

#include <windows.h>

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)
{
    // Register the window class.
    const wchar_t CLASS_NAME[]  = L"Sample Window Class";
    
    WNDCLASS wc = { };

    wc.lpfnWndProc   = WindowProc;
    wc.hInstance     = hInstance;
    wc.lpszClassName = CLASS_NAME;

    RegisterClass(&wc);

    // Create the window.

    HWND hwnd = CreateWindowEx(
        0,                              // Optional window styles.
        CLASS_NAME,                     // Window class
        L"Learn to Program Windows",    // Window text
        WS_OVERLAPPEDWINDOW,            // Window style

        // Size and position
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,

        NULL,       // Parent window    
        NULL,       // Menu
        hInstance,  // Instance handle
        NULL        // Additional application data
        );

    if (hwnd == NULL)
    {
        return 0;
    }

    ShowWindow(hwnd, nCmdShow);

    // Run the message loop.

    MSG msg = { };
    while (GetMessage(&msg, NULL, 0, 0) > 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);

            // All painting occurs here, between BeginPaint and EndPaint.

            FillRect(hdc, &ps.rcPaint, (HBRUSH) (COLOR_WINDOW+1));

            EndPaint(hwnd, &ps);
        }
        return 0;

    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```

- 使用CMake命令行或CMakeGUI生成VisualStudio工程文件，在`解决方案资源管理器`中，右键 Window项目 - `设为启动项目`，执行就能看到

![img](https://pic4.zhimg.com/80/v2-7d04421c30d708d13eb37f3b80d6638f_720w.webp)

上述代码来自于 微软 的官方教程，有兴趣的读者可以自己过一遍：

- [https://learn.microsoft.com/en-us/windows/win32/learnwin32/your-first-windows-program](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/en-us/windows/win32/learnwin32/your-first-windows-program)

### **Spy++**

看到这里，你觉得什么是Window？它是一个带有最大化、最小化、关闭的按钮的框吗？

不尽然，在 Visual Studio 中可以找到 **Spy++** ：【菜单栏】—【工具】—【Spy++】

![img](https://pic1.zhimg.com/80/v2-b1d6a90e0f671f226a11262ab5b56f58_720w.webp)

使用它可以查看系统中的所有Window：

![img](https://pic4.zhimg.com/80/v2-e4d9df2d404ed256f603c92c18a7bfff_720w.webp)

> Spy++自底向上按层级显示了所有窗口，即，你在显示器上看到的东西，都有迹可循，比如最底层为桌面（壁纸）

使用它的窗口搜索工具（【菜单栏】—【搜索】—【查找窗口】—拖拽下图准心到任意窗口），可以Spy++中定位到具体的`Item`，这有点类似UE中的控件反射器。

![img](https://pic1.zhimg.com/80/v2-fdb9df2603b06137c35abe2fe3aedf34_720w.webp)

通过上面的工具，你可以发现窗口是有层级的，且不一定会有关闭按钮，甚至没有边框。

![img](https://pic2.zhimg.com/80/v2-a620d949306ed77d44d533c98c966765_720w.webp)

在Windows下，边框和标题栏部分由系统控制，它不属于程序本身，称之为 **Non-Client Area（非客户区域）**

边框内部的区域才可以由程序自由绘制，这部分称之为 **Client Area（ 客户区域）**

- [What is windows client and non-client area?](https://link.zhihu.com/?target=https%3A//www.equestionanswers.com/vcpp/client-non-client-area.php)

微软可能意识到它的标题栏限制了UI的美化，所以窗口还支持设置 **无边框且背景透明** 的属性，而很多软件通过这种方式来绘制 **异形窗口**，比如QQ音乐的播放器：

![img](https://pic4.zhimg.com/80/v2-c4111a492b003b967ccff4d6c04549f3_720w.webp)

系统交互事件会传递给 当前的Activated（激活的）窗口，而处于Unactivated状态的窗口，系统一般会以灰色的样式来进行显示：

![img](https://pic1.zhimg.com/80/v2-3ef9599d252c2f6282a7f9e42ca95858_720w.webp)

> 一般情况下，只会有一个激活的窗口，这也意味着当前只有一个窗口能接受电脑的输入事件，不过也可以通过一些方法来打破规则，比如 [钩子](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E9%92%A9%E5%AD%90)

### **Multiple buffering**

在之前的控制台程序中，页面在疯狂闪烁，这是因为我们对一个缓冲区一点一点的在添加东西，而控制台窗口正在预览这个过程，由于刷新速度很快，就导致了闪烁，为了解决这类问题，在计算机科学中，提出了 **Multiple buffering（多缓冲）** 的概念：

- 用来供给控制台预览的缓冲区称之为 **前台缓冲区**，多缓冲的核心在于我们并不直接操作前台缓冲区，而是对 **后台缓冲区** 进行操作，当处理完毕再 **统一提交** 给 前台缓冲区，这样可以有效避免闪烁和撕裂

> 提到统一提交，是否想到了上一节的 **for copy** 和 **memcpy**？
> 要将筐里的所有橘子放到另一个筐里，一个一个放快呢？还是直接抬起筐倒快呢？显而易见
> 硬件和接口的提供者显然也懂得这个道理，绝大多情况下，他们都会都支持 Map，Blit 之类的操作

在控制台中使用双缓冲区的示例如下：

```cpp
#include <conio.h>
#include <iostream>
#include <Windows.h>

const int width = 20;
const int height = 20;
const int MaxBufferSize = width * height * 10;

void UseSingleBuffer() {
	char currentChar = '*';
	while (true) {
		if (_kbhit()) {              //kbhit 能判断当前是否有按键输入
			currentChar = _getch();  //getch 为不回显输入函数，与getchar不同的是，输入的按键不会显示在控制台上
		}
		system("cls");              //控制台清屏
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				std::cout << currentChar;
			}
			std::cout << std::endl;
		}
	}
}
void UseDoubleBuffer() {
	HANDLE frontendBuffer = GetStdHandle(STD_OUTPUT_HANDLE);        //获取默认的缓冲区

	HANDLE backendBuffer = CreateConsoleScreenBuffer(               //创建一个新的缓冲区作为后台缓冲区
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		CONSOLE_TEXTMODE_BUFFER,
		NULL
	);

	//隐藏两个缓冲区的光标
	CONSOLE_CURSOR_INFO cci;
	cci.bVisible = 0;
	cci.dwSize = 1;
	SetConsoleCursorInfo(frontendBuffer, &cci);
	SetConsoleCursorInfo(backendBuffer, &cci);

	char bufferData[MaxBufferSize];     //缓存数据暂存区
	DWORD bufferLength = 0;
	COORD zeroCoord = { 0,0 };
	char currentChar = '*';

	while (true) {
		if (kbhit()) {
			currentChar = getch();
		}
		bufferLength = 0;

		CONSOLE_SCREEN_BUFFER_INFO backendBufferInfo;       //获取backendBuffer每行的字符数量
		GetConsoleScreenBufferInfo(backendBuffer, &backendBufferInfo);
		int lineWidth = backendBufferInfo.srWindow.Right - backendBufferInfo.srWindow.Left + 1;

		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				bufferData[bufferLength++] = currentChar;
			}
			while (bufferLength % lineWidth != 0) {             //填充字符以到达换行的效果
				bufferData[bufferLength++] = ' ';
			}
		}

		//从backendBuffer的zeroCoord开始写入bufferLength长度的bufferData
		WriteConsoleOutputCharacterA(backendBuffer, bufferData, bufferLength, zeroCoord, &bufferLength);
		SetConsoleActiveScreenBuffer(backendBuffer);            //将backendBuffer显示出来
		std::swap(backendBuffer, frontendBuffer);               //交换前后缓冲操作句柄,frontendBuffer将作为下一次循环的backendBuffer
	}
}
int main() {
	//UseSingleBuffer();
	UseDoubleBuffer();
	return 0;
}
```

大多数GUI框架都使用了双缓冲的方式，而游戏中甚至使用了三缓冲，一般我们会称这个结构为 [交换链](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Swap_chain)

关于多缓冲的细节，可以查阅：

- [https://en.wikipedia.org/wiki/Multiple_buffering](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Multiple_buffering)

### **DPI**

> 图像每英寸长度内的像素点数。
> DPI（Dots Per Inch，每英寸点数）是一个量度单位，用于点阵[数码影像](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E6%95%B0%E7%A0%81%E5%BD%B1%E5%83%8F/6208065%3FfromModule%3Dlemma_inlink)，指每一[英寸](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E8%8B%B1%E5%AF%B8%3FfromModule%3Dlemma_inlink)长度中，取样、可显示或输出点的数目。

在Windows上，通过设置 **缩放与布局** 来调整系统的DPI

![img](https://pic1.zhimg.com/80/v2-930aca8607901b742ea53d058af0ce40_720w.webp)

操作系统将根据DPI的变动按一定可配置的机制去调整窗口的尺寸和内容，关于DPI感知的细节，请查阅：

- [https://learn.microsoft.com/zh-cn/windows/win32/hidpi/high-dpi-desktop-application-development-on-windows](https://link.zhihu.com/?target=https%3A//learn.microsoft.com/zh-cn/windows/win32/hidpi/high-dpi-desktop-application-development-on-windows)
- [https://doc.qt.io/qt-6/highdpi.html](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/highdpi.html)
- [https://en.wikipedia.org/wiki/Dots_per_inch](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Dots_per_inch)

在GUI开发过程中，支持多 DPI 的预览一直是一个比较头疼的问题，因为很难通过 几个参数 去调整 整个界面 的 效果与布局

而在图形开发过程中，一个比较大的坑就是：

- Window Size != Buffer Size，很多小伙伴通过Window Size去创建 Frame Buffer，这在100%缩放的电脑上表现是正常的，但在其他情况下，就有问题了

## **Qt基础**

### **安装**

[https://courses.qt.io/how-to-install-qt/index.html#/lessons/WDj_gIccDJa6gmhH_-3P7uC2QDaZHbYA](https://link.zhihu.com/?target=https%3A//courses.qt.io/how-to-install-qt/index.html%23/lessons/WDj_gIccDJa6gmhH_-3P7uC2QDaZHbYA)

![img](https://pic3.zhimg.com/80/v2-7229bc564916df1ee4f4087b3405b2a6_720w.webp)

如果你想继续学习之后的图形章节，那么你在安装的时候请选择 `Custom installation`，确保安装以下模块：

- Qt6以上的任意版本，建议是最新的（比如6.5.2 beta），包含
  - **MSVC 2019 64-bit** ：支持使用Visual Studio进行Qt开发
  - **Sources** ：Qt源码
  - **Qt 5 Compatibility Module** ：Qt5的共存模块
  - **Qt Shader Tools** ：Qt的着色器工具，用于将glsl转换hlsl、msl
  - Qt Debug Infomation Files：可选，体积较大，用于调试Qt源码
- Developers and Designer Tools
  - **Debugging Tools  For Windows** ：Windows调试工具
  - **CMake** ：构建工具，如果已有，则无需安装
  - Qt Installer Framework ：可选，用于将Qt程序打包为安装包

此外，笔者还建议在学习的初期，不要使用 **Designer（\*.ui）** 及 **Design Studio** ，它们会是你早期提升最大的阻力

### **开始**

- 新建一个`CMakeLists.txt` 及 `main.cpp` 文件
- `CMakeLists.txt` 中填入：

```cmake
cmake_minimum_required(VERSION 3.12)
project(QtExample)

add_executable(QtExample main.cpp)

find_package(Qt6 COMPONENTS Core Widgets REQUIRED)      #查找Qt6的模块

target_link_libraries(QtExample                         #将Core和Widget链接到QtExample中
    PRIVATE 
        Qt6::Core                     
        Qt6::Widgets
)
```

- `main.cpp`中填入：

```cpp
#include <QApplication>
#include <QWindow>

int main(int argc, char* argv[]) {
	QApplication a(argc, argv);
	QWindow window;
	window.setTitle("Hello Qt!");
	window.show();
	return a.exec();
}
```

- 使用`Cmake命令行`或者 `CMake GUI` 生成 Visual Studio工程
- 选择  **QtExample** 为启动项目，编译运行，就能看到：

![img](https://pic2.zhimg.com/80/v2-d3a028782f764121e4144fe2323e4be5_720w.webp)

**[QApplication](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qapplication.html)** 是Qt对整个程序的调度管控中心，通过它可以：

- 解析程序的输入参数（即上方的`argument count`，`argument value`）
- 管理对象之间的事件通信
- 处理程序的事件循环
- 能获取到所有的Window、Widget
- 提供程序进程相关的各类操作
- ...

> 对应 UE 中的 **GenericApplication**、**SlateApplication**

通过`QApplication::instance()`或宏 `qApp` ，能在程序中的任何地方对其进行操作，查看官方文档，你能知道它可以做什么：

- [https://doc.qt.io/qt-6/qapplication.html](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qapplication.html)

QApplication 继承自 QGuiApplication，它来自于 **Widgets模块** ，如果仅需要控制台程序，而非窗口，那么使用 **Core模块** 中的 **[QCoreApplication](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qcoreapplication.html)** 就够了

> 在实际开发应用时，可以派生QApplication，在其中添加一些全局的管理操作

`QApplication::exec()`将启动Qt的事件循环，它等价于：

```cpp
#include <QApplication>
#include <QWindow>

int main(int argc, char* argv[]) {
    QApplication a(argc, argv); 
    Q_ASSERT(QApplication::instance() == &a);

    QWindow window;
    window.setTitle("Hello Qt!");
    window.show();
    while (true) {                      //QApplication内部有一个退出信号，可惜它是私有的，这里就只能作为死循环了
        QApplication::processEvents();  //注释它,你会发现窗口无法再响应交互事件
    }
}
```

> 在开发过程中，可能经常会执行一些比较慢的操作，导致界面卡顿，这个时候就可以在这些操作中间手动调用一下`QApplication::processEvents()`让界面能够刷新

### **Object**

Qt中的绝大多数类都派生自 [QObject](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qobject.html) ，这样便于管理其所有子对象，并提供了反射、Signal-Slot、垃圾回收、事件等机制，一个QObject子类定义的示例如下：

```cpp
class QExmapleClass : public QObject {
	Q_OBJECT			//Q_OBJECT是Qt反射数据的入口，如果无需反射功能，可以不写
};
```

### **Meta Object System**

Qt 的元对象系统提供了Signal-Slot、运行时类型信息和动态属性系统等机制

如果想在 CMake作为构建系统的工程 中启用QObject的反射功能，需要在`CMakeLists.txt`的`add_executable`之前开启 [AUTOMOC](https://link.zhihu.com/?target=https%3A//cmake.org/cmake/help/latest/prop_tgt/AUTOMOC.html)：

```cmake
set(CMAKE_AUTOMOC ON)
```

`AUTOMOC`会自动检测头文件中是否存在 `Q_OBJECT` 之类的Qt宏，如果存在，则会使用Qt的反射编译器 **moc**  扫描该文件，扫描结束将生成一个 `*.moc` 文件，这里面包含了Qt反射数据的定义

你能在类似如下的路径中，找到Qt的moc，在当前目录打开cmd，执行 `moc -h`，就能看到它的帮助文档

![img](https://pic2.zhimg.com/80/v2-794f97591a93dae3924165840664de75_720w.webp)

moc的源码位于如下路径：

![img](https://pic4.zhimg.com/80/v2-9f1cd954511a2240c14634d845402ab7_720w.webp)

> UE 的反射编译器为 UHT（Unreal Header Tool）

对于那些写在`*.cpp`中的`Q_OBJECT`，需要在末尾手动`include` `*.moc`，才能触发 moc 的执行，例如：

```cpp
/* main.cpp
*/

#include <QApplication>
#include <QMetaType>
#include <QMetaProperty>

class QExmapleClass : public QObject {
    Q_OBJECT
    Q_PROPERTY(int Var READ getVar WRITE setVar)                //通过Getter、Setter生命MetaProperty
public:
    int getVar() {
        return mVar;
    }
    void setVar(int inVar) {
        mVar = inVar;
    }

    Q_INVOKABLE void sayHello(const QString& inName) {          //声明MetaMethod
        qDebug() << "Hello " << inName.toLatin1().data();
    }

    enum Number {
        Zero, One, Two, Three
    };
    Q_ENUM(Number)                                              //声明MetaEnum
protected:
    int mVar= 5;
};

int main(int argc, char* argv[]) {
    QApplication a(argc, argv);

    QExmapleClass obj;      

    //获取MetaObject
    const QMetaObject* metaObjectFromStatic = &QExmapleClass::staticMetaObject; 
    const QMetaObject* metaObjectFromVirtual = obj.metaObject();

    //读写属性
    obj.setProperty("Var", QVariant::fromValue<int>(10));                       
    QVariant var = obj.property("Var");
    qDebug() << "Property : " << var.value<int>();

    //调用函数
    qDebug() << "Invoke Method Begin:";
    metaObjectFromStatic->invokeMethod(&obj, "sayHello",Q_ARG(QString,"Boy"));
    qDebug() << "Invoke Method End";

    //MetaType操作
    QMetaType metaType = var.metaType();
    qDebug() << "Meta Type : " << metaType.name() <<" ID: " << metaType.id();

    //在MetaObject中遍历及读写属性，并打印属性类型
    for (int i = metaObjectFromStatic->propertyOffset() ; i < metaObjectFromStatic->propertyCount(); i++) {
        const QMetaProperty& metaProperty = metaObjectFromStatic->property(i);
        metaProperty.write(&obj, QVariant::fromValue<int>(15));
        QVariant varFromMetaObject = metaProperty.read(&obj);
        qDebug() << "Meta Property : " << metaProperty.name() << varFromMetaObject;
    }

    //在MetaObject中遍历函数，并打印参数信息
    for (int i = metaObjectFromStatic->methodOffset(); i < metaObjectFromStatic->methodCount(); i++) {
        const QMetaMethod& metaMethod = metaObjectFromStatic->method(i);
        QByteArrayList paramNames = metaMethod.parameterNames();
        QStringList paramsDefineList;
        for (int j = 0; j < metaMethod.parameterCount(); j++) {
            paramsDefineList << metaMethod.parameterTypeName(j) +" " + paramNames[j];
        }
        qDebug() << QString("Meta Method : %1 %2(%3)")
            .arg(metaMethod.typeName())
            .arg(metaMethod.name())
            .arg(paramsDefineList.join(',')).toLatin1().data();
    }

    //在MetaObject中遍历枚举，并打印枚举信息
    for (int i = metaObjectFromStatic->enumeratorOffset(); i < metaObjectFromStatic->enumeratorCount(); i++) {
        const QMetaEnum& metaEnum = metaObjectFromStatic->enumerator(i);
        qDebug()<< "Meta Enum : " << metaEnum.name();
        for (int j = 0; j < metaEnum.keyCount(); j++) {
            qDebug() << "-- " << metaEnum.key(j) << " : " << metaEnum.value(j);
        }
    }
    return a.exec();
}

#include "main.moc"     //必须包含main.moc才能触发moc编译
```

上述代码是一个基本的Qt反射使用示例，更详细的内容，请参阅：

- Qt Meta Object System：[https://doc.qt.io/qt-6/metaobjects.html](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/metaobjects.html)
- QMetaObject ：[https://doc.qt.io/qt-6/qmetaobject.html](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qmetaobject.html)
- Qt Property System：[https://doc.qt.io/qt-6/properties.html](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/properties.html)

### **Signal-Slot**

信号槽机制用于对象之间的通信，它是 Qt 的核心特性，关于它的作用，一个伪代码示例如下：

```cpp
class Student{
    Signal nameChanged(string OldName, string NewName);
public:
    void setName(string inName){
        nameChanged.Emit(mName，inName);
        mName = inName;
    }
private:
    string mName;
};

class Tearcher{
public:
    void OnStudentNameChanged(string OldName, string NewName){
        //do something
    }
};

class Class{
protected:    
    void connectEveryone(){
         for(auto Student:mStudents){       
             Student.nameChanged.Connect(mTeacher,&Tearcher::OnStudentNameChanged);
         }
    }
private:
    Teacher mTeacher;
    TArray<Student> mStudents;
};
```

通过connectEveryone函数，可以看做是："老师"在班级里面告诉学生，如果你们改名字了，请通知我。

这里没有直接修改Teacher和Student的结构，而是在第三方集合（班级）中进行二者关系的绑定，从而实现很好的解耦，

> 这一机制对应UE中的委托（Delegate），它相较于Qt的信号槽更细致一些，但译文有些槽点，如果也叫Signal的话，相信可以更容易勾起开发者的联想而采用正确的使用方式

对于更细节的说明，请查阅：

- [https://doc.qt.io/qt-6/signalsandslots.html](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/signalsandslots.html)

### **Event System**

在Qt中，事件是指抽象类[QEvent](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qevent.html)子类的实例对象，它用于描述应用程序内部或外部活动的结果。在作用上它可以看做是重量级的Single-Slot，QWigdet中的交互机制都是通过事件实现的。

当一个事件发生时，Qt通过构造适当的QEvent子类实例来表示它，并调用：

- [static bool QCoreApplication::sendEvent(QObject* receiver, QEvent event)](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qcoreapplication.%3Ci%3Ehtml%23sen%3C/i%3EdEvent)

来向对应的`QObject`发送事件，而QObject拥有一个虚函数：

- [virtual bool QObject::event( QEvent* e )](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qobje%3Ci%3Ec%3C/i%3Et.html%23event)

通过覆写`event`可以在其中处理事件或者进一步分发到其他函数

此外，Qt还支持事件监听器机制，可以覆写QObject的虚函数：

- [>bool QObject:: eventFilter ( QObject * watched , QEvent* event )](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qobject%3Ci%3E.html%23e%3C/i%3EventFilter)

使之可以作为`filterObj`，再调用：

- [void QObject:: installEventFilter ( QObject* filterObj )](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qobject.html%23%3Ci%3EinstallEv%3C/i%3EentFilter)

从而让该对象能作为其他的对象的事件监听者

关于事件系统，详见：

- [https://doc.qt.io/qt-6/eventsandfilters.html](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/eventsandfilters.html)

### **Garbage Collection**

在上一节内存管理中，已经提过Qt的GC，它的GC方式很简单，就是QObject可以指定唯一的parent，当parent释放时，还会释放children，此外，可以还可以使用 [QObject::deleteLater](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qobject.html%23deleteLater) 来延迟QObject的释放

在QWidget中，加入子控件会隐式设置parent，绝大多数情况下都不需要手动去delete，但需要注意控制parent的生命周期，对象树中的某个节点如果出现纰漏，那么整个子树的对象都无法被释放

### **Window**

在前面，我们使用了Win API简单创建了一个窗口，那些代码一点也不 **"现代"** ，大量的宏，奇怪的命名规范

**QPlatformWindow** 是 Qt 的跨平台Window底层封装的细节，Qt将其包裹一层用来提供接口，也就是 **[QWindow](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qwindow.html)**

> 这里对应UE的 **GenericWindow** 和 **SWindow**
> 你要说它两之间没 “奸情” 我肯定是不信的0.0

在Window的客户区域中，经常会有很多的小部件，比如下面的窗口：

![img](https://pic4.zhimg.com/80/v2-174039a768e5bac2cf46e0f7259763b3_720w.webp)

它拥有很多的按钮和控件，如果我们单纯使用一个窗口的点击事件（可获取到鼠标坐标）去判断点了窗口的哪个部分，再一点点处理绘制，当窗口的复杂度一上来，整个代码会显得异常混乱，管理困难，虽然Windows提供了SubWindow的机制，但由于维护一个Window的开销过大，所以，很多框架都提出了 **Widget** 的概念

> 对应Qt中的QWidget，UE中的 SWidget

Widget 可以看做是一个轻量级的Window，它具有以下特性：

- 在显示上，Widget可以看做是一个块，它本质上是分割Window的客户区域，该区域由Widget自行绘制。
- 在逻辑上，Widget具有树状层级，事件往往会自顶向下传递。

### **Widget**

**[QWidget](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qwidget.html)** 是Qt GUI的核心，Qt中的绝大多数的 可视部件 都派生于它

它的创建也很简单：

```cpp
#include <QApplication>
#include <QWidget>

int main(int argc, char* argv[]) {
	QApplication a(argc, argv);
	QWidget widget;
	widget.setWindowTitle("Hello QWigdet!");
	widget.show();
	return a.exec();
}
```

单个部件的开发，主要是设置 QWidget 的 [Properties](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qwidget.html%23protected-functions)：

![img](https://pic3.zhimg.com/80/v2-a91fea45fcbeb257d6906344d93d7716_720w.webp)

和覆写[Event](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qwidget.html%23protected-functions)：

![img](https://pic1.zhimg.com/80/v2-1a308df2cfb7376e816da859c272bca0_720w.webp)

来实现各种复杂的界面效果和交互逻辑

### **WindowOption**

在一般情况下，开发者甚至都不会接触到 `QWindow`，因为最外层 （or 最顶级）的 `QWidget` 会自动生成 `QWindow`，我们可以通过对这个QWidget做一些设置，来影响Window的生成：

- [WindowFlag](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qt.html%23WindowType-enum)：调整Window的标识，比如弹窗，对话框，提示框，无边框...
- [WindowModality](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qt.html%23WindowModality-enum)：设置模态窗口，模特窗口会阻塞其他窗口的输入，一般用于让用户在当前强制选择某些选项，才能继续执行
- [WindowState](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qt.html%23WindowState-enum)：Window的状态有：`默认`，`最小化`，`最大化`，`全屏（无边框）`，`激活`，可以调用`setWindowState`，Qt也提供了一些便捷API，例如 [activateWindow()](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qwidget.html%23activateWindow)

比如这样的代码：

```cpp
QWidget widget;
widget.setWindowFlags(Qt::FramelessWindowHint|Qt::Tool);
widget.resize(200,200);
widget.show();
```

你能在屏幕上看到一个200*200的灰色方块，并且你在下方的任务栏中，它的图标也被隐藏了

需要注意的是，在创建Widget的时候并没有创建Window，我们对Widget的设置绝大多数时候只是在调整它的属性状态机，只有在事件执行时，才会根据这些状态来进行实际的操作，就比如说，你得在show之后才能拿到Window的句柄

### **[Attribute](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qt.html%23WidgetAttribute-enum)** 

在Qt命名空间下，有一组以`WA_`开头的枚举值可以用来设置[WidgetAttribute](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qt.html%23WidgetAttribute-enum)，你可以给QWidget设置很多有用的属性，其中常用的：

- Qt::WA_DeleteOnClose：关闭窗口时，销毁该对象
- Qt::WA_TranslucentBackground：使窗口的背景变透明

### **Event**

GUI的显示在于 QWidget 的 [paintEvent](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qwidget.html%23paintEvent) ，我们可以通过覆写它，在里面使用通过 [QPainter](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qpainter.html) 绘制我们想要的任何图形

而GUI的本质无非就是借助于各类交互事件，调整属性状态机，切换 paintEvent 的绘制结果

这是一个很好的例子：

```cpp
#include <QApplication>
#include <QWidget>
#include <QMouseEvent>
#include <QPainter>

class QExmapleWidget:public QWidget {
    Q_OBJECT
private:
    QPoint mMousePressPos;
    bool bIsHovered = false;
protected:
    void mousePressEvent(QMouseEvent* event) override {
        if (event->button() == Qt::LeftButton)      //记录鼠标左键按下时的位置
            mMousePressPos = event->pos();          
    }
    void mouseMoveEvent(QMouseEvent* event) override {
        if (event->buttons() & Qt::LeftButton)      //鼠标左键按下拖拽时，调整Widget的位置
            move(event->pos() + this->pos() - mMousePressPos);
    }

    void enterEvent(QEnterEvent* event) override {
        bIsHovered = true;                          //鼠标进入Widget中
        setCursor(Qt::ClosedHandCursor);            //设置鼠标光标的形状
        update();                                   //请求刷新界面
    }

    void leaveEvent(QEvent* event) override {
        bIsHovered = false;                         //鼠标离开Widget
        setCursor(Qt::ArrowCursor);                 //设置鼠标光标的形状
        update();                                   //请求刷新界面
    }

    void paintEvent(QPaintEvent* event) override {
        QPainter painter(this);

        painter.fillRect(this->rect(),bIsHovered ? Qt::green : QColor(0,100,200));  //在区域内填充颜色

        painter.setPen(QPen(Qt::white));
        painter.setFont(QFont("",20,90));                                           //使用缺省字体并设置字号和权重
        painter.drawText(this->rect(), Qt::AlignCenter, "Hello Qt");                //绘制文字
    }
};

int main(int argc, char* argv[]) {
    QApplication a(argc, argv);
    QExmapleWidget widget;
    widget.setWindowFlags(Qt::FramelessWindowHint);         //无边框
    widget.setAttribute(Qt::WA_TranslucentBackground);      //背景透明      
    widget.setAttribute(Qt::WA_AlwaysStackOnTop);           //置顶
    widget.resize(200,200);
    widget.show();
    return a.exec();
}

#include "main.moc"
```

运行它你能看到如下效果：

![动图封面](https://pic3.zhimg.com/v2-8dac5f6a10f87695a9dab6e61d9a8852_b.jpg)





使用QWidget，可以实现我们想要的任何效果。

Qt官方的提供了很多基础控件供开发者使用：

- [https://doc.qt.io/qt-6/widget-classes.html](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/widget-classes.html)

![img](https://pic3.zhimg.com/80/v2-72ef5454960ba837485abc9c5d8e9ffe_720w.webp)

**Layout**

在一个程序中，往往不会只有一个QWidget，所以我们还需要组织这些Widget的布局，Qt中常用的布局是BoxLayout，这里有一个简单的示例：

```cpp
#include <QApplication>
#include <QWidget>
#include <QHBoxLayout>
#include <QPushButton>

class QMainWidget :public QWidget {
    Q_OBJECT
public:
    QMainWidget() {
        createUI();
    }
private:
    void createUI() {
        QHBoxLayout* hLayout = new QHBoxLayout(this);
        // QHBoxLayout* hLayout = new QHBoxLayout();            //等价
        //setLayout(hLayout);

        hLayout->setContentsMargins(5, 5, 5, 5);                //设置外边距
        hLayout->setSpacing(10);                                //设置内部元素间隔
        hLayout->setAlignment(Qt::AlignLeft|Qt::AlignVCenter);  //设置左对齐且垂直居中
        hLayout->addWidget(new QPushButton("A"));
        hLayout->addSpacing(20);                                //加入空白填充
        hLayout->addWidget(new QPushButton("B"));
        hLayout->addWidget(new QPushButton("C"));
    }
};

int main(int argc, char* argv[]) {
    QApplication a(argc, argv);
    QMainWidget widget;
    widget.resize(300, 300);
    widget.show();
    return a.exec();
}

#include "main.moc"
```

![img](https://pic1.zhimg.com/80/v2-a45b7fb0fe27e494d9197d69b43d2274_720w.webp)

布局的完整介绍，请查阅：

- [https://doc.qt.io/qt-6/layout.html](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/layout.html)

对于：

- 最外层的Widget
- 没有设置Layout，但具有层级关系的Widget

可以通过相对与parent左上角坐标来调整以下属性

- pos：[https://doc.qt.io/qt-6/qwidget.html#pos-prop](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qwidget.html%23pos-prop)
- geometry：[https://doc.qt.io/qt-6/qwidget.html#geometry-prop](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qwidget.html%23geometry-prop)

在同一层级的Widget，可以调用以下接口来调整Z Order：

- [raise()](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qwidget.html%23raise)：置顶
- [lower()](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qwidget.html%23lower)：置底

### **Style**

Qt的默认样式并不美观，但它支持使用 QSS 进行美化控件，详见：

- [https://doc.qt.io/qt-6/stylesheet.html](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/stylesheet.html)

## **进阶路线**

就跟第三节 C++基础所说的那样：大量刷题是学习编程最好的方式，这样可以快速地掌握C++的基本语法和各类数据结构与算法，消除自己的误解，塑造自己的编程思维

同样Qt也是，你无需根据某些书籍或教程按部就班的学习，大量的实践能让你快速了解某个框架的基本骨架

在学习框架的过程中，最最最重要的是：

- 示例
- 文档

在遇到问题的时候，往往能帮上你的是：

- 社区

### **文档**

在 **Qt Creator** 中，你只需选择代码中的Qt结构，按下 `F1`就能打开它的相关文档

在 **Visual Studio** 中，你需要安装 Qt Vs Tool 插件，在设置中开启：

![img](https://pic1.zhimg.com/80/v2-ebfc065103ef345883b353fa208e03f4_720w.webp)

![img](https://pic1.zhimg.com/80/v2-919dc2ad4ae1f1108cb82a7d4b7405b4_720w.webp)

### **示例**

这是Qt官方的示例教程页面：

- [https://doc.qt.io/qt-6/qtexamplesandtutorials.html](https://link.zhihu.com/?target=https%3A//doc.qt.io/qt-6/qtexamplesandtutorials.html)

![img](https://pic4.zhimg.com/80/v2-cb1a4bf7dbc62274c6da1842d1dac5df_720w.webp)

在Qt Creator中也有大量的使用示例：

![img](https://pic4.zhimg.com/80/v2-b58b1e3d4a46d253ca05c2e169734edb_720w.webp)

### **源码**

在达到一定阶段之后，好奇心总会驱使你打开这个目录：

![img](https://pic2.zhimg.com/80/v2-bcba2ef7a0bf3519b24650ac26d588b9_720w.webp)

在每个模块的`tests`目录下面，你能找到非常多可供运行的测试工程：

![img](https://pic3.zhimg.com/80/v2-1a34dabe24bdaf1873e6b9fbbcbaa35a_720w.webp)

**结尾**

看到这里，你还觉得Qt只是一个 GUI 框架吗？

Qt的GUI功能甚至都只是源码目录下的一小部分：

![img](https://pic2.zhimg.com/80/v2-867df7267cf25bb6a81f1216dd645451_720w.webp)

翻阅一下源码，你能体会到Qt有多么庞大~

在笔者眼里，它在代码层面并不比 Unreal Engine 逊色，由于它们适用于不同的行业，比较起来毫无意义

但无论你之后的目标是 Qt 还是 Unreal Engine 或是其他，只要方向是 C++ ，那么 Qt 不仅是一个完善的工具库，更是提升代码素养、架构能力的最好途径

https://zhuanlan.zhihu.com/p/605656730?utm_id=0

## 3. 信号与槽

## 一、Qt信号和槽机制&emit的使用

## （一）相关概念

**1.信号（Signal）就是在特定情况下被发射的事件**

例如PushButton 最常见的信号就是鼠标单击时发射的 clicked() 信号，一个 ComboBox 最常见的信号是选择的列表项变化时发射的  CurrentIndexChanged() 信号。GUI  程序设计的主要内容就是对界面上各组件的信号的响应，只需要知道什么情况下发射哪些信号，合理地去响应和处理这些信号就可以了。

**2.槽（Slot）就是对信号响应的函数。槽就是一个函数**

与一般的C++函数是一样的，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。

3.信号与槽之间的关联：是用 QObject::connect() 函数实现的，其基本格式是：

```text
QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));

//信号发出者，处理的信号， 信号接收者，处理动作方法（槽函数）。
```

注解：

1. sender 是发射信号的对象的名称
2. signal() 是信号名称。信号可以看做是特殊的函数，需要带括号，有参数时还需要指明参数。
3. receiver 是接收信号的对象名称，slot() 是槽函数的名称，需要带括号，有参数时还需要指明参数。
4. SIGNAL 和 SLOT 是 Qt 的宏，用于指明信号和槽，并将它们的参数转换为相应的字符串。

[qt技术开发老杰：Qt开发必备技术栈学习路线和资料4 赞同 · 1 评论文章![img](https://pic2.zhimg.com/v2-9f889095a515b24e28a2b823788ec3f9_180x120.jpg)](https://zhuanlan.zhihu.com/p/627818982)

## （二）注意点

**1.一个信号可以连接多个槽**, 当一个信号与多个槽函数关联时，**槽函数按照建立连接时的顺序依次执行**，例如：

- connect(spinNum, SIGNAL(valueChanged(int)), this, SLOT(addFun(int));
- connect(spinNum, SIGNAL(valueChanged(int)), this, SLOT(updateStatus(int));

**2.多个信号可以连接同一个槽**，

- connect(ui->rBtnBlue,SIGNAL(clicked()),this,SLOT(setTextFontColor()));
- connect(ui->rBtnRed,SIGNAL(clicked()),this,SLOT(setTextFontColor()));
- connect(ui->rBtnBlack,SIGNAL(clicked()),this,SLOT(setTextFontColor()))

**3. 一个信号可以连接另外一个信号**

**4.严格的情况下，信号与槽的参数个数和类型需要一致**，至少信号的参数不能少于槽的参数。如果不匹配，会出现编译错误或运行错误。

**5.使用signals/slots必须要加入宏Q_OBJECT**

**6. 当一个信号被发射时，与其关联的槽函数通常被立即执行，就像正常调用一个函数一样。只有当信号关联的所有槽函数执行完毕后，才会执行发射信号处后面的代码。**

**7.一定要有signals关键字**，定义信号时这个关键字不可或缺，比如我们定义一个信号void signal()，一定要在前面加上关键字“signals:”，

- signals:
- void signal();
- 就像类中的public、protected、pravate一样，但是一定不能在signals前面加上public、protected、private，publi signals:这样写是错误的

**8.slots可以写可以不写**，一般的函数也可以与signals下的信号关联，我们定义槽函数时可以像signals那样加上slots关键字，也可以不加，但是需要注意的是，如果加上了，那就必须加上public、protected、paivate

- public slots:
- void func();这样写slots:void func();这样写就是错的
- 当然不加上slots的一般函数也可以与信号关联

**9.signals下的函数必须是void类型，而且只需要给出声明即可，具体实现QT内部自己处理，但是槽函数一定要实现，从我们角度思考是这种信号处理是一致的，但是槽函数的功能确实根据我们需要自己设计，所以有了这种差异。**

**10.信号与槽的参数不能是宏和函数指针**

**11.信号一般与emit配合使用，使用emit发射信号给关联的槽**

**12.**connect若触发，它后面的不会再运行

## （三）自定义槽

可当作槽函数的：任意的成员函数，普通全局函数，静态函数。

槽函数需要和信号一致（参数列表，返回值）如果信号没有返回值，槽函数一定没有返回值。

【举例】：让按钮2点击一下，就能改变按钮上的文本。

1.首先，在.h文件中声明：



![img](https://pic2.zhimg.com/80/v2-584eec40b451468d8296840038b72dad_720w.webp)



2.在.cpp文件对该函数进行定义：



![img](https://pic4.zhimg.com/80/v2-b7162752182263c1ed0f8e72d56ce24f_720w.webp)



3.给按钮联结自定义的槽函数 mySlot：

```text
connect(b2, &QPushButton::released, this, &MainWidget::mySlot);
```

4.运行



![img](https://pic1.zhimg.com/80/v2-9daaf9f7b1b4f02eecc6b9169c69de18_720w.webp)



## （四）自定义信号

1.信号必须有signals关键字来声明

2.信号没有返回值，但可以有参数。

3.信号就是函数的声明，只需声明，无需定义。

## （五）emit发射信号

emit是Qt关键字，像其他关Qt扩展一样，它也会被C++预处理器转换成标准的C++代码。

使用：在A中对B使用信号

主要步骤：信号的创建，槽函数的创建，A类信号和B类槽函数的联接和使用

## 二、Connect几种方式

## （一）说明

```text
QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot()));

//信号发出者，处理的信号， 信号接收者，处理动作方法（槽函数）。
```

1. sender 是发射信号的对象的名称
2. signal() 是信号名称。信号可以看做是特殊的函数，需要带括号，有参数时还需要指明参数。
3. receiver 是接收信号的对象名称，slot() 是槽函数的名称，需要带括号，有参数时还需要指明参数。
4. SIGNAL 和 SLOT 是 Qt 的宏，用于指明信号和槽，并将它们的参数转换为相应的字符串。

1.

这应该是QT4.0最为传统的方法

```text
connect(ui->pushButton,SIGNAL(clicked()),this,SLOT(pushButon1_clicked()));
```

2.

这应该是QT5.0之后退出来的绑定方法，去掉了之前的宏

```text
connect(ui->pushButton_2,&QPushButton::clicked,this,&::MainWindow::pushButon2_clicked);
```

3.

C++11出来之后，新的特性就出来，static_cast 用法

```text
connect(ui->pushButton_3, QOverload<bool>::of(&QPushButton::clicked),this,&::MainWindow::pushButon3_clicked);
```

4.

lamda表达式

```text
connect(ui->pushButton_4, QOverload<bool>::of(&QPushButton::clicked),[=](bool check){
                   ui->textBrowser->setText("按钮4信号绑定成功");
           });
```

如果槽函数很简单，可以直接利用 lambda表达式进行连接，以减少代码量

这里需要注意 Lambda表达式是C++ 11 的内容，所以，需要再Pro项目文件中加入 CONFIG += C++ 11

## （二）例子

1.彻底退出

```text
connect(quitAction,&QAction::triggered,[=](){this->close(); });
```

2.跳转其他页面

```text
connect(m_button[0], &ClickLabel::clicked, this, [=]() {
        zoom(m_button[0]);
        m_guideScene->show();
        this->hide();
        });
```

3.connect嵌套

```text
//监听每个按钮的点击事件
        connect(menuBtn,&MyPushButton::clicked,[=](){
            ...
            //进入到游戏场景
            this->hide(); //将选关场景隐藏掉
            play = new PlayScene(i+1); //创建游戏场景
            //这里注意，每次点击按钮都会新建一个游戏场景对象指针，因此返回时应当删除
            ...
            play->show(); //显示游戏场景
            connect(play,&PlayScene::chooseSceneBack,[=](){
                this->setGeometry(play->geometry());//设定新窗口的坐标在屏幕上与原先窗口坐标相同
                this->show();
                delete play;
                play = NULL;
            });

        });
//点击返回//从子页面返回
connect(backBtn,&MyPushButton::clicked,[=](){
        QTimer::singleShot(500,[=](){
            emit this->chooseSceneBack();
        });
});
```

## 三、connect 第五个参数

## （一）函数原型

connect 函数原型如下，第五个（5种）参数根据接收者和发送者是否在同一个线程不同

```text
connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal,
        const typename QtPrivate::FunctionPointer<Func2>::Object *receiver, Func2 slot,
        Qt::ConnectionType type = Qt::AutoConnection)
```

## （二）Qt::ConnectionType 详解

**1.Qt::AutoConnection**

> 自动。一般不写就默认是这个，使用这个值会根据实际情况去判断，如果sender和receiver在同一个线程，则自动使用Qt::DirectConnection，如果不在一个线程，则自动使用Qt::QueuedConnection。

**2.Qt::DirectConnection**

> 直连。槽函数会在信号发送的时候直接被调用，槽函数运行于信号发送者所在线程。效果看上去就像是直接在信号发送位置调用了槽函数。这个在多线程环境下比较危险，可能会造成奔溃。

**3.Qt::QueuedConnection**

> 队列连接。槽函数在控制回到接收者所在线程的事件循环时被调用，槽函数运行于信号接收者所在线程。发送信号之后，槽函数不会立刻被调用，等到接收者的当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。

**4.Qt::BlockingQueuedConnection**

> 阻塞队列连接。槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。

**5.Qt::UniqueConnection**

> 唯一连接。这个flag可以通过按位或（|）与以上四个结合在一起使用。当这个flag设置时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是避免了重复连接。

## 四、disconnect函数

disconect函数的原型如下：

```text
bool QObject::disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)
```

## （一）使用方法

一般有四种用法：

**1.解除myObject对象的所有信号连接，调用后myObject对象发出的所有信号都得不到响应。**

```text
disconnect(myObject, 0, 0, 0);
//等同于
myObject->disconnect();
```

**2.解除myObject对象的mySignal信号的所有连接，调用后myObject对象发出的mySignal信号得不到响应。**

```text
disconnect(myObject, SIGNAL(mySignal()), 0, 0);
//等同于
myObject->disconnect(SIGNAL(mySignal()));
```

**3.解除myObject对象与myReceiver对象的信号连接，调用后myObject对象发出的所有信号得不到myReceiver对象的响应。**

```text
disconnect(myObject, 0, myReceiver, 0);
//等同于
myObject->disconnect(myReceiver);
```

**4.解除myObject对象的mySignal信号与myReceiver对象的mySlot槽的连接，调用后myObject对象发出的mySignal信号得不到myReceiver对象的mySlot槽的响应。**

```text
disconnect(myObject, SIGNAL(mySignal()), myReceiver, SLOT(mySlot()));
//等同于
myObject->disconnect(SIGNAL(mySignal(), myReceiver, SLOT(mySlot())));
```

上述4种用法中，**0是通配符，它表示任一信号、任一接收对象、任一槽**。

## 五、blockSignals

blockSignals的函数原型如下：

```text
bool QObject::blockSignals(bool block)
```

## （一）用法

```text
//object发出的信号被阻塞，系统不会调用任何连接到object的处理。
object->blockSignals(true);
 
//解除信号阻塞
object->blockSignals(false);
```

## 六、案例

//widget.h

```text
#ifndef WIDGET_H
#define WIDGET_H
 
#include <QWidget>
 
class Widget : public QWidget
{
    Q_OBJECT
 
public:
    Widget(QWidget *parent = 0);
    ~Widget(){}
};
 
#endif // WIDGET_H
```

//widget.cpp

```text
#include "widget.h"
 
#include <QPushButton>
#include <QGridLayout>
#include <QDebug>
 
Widget::Widget(QWidget *parent)
    : QWidget(parent)
{
    /* 创建控件 */
    QPushButton *btnClick      = new QPushButton("click me", this);
    QPushButton *btnBlock      = new QPushButton("block", this);
    QPushButton *btnUnblock    = new QPushButton("unblock", this);
    QPushButton *btnDisconnect = new QPushButton("disconnect", this);
 
    QGridLayout *pLayout = new QGridLayout();
    pLayout->addWidget(btnClick, 0, 0);
    pLayout->addWidget(btnBlock, 0, 1);
    pLayout->addWidget(btnUnblock, 0, 2);
    pLayout->addWidget(btnDisconnect, 0, 3);
    this->setLayout(pLayout);
 
    /* 信号槽 */
    connect(btnClick, &QPushButton::clicked, this, [=]()
    {
        qDebug() << "点击按钮";
    });
 
    connect(btnBlock, &QPushButton::clicked, this, [=]()
    {
        btnClick->blockSignals(true);
        btnBlock->setEnabled(false);
        btnUnblock->setEnabled(true);
    });
 
    connect(btnUnblock, &QPushButton::clicked, this, [=]()
    {
        btnClick->blockSignals(false);
        btnBlock->setEnabled(true);
        btnUnblock->setEnabled(false);
    });
 
    connect(btnDisconnect, &QPushButton::clicked, this, [=]()
    {
        disconnect(btnClick, &QPushButton::clicked, this, 0);
    });
 
}
```

//main.c

```text
#include "widget.h"
#include <QApplication>
 
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    Widget w;
    w.show();
 
    return a.exec();
}
```

结果：



![img](https://pic3.zhimg.com/80/v2-1886695e829f0a2ed6c9129df0fd4d56_720w.webp)



1.按下"click me"按钮，窗口接收到"click me"按钮发出的clicked信号，打印"点击按钮"。

2.然后再按下"block",再次按下"click me"按钮，没有打印"点击按钮"。这是因为 "click me"按钮发出的信号被阻塞了，没有得到响应。

3.然后再按下"unblock"按钮，再次按下"click me"按钮，打印"点击按钮"。这是因为解除了"click me"按钮的信号阻塞。

4.最后按下"disconnect"按钮，此时按下"click me"按钮没有反应。这是因为解除了本窗口与"click me"按钮的clicked信号的连接。

https://zhuanlan.zhihu.com/p/649041904



# 第五章：大容量数据存储

## 1. SQL

1.SQLite数据库简介 

 

    轻量化，易用的嵌入式数据库，用于设备端的数据管理，可以理解成单点的数据库。传统服务器型数据
    库用于管理多端设备，更加复杂
    SQLite 是一个无服务器的数据库，是自包含的。这也称为嵌入式数据库，这意味着数据库引擎作
    为应用程序的一部分运行。
    MySQL 需要运行服务器， MySQL 将需要客户端和服务器架构通过网络进行交互。
    基于嵌入式的数据库主要有： SQLite ， Firebird ， Berkeley DB ， eXtremeDB
    Firebird 是关系型数据库，功能强大，支持存储过程， SQL 兼容等
    SQLite 关系型数据库，体积小，支持 ACID 事务
    Berkeley DB 并没有数据库服务器的概念，他的程序直接链接到应用程序中
    eXtremeDB 是内存数据库，运行效率高

2.下载方式

    https://www.sqlite.org/download.html
    
    1. 把下载的文件 sqlite-autoconf-3390000.tar.gz 上传到开发板
    2. tar xvf sqlite-autoconf-3390000.tar.gz 解压
    3. cd sqlite-autoconf-3390000 进入文件夹
    4. ./configure --prefix=/usr/local 配置安装路径在 /usr/local
    5. make 编译 // 比较久 10 分钟
    6. sudo make install 安装


​     

3.SQLite的命令用法 

创建库：

方法1：

    1. sqlite3 进入数据库
    2. .open test.db
    3. .quit
    数据库退出后在命令当前路径创建数据库 test.db

方法2：

    sqlite3 test.db // 在命令运行当前窗口创建数据库 test.db
    在数据库命令下
    .databases 列出当前打开的数据库
    .quit 退出

SQLite有两种语法

创建一张表格 

    语法1：
    create table stu2(id Integer,name char,score Integer);
    .table可以查看创建了几个表格。
    .schema可以查看表格内容
    
    语法2:
    它创建了一个 COMPANY 表，ID 作为主键，NOT NULL 的约束表示在表中创建纪录时这些字段不能为 NULL;
    CREATE TABLE COMPANY(
       ID INT PRIMARY KEY     NOT NULL,
       NAME//名字           TEXT    NOT NULL,
       AGE//年龄            INT     NOT NULL,
       ADDRESS//地址      CHAR(50),
       SALARY//薪水         REAL
    );

插入/写入一条记录  （增加一行）

    方法一：
    insert into stu values(18130106,'huang',99);
    insert into stu2 values(18130101,"gang",100); '' 和 "" 都行
    insert into stu(name,score) values("huanggang",98); 插入部分字段内容  
    
    方法二:
    INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
    VALUES (1, 'Paul', 32, 'California', 20000.00 );
    
    INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
    VALUES (2, 'Allen', 25, 'Texas', 15000.00 );
    
    INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
    VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );
    
    INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
    VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );
    
    INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
    VALUES (5, 'David', 27, 'Texas', 85000.00 );
    
    INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
    VALUES (6, 'Kim', 22, 'South-Hall', 45000.00 );

 查看/选择数据库的记录

    select * from stu; // 查询所有字段的结果
    select name,score from stu; // 查询数据库中部分字段的内容

删除一条记录

    delete from stu where id = 18130101;  

更改一条记录

    update stu set name = 'huangg' where id = 18130106; 

删除一张表

    drop table stu; 

增加一列

     alter table stu add column sex char;
    
    qlite3_open ( const char * filename , sqlite3 ** ppDb )
    该例程打开一个指向 SQLite 数据库文件的连接，返回一个用于其他 SQLite 程序的数据库连接对象。
    sqlite3_close ( sqlite3 * )
    该例程关闭之前调用 sqlite3_open () 打开的数据库连接。所有与连接相关的语句都应在连接关闭之前完
    成。
    如果还有查询没有完成， sqlite3_close () 将返回 SQLITE_BUSY 禁止关闭的错误消息。
    const char * sqlite3_errmsg ( sqlite3 * );
    sqlite3_errcode () 通常用来获取最近调用的 API 接口返回的错误代码
    错误代码表
    
    sqlite3_exec(sqlite3*, const char *sql, sqlite_callback, void *data, char **errmsg)
    
    该例程提供了一个执行 SQL 命令的快捷方式， SQL 命令由 sql 参数提供，可以由多个 SQL 命令组成。
    在这里，第一个参数 sqlite3 是打开的数据库对象， sqlite_callback 是一个回调， data 作为其第一 个参数，errmsg 将被返回用来获取程序生成的任何错误。
    sqlite3_exec () 程序解析并执行由 sql 参数所给的每个命令，直到字符串结束或者遇到错误为止。
    int callback ( void * arg , int column_size , char * column_value [], char
    * column_name [])
    参数分析：
    void * arg ：是 sqlite3_exec 函数的第四个参数
    column_size ：数据库的字段 数
    column_value [] ：列的值
    column_name ：字段名字

1.学生成绩管理系统（SQLite3）


    #include "stdio.h"
    #include "stdlib.h"
    #include "sqlite3.h"
    #define DATABASE "stu.db"
    int do_insert(sqlite3*db)//插入新一条学生数据
    {
            char*errmsg;
            int id;
            char name[32]={};
            int score;
            char sql[128]={};
            printf("Input id:");
            scanf("%d",&id);
            getchar();
            printf("Input name:");
            scanf("%s",name);
            getchar();
            printf("Input score:");
            scanf("%d",&score);
            getchar();
            sprintf(sql,"insert into stu(id,name,score)values(%d,'%s',%d);",id,name,score);
            if(sqlite3_exec(db,sql,NULL,NULL,&errmsg)!=SQLITE_OK){
                    printf("%s\n",errmsg);
                    return -1;
            }
            else{
                    printf("Insert succesful\n");
            }
            return 0;
    }
    int do_delete(sqlite3*db)//删除一条学生数据
    {
             char*errmsg;
             int id;
             char sql[128]={};
             printf("Input id:");
             scanf("%d",&id);
             getchar();
    sprintf(sql,"delete from stu where id=%d;",id);
             if(sqlite3_exec(db,sql,NULL,NULL,&errmsg)!=SQLITE_OK){
                     printf("%s\n",errmsg);
                     return -1;
             }
             else{
                      printf("Delete succesful\n");
             }
             return 0;
     
    }
    int do_update(sqlite3*db)//更新一个学生的成绩
    {
             char*errmsg;
             int id,score;
             char sql[128]={};
             printf("Input id:");
             scanf("%d",&id);
             getchar();
             printf("Input new score:");
             scanf("%d",&score);
             getchar();
             sprintf(sql,"update stu set score=%d where id=%d;",score,id);
             if(sqlite3_exec(db,sql,NULL,NULL,&errmsg)!=SQLITE_OK){
                     printf("%s\n",errmsg);
                     return -1;
             }
             else{
                      printf("Update succesful\n");
             }
             return 0;
    }
    int callback(void * para,int columncount,char ** columnvalue,char ** columnname)
    {
            for(int i=0;i<columncount;i++)
            {
                    printf("%-11s",columnvalue[i]);
            }
     printf("\n");
            return 0;
    }
    int do_query(sqlite3*db)//打印所有学生数据
    {
            char*errmsg;
            if(sqlite3_exec(db,"select * from stu;",callback,NULL,&errmsg)!=SQLITE_OK){
                     printf("%s\n",errmsg);
                     return -1;
            }
            else{
                     printf("Update succesful\n");
            }
            return 0;
    }
    int main(int argc,char**argv)
    {
            sqlite3 *db;
            char *errmsg;
            int option;
            if(sqlite3_open(DATABASE,&db)!=SQLITE_OK){//打开或新建数据库
                    printf("%s\n",sqlite3_errmsg(db));
                    exit(-1);
            }
            else{
                    printf("Open DATABASE success!\n");
            }
            if(sqlite3_exec(db,"create table stu(id Integer,name char,score Integer);",NULL,NULL,&errmsg)!=SQLITE_OK){//创建一张表
                    printf("%s\n",errmsg);
            }
            else{
                    printf("create table successful!\n");
            }
            while(1){
                    printf("*********************************************\n");
                    printf("1.Insert 2.delete 3.query 4.update 5.quit\n");
                    printf("Input Option:\n");
                    scanf("%d",&option);
    getchar();
                    switch(option){
                            case 1:
                                    do_insert(db);
                                    break;
                            case 2:
                                    do_delete(db);
                                    break;
                            case 3:
                                    do_query(db);
                                    break;
                            case 4:
                                    do_update(db);
                                    break;
                            case 5:
                                    sqlite3_close(db);
                                    exit(1);
                            default:
                                    printf("Input error!\n");
                    }
            }
     
            return 0;
    }

2.从SQLite3数据库中读取数据并将存储到链表中

    #include <stdio.h>
    #include <stdlib.h>
    #include <sqlite3.h>
     
    typedef struct Node {
        int id;
        char name[100];
        struct Node *next;
    } Node;
    //stpedef struct Node Node;的意思是Node代替struct Node这个结构体定义struct Node t1=Node t1
     
    Node *head = NULL;//定义一个结构体指针为链表头
    /*头插法*/
    void addNode(int id, char *name) {
        Node *newNode = (Node *)malloc(sizeof(Node));//定义一个结构体指针并开辟空间
        newNode->id = id;
        strcpy(newNode->name, name);
        newNode->next = head;//新的指针指向原来的头
        head = newNode;//新的指针被定义为头，实现了头插法
    }
     
    //exec的回调函数
    static int callback(void *NotUsed, int argc, char **argv, char **azColName) {
        int id = atoi(argv[0]);//atoi将数字字符串转换为整数
        char *name = argv[1];
        addNode(id, name);
        return 0;
    }
     
    int main() {
        sqlite3 *db;
        char *zErrMsg = 0;
        int rc;
     
        rc = sqlite3_open("test.db", &db);//打开指定数据库文件
     
        if (rc ！= SQLITE_OK) {
            fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
            return 0;
        }else
        {
            printf("open success!\n");
        }    
     
        char *sql = "SELECT * FROM students";
        rc = sqlite3_exec(db, sql, callback, 0, &zErrMsg);
     
        if (rc != SQLITE_OK) {
            fprintf(stderr, "SQL error: %s\n", zErrMsg);
            sqlite3_free(zErrMsg);
        }else
     
        sqlite3_close(db);//关闭数据库
     
        Node *current = head;//再定义一个结构体指针指向链表头
        while (current != NULL)//遍历链表，打印链表数据
        {
            printf("ID: %d, Name: %s\n", current->id, current->name);
            current = current->next;
        }
     
        return 0;
    }
    
    首先，程序定义了一个 Node 结构体，表示链表中的结点。每个结点包含一个整数类型的 id 字段，一个字符数组类型的 name 字段和一个指向下一个结点的指针 next。
    
    接下来，程序定义了一个全局变量 head，表示链表的头指针。初始时，头指针被设置为 NULL。
    
    然后，程序定义了一个 addNode 函数，用于向链表中添加新结点。该函数接受两个参数：一个整数 id 和一个字符串 name。函数首先使用 malloc 函数为新结点分配内存空间，并将传入的 id 和 name 参数分别赋值给新结点的对应字段。然后，使用头插法将新结点插入到链表中。
    
    接下来，程序定义了一个回调函数 callback。该函数会在 SQLite 数据库查询时被调用，并接收查询结果作为参数。函数首先从参数中提取出查询结果中的 id 和 name 字段，并调用 addNode 函数将这些数据添加到链表中。
    
    在 main 函数中，程序首先打开 SQLite 数据库，并检查是否打开成功。然后，定义一个 SQL 查询语句，并使用 sqlite3_exec 函数执行该查询语句。在执行查询时，SQLite 会调用之前定义的回调函数，并将查询结果传递给回调函数。
    
    查询完成后，程序关闭 SQLite 数据库，并遍历链表，打印出每个结点中存储的数据。

3.将链表中的数据传给SQLite3数据库

    #include <stdio.h>
    #include <stdlib.h>
    #include <sqlite3.h>
     
    typedef struct node//定义结构体变量，通过typedef 将struct node 定义为 Node，struct node t1 = Node t1
    {
        int data;
        struct node *next;
    }Node;
     
    Node *head = NULL;//定义一个结构体指针变量指向链表头部
    int insert_to_lianbiao(int data)//头插法动态建立链表，将数据插入链表 
    {
        Node *new = (Node*)malloc(sizeof(Node));
        new -> data = data;
        new -> next = head;
        head = new;
    }
     
    void disp()//遍历链表并打印数据
    {
        Node *temp = head;
        while(temp != NULL)
        {
            printf("%d\n",temp->data);
            temp = temp->next;
        }
    }
     
    void send_to_db(sqlite3* db) //通过sqlite3_exec()接口函数先创建一张表文件，再向表中写入数据
    {
        char *errorMes;
        char* sql = "create table test(data Integer);";
        int ret,res;
        char buffer[1024];
        Node *temp = head;//定义一个结构体指针变量指向链表头
        ret = sqlite3_exec(db,sql,NULL,0,&errorMes);
        if(ret != SQLITE_OK)
        {
            printf("error:%s\n",errorMes);
            exit(-1);
        }
     
        while(temp != NULL)
        {
            sprintf(buffer,"insert into test values(%d)",temp->data);//将数据和命令写入buffer
            res = sqlite3_exec(db,buffer,NULL,0,&errorMes);//再通过exec执行
            if(res != SQLITE_OK)
            {
                printf("error:%s\n",errorMes);
                sqlite3_free(errorMes);
                exit(-1);
            }
            temp = temp -> next;//遍历链表
        }
    }
     
    int main()
    {
        sqlite3 *db;
        int rc;
     
        insert_to_lianbiao(1);//向链表写入数据
        insert_to_lianbiao(2);
        insert_to_lianbiao(3);
     
        disp();
     
        rc = sqlite3_open("test.db",&db);//打开数据库文件
        if(rc != SQLITE_OK)
        {
            printf("Open error!\n");
            exit(-1);
        }else
        {
            printf("Open success!\n");
        }
     
        send_to_db(db);//向数据库写入数据
     
        sqlite3_close(db);//关闭数据库
        return 0;
    }
    
    这个程序的主要目的是将链表中的数据发送到SQLite3数据库。下面是程序中每一步的详细解释：
    
        首先，我们定义了一个名为Node的结构体，它包含一个整型数据data和一个指向下一个节点的指针next。
        然后，我们定义了一个全局变量head，它是链表的头节点。
        接下来，我们定义了一个名为insert的函数，它用于在链表的头部插入新节点。这个函数接受一个整型参数data，表示要插入的数据。函数内部首先创建一个新节点，并将其数据设置为data，然后将其指向当前的头节点，并将头节点更新为新节点。
        然后，我们定义了一个名为display的函数，它用于打印链表中的所有数据。函数内部使用一个临时指针遍历链表，并打印每个节点的数据。
        接下来，我们定义了一个名为send_to_db的函数，它用于将链表中的数据发送到SQLite3数据库。这个函数接受一个指向sqlite3数据库对象的指针作为参数。函数内部首先定义了一条SQL语句，用于创建一个名为test的表，如果该表不存在。然后执行这条SQL语句。接着，函数使用一个临时指针遍历链表，并对于每个节点，都构造一条SQL插入语句，并执行该语句，将节点中的数据插入到数据库中。
        在主函数中，我们首先调用insert函数三次，向链表中插入三个数据：1、2和3。然后调用display函数打印链表中的所有数据。
        接下来，我们调用sqlite3_open函数打开一个名为test.db的SQLite3数据库。如果打开失败，则打印错误信息并退出程序；否则打印成功信息。
        然后，我们调用之前定义的send_to_db函数，将链表中的数据发送到数据库中。
        最后，我们调用sqlite3_close函数关闭数据库。
    
    这是一个简单的示例程序，它演示了如何在C语言中使用SQLite数据库和链表。该程序创建了一个简单的数据库，其中包含一个表，用于存储用户信息（姓名和年龄）。程序还定义了一个链表结构，用于在内存中存储用户信息。程序包含了从数据库中查询数据并将其存储在链表中，以及将链表中的数据插入到数据库中的功能。


​     
​    #include <stdio.h>
​    #include <stdlib.h>
​    #include <string.h>
​    #include <sqlite3.h>
​     
​    typedef struct User {
​        char name[100];
​        int age;
​        struct User *next;
​    } User;
​     
​    User *create_user(const char *name, int age) {
​        User *user = malloc(sizeof(User));
​        strcpy(user->name, name);
​        user->age = age;
​        user->next = NULL;
​        return user;
​    }
​     
​    void free_users(User *users) {
​        User *tmp;
​        while (users != NULL) {
​            tmp = users;
​            users = users->next;
​            free(tmp);
​        }
​    }
​     
​    void print_users(User *users) {
​        while (users != NULL) {
​            printf("Name: %s, Age: %d\n", users->name, users->age);
​            users = users->next;
​        }
​    }
​     
​    int select_callback(void *data, int argc, char **argv, char **col_name) {
​        User **users = data;
​        User *user = create_user(argv[0], atoi(argv[1]));
​        user->next = *users;
​        *users = user;
​        return 0;
​    }
​     
​    User *select_users(sqlite3 *db) {
​        User *users = NULL;
​        char *err_msg = NULL;
​        if (sqlite3_exec(db, "SELECT name, age FROM users", select_callback, &users, &err_msg) != SQLITE_OK) {
​            fprintf(stderr, "Failed to select data: %s\n", err_msg);
​            sqlite3_free(err_msg);
​            free_users(users);
​            return NULL;
​        }
​        return users;
​    }
​     
​    int insert_user(sqlite3 *db, const char *name, int age) {
​        char sql[1024];
​        snprintf(sql, sizeof(sql), "INSERT INTO users(name, age) VALUES('%s', %d)", name, age);
​        char *err_msg = NULL;
​        if (sqlite3_exec(db, sql, NULL, NULL, &err_msg) != SQLITE_OK) {
​            fprintf(stderr, "Failed to insert data: %s\n", err_msg);
​            sqlite3_free(err_msg);
​            return -1;
​        }
​        return 0;
​    }
​     
​    int main() 
​    {
​        sqlite3 *db;
​        if (sqlite3_open(":memory:", &db) != SQLITE_OK) 
​       {
​            fprintf(stderr, "Failed to open database: %s\n", sqlite3_errmsg(db));
​            return -1;
​        }
​     
​        char *err_msg = NULL;
​        if (sqlite3_exec(db, "CREATE TABLE users(name TEXT, age INTEGER)", NULL, NULL, &err_msg) != SQLITE_OK)
​        {
​            fprintf(stderr, "Failed to create table: %s\n", err_msg);
​            sqlite3_free(err_msg);
​            sqlite3_close(db);
​            return -1;
​        }
​     
​        insert_user(db, "Alice", 20);
​        insert_user(db, "Bob", 30);
​     
​        User *users = select_users(db);
​        print_users(users);
​        free_users(users);
​    }
​    
​    select_callback 函数是 SQLite 的回调函数，它在执行 sqlite3_exec 函数时被调用。该函数的第三个参数 argv 是一个字符串数组，其中包含了查询结果中的一行数据。argv 数组中的每个元素都对应查询结果中的一列。
​    
​    在这个示例程序中，我们执行了如下查询语句：
​    
​    "SELECT name, age FROM users"
​    
​    这条查询语句从 users 表中查询了两列数据：name 和 age。因此，当 select_callback 函数被调用时，argv[0] 包含了查询结果中的 name 列的值，而 argv[1] 包含了查询结果中的 age 列的值。
​    
​    例如，如果查询结果包含如下数据：
​    
​        name | age
​        -----|-----
​        Alice| 20
​        Bob  | 30
​    
​    那么当 select_callback 函数第一次被调用时，argv[0] 的值为 "Alice"，而 argv[1] 的值为 "20"。当 select_callback 函数第二次被调用时，argv[0] 的值为 "Bob"，而 argv[1] 的值为 "30"。
​    
​    callback这个回调函数有几列就会执行几次，第一次argv[0]获取第一列的数据，第二次argv[1]获取第二列的数据，但是必须return0，不然会出错，只运行1次
————————————————
版权声明：本文为CSDN博主「TX564」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_63303786/article/details/130335195

# 第六章：软件框架设计

## 1. C 程序的背后

**1.4　第一次的亲密接触——Hello，World**

无论是学习任何编程语言，我们基本上都是从一个最简单的HelloWorld程序开始的，可以说，HelloWorld程序恐怕是这个世界上最普通最简单的一个程序了，同样她也是程序员们的初恋。

（HelloWorld程序最早出现在Brian W. Kernighan和Dennis M. Ritchie所著的《The C Programming  Language》一书中。后因C语言的广泛使用而逐渐成为各种程序设计语言中最基本、最简单的程序，因而亦通常是初学者所编写的第一个程序。同时，它还可以用来验证该语言的编译器、程序开发环境，以及运行环境是否已经安装配置妥当，是否可以开始我们的学习开发之旅。）

为了学习C语言，让我们先来看看谭老师是如何向我们介绍这位初恋情人的。

### 1.4.A　最简单的C语言程序背后的故事——它的汇编代码是如何被执行的

在这个小节中，谭老师列出了C语言中比较简单的三个小程序，分别实现了简单的输出、简单的加法运算，以及数据的输入输出和对数据的处理（比较获得两个数据中较大的一个）。虽然谭老师对这些程序作了详细的解释，但是我们心中可能还是有很多疑问：一个C语言程序为什么从main()函数开始？它到底是如何执行的？要想获得自由，我们必须知道事情的真相。我们现在就来学一次庖丁解牛，将一个C语言程序分解开，看看它背后隐藏的秘密。

在书中，我们首先接触到的最简单的C语言程序是：

```c
#include <stdio.h>
int main()
{
 printf("This is a C program. \n");
 
 return 0; 
}
```

这个C语言程序只有短短的7行代码，实现的也只是简单地向屏幕输出一个字符串，但是别小看这个简单的C语言程序，在它的背后，也有着同样精彩的故事。

在Visual C++  6.0调试模式下的汇编视图（Disassembly）中，我们可以清楚地看到每个C语言程序背后的故事。在汇编视图中，我们可以看到C语言程序中的各条语句所对应的汇编代码。这下，各条语句做了什么事情、各个功能是如何实现的，都一目了然了。C语言程序语句所对应的汇编语句，反映了C语言程序语句操作硬件的实质，也就是C语言程序背后的故事。这个号称最简单的程序虽然只是简单地输出一个字符串，但是当我们把这个程序拆解开，却可以发现它背后做了很多事情。在汇编视图下这个最简单的程序是这样的（汇编代码太长了，我只保留其中的关键操作）：

```text
// 每一个程序的入口地址mainCRTStartup
mainCRTStartup:
00401120 push ebp
00401121 mov ebp,esp
// …
// 调用GetVersion()函数，获得操作系统版本
00401146 call dword ptr [__imp__GetVersion@0 (0042513c)]
// …
// 进行堆的初始化
0040119E call _heap_init (00403c40)
// …
// 向程序传递参数
004011D5 call _setargv (004031a0)
004011DA call  _setenvp (00403050)
004011DF call _cinit (00402c70)
// …
// 开始进入main函数的入口地址执行main函数
00401204 call @ILT+0(_main) (00401005)
// …
// 退出整个程序的执行
00401213 call exit (00402cb0)
// …
```

这段汇编代码，几乎就是一个C语言程序的一生。当我们启动一个程序后，操作系统会创建一个新的进程来执行这个程序。所谓进程，就是应用程序的一个实例。操作系统创建进程的时候，会为其分配一定的内存空间（默认堆），作为其私有的虚拟地址空间。通常，一个应用程序的执行对应于一个进程，进程负责管理这个程序运行时的一切事物，例如资源的分配与调度等等。但是，作为程序执行的调度者，它并不负责程序的执行，具体的执行工作是由它创建的线程来完成的。每个进程都有一个主线程，如果是多线程应用程序，还可以有多个辅助线程。线程并不拥有资源（它使用的是它所属进程的资源），但是它拥有自己的执行入口、执行的顺序系列和一个终点。一个进程的内存分布如下图所示：

![img](https://pic3.zhimg.com/80/v2-fcbaaa413355eb4df33ee25a396028aa_720w.webp)

程序的进程与线程

当进程的主线程被创建之后，它会首先寻找程序当中的入口地址。我们知道，程序实质上就是一系列计算机指令，程序的入口地址代表了从哪一条指令开始执行。通常，每个程序中都有mainCRTStartup这样一个地址，这个默认的入口函数地址是编译器插入到程序中的（其中完成了一些必要的初始化和清理工作）。主线程就是找到这个地址并从这里开始向下逐条执行程序当中的指令。在这个函数执行的时候，首先会执行一些初始化工作，例如获得操作系统的信息、对堆进行初始化以及完成程序参数的传递等等。然后，就是最关键的对主函数的调用，一句call  @ILT+0(_main)就是跳转到main()函数的入口地址，开始进入main()函数的执行了。mainCRTStartup所做的事情我们无法控制，而main()函数就是我们的一亩三分地，可以自由发挥了。接下来我们来看看main()函数到底是如何执行的。

```text
// main()函数入口地址
@ILT+0(_main):
00401005 jmp main (00401010)
// …
--- e:\sourcecode\clan\clan.c ---------------------------------------------------
1: #include <stdio.h>
2: int main()
3: {
00401010 push ebp
00401011 mov   ebp,esp
00401013 sub esp,40h
00401016 push ebx
00401017 push esi
00401018 push edi
00401019 lea edi,[ebp-40h]
0040101C mov ecx,10h
00401021 mov eax,0CCCCCCCCh
00401026 rep stos dword ptr [edi]
4: printf("This is a C program. \n");
00401028 push offset string "This is a C program. \n" (00420f7c)
0040102D call printf (00401060)
00401032 add esp,4
5:
6: return 0;
00401035 xor eax,eax
7: }
00401037 pop edi
00401038 pop esi
00401039 pop ebx
0040103A add  esp,40h
0040103D cmp ebp,esp
0040103F call __chkesp (004010e0)
00401044 mov esp,ebp
00401046 pop ebp
00401047 ret
--- No source file ----
```

从汇编代码中我们可以看到，主函数的执行，也不过是对于一些寄存器的操作和对库函数的调用而已。例如，在main()函数的第一句就是用“push  ebp”保存当前地址。在汇编代码中，ebp代表了当前地址。为什么在进入main()函数后的第一件事不是我们在C语言程序代码中看到的输出一个字符串，而是保存当前地址呢？实际上，我们从C语言程序代码中看到的只是我们对于要实现的功能的描述，而真正地要实现这些功能，C语言程序背后所对应的汇编代码还要为我们完成很多事情。这里的“push  ebp”保存当前地址，就是为了让这个main()函数执行完毕后可以顺利返回（也就相当于在出发的地方插上一个标签，好让我们可以找到回来时的路）。除了对于寄存器的操作（push、move以及pop等汇编指令）之外，汇编代码中更重要的是对其他函数的调用，这都是通过call指令来实现的。例如，“call printf  (00401060)”这个call指令就是调用printf函数，进入printf函数的执行以输出字符串。因为printf函数是由C语言函数库提供的一个函数，我们这里看不到它的具体代码，但是其内部与上面的main()函数都是相似的。

虽然我们的源代码中只有一行代码，但是编译后的程序在背后却做了很多事情。而正是因为汇编代码太过繁琐，我们才更加钟爱简洁易懂的C语言程序代码。而至于如何将C语言源代码转变成可以执行的汇编代码或目标机器代码，这些复杂的事情就让任劳任怨的编译器去完成吧。

发布于 2021-11-18 14:43

https://zhuanlan.zhihu.com/p/434786789

## 2. 面向对象编程

信很多刚开始接触编程的小伙伴，对于什么是面向对象，什么是面向过程都是一脸懵逼的。

网上关于这两个的回答真的很多，但是都有一个共同特点：------------不容易懂。

让我们来看看某百科给出的定义:

![img](https://pic2.zhimg.com/80/v2-667208067791101baa86c8631bf62af5_720w.webp)

![img](https://pic1.zhimg.com/80/v2-0e3028b50c3c362b3ccd7b505843722c_720w.webp)

是不是听不懂？？为了解决大家的疑惑，小编今天上网收集了一些资料，现在就简单通俗的为大家介绍一下**到底什么是面向对象编程和面向过程编程**

## 一、先来两小段通俗解释

**面向过程（Procedure Oriented 简称PO ：如C语言）：**

​    从名字可以看出它是注重过程的。当解决一个问题的时候，面向过程会把事情拆分成： 一个个函数和数据（用于方法的参数） 。然后按照一定的顺序，执行完这些**方法**（每个方法看作一个过程），等方法执行完了，事情就搞定了。

**面向对象（Object Oriented简称OO ：如C++，JAVA等语言）：**

​    看名字它是注重对象的。当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。

## 二、用3个例子说明两者的区别

**例子一：**

  问题：  洗衣机里面放有脏衣服，怎么洗干净？

**面向过程的解决方法：**

1、执行加洗衣粉方法；

2、执行加水方法；

3、执行洗衣服方法；

4、执行清洗方法；

5、 执行烘干方法；

以上就是将解决这个问题的过程拆成一个个方法（是没有对象去调用的），通过一个个方法的执行来解决问题。

**面向对象的解决方法：** 

1、我先弄出两个对象：“洗衣机”对象和“人”对象 

2、针对对象“洗衣机”加入一些属性和方法：“洗衣服方法”“清洗方法”、“烘干方法”      

3、针对对象“人”加入属性和方法：“加洗衣粉方法”、“加水方法”

4、然后执行

人.加洗衣粉

人.加水 

洗衣机.洗衣服

洗衣机.清洗

洗衣机.烘干

解决同一个问题 ，面向对象编程就是先抽象出对象，然后用对象执行方法的方式解决问题。

------

**例子二 ：  打麻将例子  你 我 他**

 面向过程：        打麻将 （你，我，他） 

---------解决问题      拆成一个动作，把数据丢进去

 面向对象：  我.打麻将（你，他） or 你.打麻将（我，他）  or 他.打麻将(我，你) 

---------解决问题    抽象出对象，对象执行动作 。 

------

**例子三：**

最后在用一个网上常见的**五子棋例子**来说明一下：

**面向过程**的设计思路就是首先分析问题的步骤：

1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。

**面向对象**的设计则是从另外的思路来解决问题。

整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。

可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。





## 三：面向过程与面向对象的优缺点：

小编在看了@十四期_李光 博客上解释的非常通俗易懂，分享给大家

用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。

蛋炒饭制作的细节不说了，最后的一道工序肯定是把米饭和鸡蛋混在一起炒匀。盖浇饭呢，则是把米饭和盖菜分别做好，你如果要一份红烧肉盖饭呢，就给你浇一份红烧肉；如果要一份青椒土豆盖浇饭，就给浇一份青椒土豆丝。

蛋炒饭的好处就是入味均匀，吃起来香。如果恰巧你不爱吃鸡蛋，只爱吃青菜的话，那么唯一的办法就是全部倒掉，重新做一份青菜炒饭了。盖浇饭就没这么多麻烦，你只需要把上面的盖菜拨掉，更换一份盖菜就可以了。盖浇饭的缺点是入味不均，可能没有蛋炒饭那么香。

到底是蛋炒饭好还是盖浇饭好呢？其实这类问题都很难回答，非要比个上下高低的话，就必须设定一个场景，否则只能说是各有所长。如果大家都不是美食家，没那么多讲究，那么从饭馆角度来讲的话，做盖浇饭显然比蛋炒饭更有优势，他可以组合出来任意多的组合，而且不会浪费。

盖浇饭的好处就是‘’菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是”可维护性“比较好，”饭”  和”菜”的耦合度比较低。蛋炒饭将”蛋”“饭”搅和在一起，想换”蛋”“饭”中任何一种都很困难，耦合度很高，以至于”可维护性”比较差。软件工程追求的目标之一就是可维护性，可维护性主要表现在3个方面：可理解性、可测试性和可修改性。面向对象的好处之一就是显著的改善了软件系统的可维护性。

总结来说：

**面向过程**

​    优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。

​    缺点：没有面向对象易维护、易复用、易扩展

**面向对象**

​    优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护

​    缺点：性能比面向过程低

## 四、面向对象编程的特性

三大基本特性：封装，继承，多态



**封装**

封装，就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。

**继承**

继承，指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。  通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过  “继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用父类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。

**多态**

多态，是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

## **五、五大基本原则：SPR, OCP, LSP, DIP, ISP**

**单一职责原则SRP(Single Responsibility Principle)**

是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。

**开放封闭原则OCP(Open－Close Principle)**

一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。

**里式替换原则LSP(the Liskov Substitution Principle LSP)**

子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。

**依赖倒置原则DIP(the Dependency Inversion Principle DIP)**

具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类：  而应当由B定义一个抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。

**接口分离原则ISP(the Interface Segregation Principle ISP)**

模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来



看到这大家是不是对面向对象有了更多的了解呢，快掏出你的键盘new一个对象来感受一下面向对象编程的魅力吧。最后，老规矩，送上表情包，拜~~~~~

https://zhuanlan.zhihu.com/p/75265007



## 3. extern_C 关键字

    1 一个文件引用另一个文件全局变量
    2 在定义点之前的函数想引用该全局变量
    3 c语言中extern关键字
        3.1 Example 1：
        3.2 Example 2：
        3.3 Example 3：
        3.4 Example 4：
        3. 5 Example 5：
        3.6 总结
    4 C++导入C函数 extern "C"
    5 其他相关文章

我们知道，程序的编译单位是源程序文件，一个源文件可以包含一个或若干个函数。在函数内定义的变量是局部变量，而在函数之外定义的变量则称为外部变量，外部变量也就是我们所讲的全局变量。它的存储方式为静态存储，其生存周期为整个程序的生存周期。全局变量可以为本文件中的其他函数所共用，它的有效范围为从定义变量的位置开始到本源文件结束。
1 一个文件引用另一个文件全局变量

如果整个工程由多个源文件组成，在一个源文件中想引用另外一个源文件中已经定义的外部变量，只需在引用变量的文件中用 extern 关键字加以声明即可
在这里插入图片描述

举例
在这里插入图片描述

在这里插入图片描述
test1.cpp

#include<stdio.h>
int kpi = 100;

int getmax(int a, int b) {
	return a > b ? a : b;
}

    1
    2
    3
    4
    5
    6

test2.cpp

#include<stdio.h>
int main() {

	extern int kpi;//外部变量申明
	extern int getmax(int a, int b);//外部函数申明
	
	int i = 0;
	i = kpi;
	printf("%d",i);
	
	int max = getmax(5,10);
	printf("\n%d", max);
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13

如果不使用extern 就会报错
在这里插入图片描述

在这里插入图片描述
2 在定义点之前的函数想引用该全局变量

如果全局变量不在文件的开头定义，有效的作用范围将只限于其定义处到文件结束。如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字 extern 对该变量作“外部变量声明”，表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。

#include <stdio.h>
int max(int x,int y);
int main(void)
{
    int result;
    /*外部变量声明*/
    extern int g_X;
    extern int g_Y;
    result = max(g_X,g_Y);
    printf("the max value is %d\n",result);
    return 0;
}
/*定义两个全局变量*/
int g_X = 10;
int g_Y = 20;
int max(int x, int y)
{
    return (x>y ? x : y);
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19

在这里插入图片描述
代码中，全局变量 g_X 与 g_Y 是在 main 函数之后声明的，因此它的作用范围不在 main 函数中。如果我们需要在 main 函数中调用它们，就必须使用 extern 来对变量 g_X 与 g_Y 作“外部变量声明”，以扩展全局变量的作用域。也就是说，如果在变量定义之前要使用该变量，则应在使用之前加 extern 声明变量，使作用域扩展到从声明开始到本文件结束。
3 c语言中extern关键字

c语言中extern关键字

extern关键字适用于变量及函数，并且扩展了他们的可见性，这也就是它被命名为extern的原因。
首先介绍一下声明（declaration）和定义（definition）的区别：

声明一个变量或者函数并没有给它们分配内存，它只是告诉程序它的类型是什么。在函数声明的情况下，它还告诉程序参数、它们的数据类型、这些参数的顺序以及函数的返回类型。

定义一个变量或者函数时，除了声明所做的一切之外，他还为该变量或函数分配内存。因此，我们可以把定义看作时声明的超集（或者声明是定义的子集）。
一个变量或者函数可以声明任意次数，但只能定义一次。

当我们在声明或定义函数时，会隐藏extern关键字。例如，当我们定义如下函数时：

int foo(int arg1, char arg2);

    1

编译器会将其视为

extern int foo(int arg1, char arg2);

    1

由于extend关键字将函数的可见性扩展到整个程序，因此可以在整个程序的任何文件中调用该函数，前提是这些文件包含该函数的声明。有了函数的声明，编译器就知道函数的定义存在于其他地方，然后继续编译文件。

当我们需要对一个变量声明而不定义的时候，我们会用extern来修饰该变量。如下所示

extern int var;//声明了一个名为var的整型变量（并没有定义，也就是说没有给var分配内存）

    1

这里声明了一个名为var的整型变量（并没有定义，也就是说没有给var分配内存）。这个声明可以进行多次。但是当我们去掉extern关键字后：

int var;//声明并定义了一个名为var的整数类型变量，var被分配内存

    1

在这一行中，声明并定义了一个名为var的整数类型变量，var被分配内存。

因此当我们声明一个函数时，extern关键字是隐式的，当我们想声明而不定义变量时，我们需要显式的包含extern关键字。此外，由于extern关键字扩展了整个程序的可见性，通过对变量使用extern关键字，我们可以在程序中任何地方使用该变量，前提是我们包含了该变量在某个地方的声明。

接下来用几个例子来理解extern关键字：
3.1 Example 1：

int var;
int main(void) {
	var = 10;
	return 0;
}

    1
    2
    3
    4
    5

这个程序是可以成功运行的，因为var变量是全局变量，并且声明和定义的。
3.2 Example 2：

extern int var;
int main(void) {
	return 0;
}

    1
    2
    3
    4

这个程序也是可以成功运行的，因为这里虽然只是声明了var变量，但是var变量并没有实际使用过，所以不会出现问题。
3.3 Example 3：

extern int var;
int main(void) {
	var = 10；
	return 0;
}

    1
    2
    3
    4
    5

这个程序就会出现问题，会在编译的时候抛出错误。因为var变量只进行了声明，并没有定义（也就是说没有分配内存），程序试图将不存在的变量的值更改为10。
3.4 Example 4：

#include "somefile.h"
extern int var;
int main(void) {
	var = 10;
	return 0;
}

    1
    2
    3
    4
    5
    6

假定somefile.h包含var的定义，这个程序是可以成功运行的。
3. 5 Example 5：

extern int var = 0;
int main(void) {
	var = 10;
	return 0;
}

    1
    2
    3
    4
    5

如果用extern声明了var变量，并且对该变量进行初始化，那么该变量被认为是已定义的。所以该程序可以顺利编译并运行。
3.6 总结

声明可以进行任意次，但是定义只能一次
extern关键字用于扩展变量/函数的可见性
extern修饰函数是隐式的，函数的声明或定义中默认使用extern修饰
extern修饰变量时，该变量只被声明，而没有定义
当使用extern修饰变量同时进行初始化时，该变量同时也被定义
4 C++导入C函数 extern “C”

C++中的extern “C”用法详解

有了符号的概念我们再来看extern “C”的用法就很容易了

extern "C"  

{  

    int func(int);  
    
    int var;  

}  

    1
    2
    3
    4
    5
    6
    7
    8
    9

它的意思就是告诉编译器将extern “C”后面的括号里的代码当做C代码来处理，当然我们也可以以单条语句来声明

extern "C" int func(int);  

extern "C" int var;  

    1
    2
    3

这样就声明了C类型的func和var。很多时候我们写一个头文件声明了一些C语言的函数，而这些函数可能被C和C++代码调用，当我们提供给C++代码调用时，需要在头文件里加extern “C”，否则C++编译的时候会找不到符号，而给C代码调用时又不能加extern “C”，因为C是不支持这样的语法的，常见的处理方式是这样的，我们以C的库函数memset为例

#ifdef __cplusplus 
extern "C" { 
#endif 

void *memset(void*, int, size_t); 

#ifdef __cplusplus 
} 
#endif 

    1
    2
    3
    4
    5
    6
    7
    8
    9

其中__cplusplus是C++编译器定义的一个宏，如果这份代码和C++一起编译，那么memset会在extern "C"里被声明，如果是和C代码一起编译则直接声明，由于__cplusplus没有被定义，所以也不会有语法错误。这样的技巧在系统头文件里经常被用到。
5 其他相关文章

文尾附相关文章
在这里插入图片描述
————————————————
版权声明：本文为CSDN博主「R-G-B」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_51233386/article/details/125877039



# 第七章：交叉开发
### （1）、 交叉编译环境

一、什么是交叉编译

        在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码，我们就称这种编译器支持交叉编译。这个编译过程就叫交叉编译。

简单地说，就是在一个平台上生成另一个平台上的可执行代码。这里需要注意的是所谓平台，实际上包含两个概念：

  1. 体系结构（Architecture）

  2. 操作系统（OperatingSystem）。

同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。举例来说:

    我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和Windows NT for x86操作系统的简称。
    
    要进行交叉编译，我们需要在主机平台上安装对应的交叉编译工具链（crosscompilation tool chain），然后用这个交叉编译工具链编译我们的源代码，最终生成可在目标平台上运行的代码。常见的交叉编译例子如下：

 1、在Windows PC上，利用ADS（ARM 开发环境），使用armcc编译器，则可编译出针对ARM CPU的可执行代码。

 2、在Linux PC上，利用arm-linux-gcc编译器，可编译出针对Linux ARM平台的可执行代码。

 3、在Windows PC上，利用cygwin环境，运行arm-elf-gcc编译器，可编译出针对ARM CPU的可执行代码。

1.1、为什么要使用交叉编译

    有时是因为目的平台上不允许或不能够安装我们所需要的编译器，而我们又需要这个编译器的某些特征；
    
    有时是因为目的平台上的资源贫乏，无法运行我们所需要编译器；
    
    有时又是因为目的平台还没有建立，连操作系统都没有，根本谈不上运行什么编译器。

1.2 、本地编译和交叉编译的比较

    本地编译：本地编译可以理解为，在当前编译平台下，编译出来的程序只能放到当前平台下运行。平时我们常见的软件开发，都是属于本地编译。比如，我们在 x86 平台上，编写程序并编译成可执行程序。这种方式下，我们使用 x86 平台上的工具，开发针对 x86 平台本身的可执行程序，这个编译过程称为本地编译。
    
    交叉编译：交叉编译可以理解为，在当前编译平台下，编译出来的程序能运行在体系结构不同的另一种目标平台（该平台自己不能干，所以让其它平台来干）上，但是编译平台本身却不能运行该程序。比如，我们在 x86 平台上，编写程序并编译成能运行在 ARM 平台的程序，编译得到的程序在 x86 平台上是不能运行的，必须放到 ARM 平台上才能运行。

二、交叉编译环境搭建

NDK官网地址：NDK 下载  |  Android NDK  |  Android Developers

本人采用ubuntu系统环境搭建，其他版本linux指令请自行百度参照，这里贴上我使用的ubuntu的下载连接 提取码：nbc3

注:谷歌在ndk-r18以后采用clang编译器，已经不支持gcc了，所以下载时要选择r19及以上的版本进行下载

1. 下载NDK，我这里选择当前最新版(北京时间:2021-01-23)

sudo wget https://dl.google.com/android/repository/android-ndk-r22-linux-x86_64.zip

 2. 解压,执行以下命令，解压ndk（注:系统需已安装unzip）

unzip android-ndk-r22-linux-x86_64.zip

3. 添加系统环境变量

        3.1 执行sudo vim etc/profile命令打开配置文件
        
        3.2 点击按键 i 进入编辑，通过键盘方向键，将光标移动到文件最下面
        
        3.3 写入以下配置
        
        3.4 修改NDK_HOME的路径为你解压的真实路径
        
        3.5 修改完毕，点击左上角按键Esc退出编辑，输入:wq保存
        
        3.6 执行source /etc/profile命令使配置生效

    #ndk home
    export NDK_HOME=/root/ndk/android-ndk-r21d
    export SYSROOT="$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/sysroot/"
    export ANDROID_GCC="$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android24-clang"
    export PATH=$PATH:$NDK_HOME

其中:

    NDK_HOME为ndk根路径
    
    ANDROID_GCC为手机编译路径，稍后会用到

4.验证配置

执行$NDK_HOME命令，如响应出NDK目录，即代表NDK环境配置成功

三、测试

1. 写main.cpp文件

执行sudo vim main.cpp命令，进入编辑模式，编辑内容如下，编辑完成，保存退出

    #include <stdio.h>
     
    int main()
    {
        printf("hello world\n");
        return 0;
    }

保存完毕后，使用ls查看指令可以看到已经生成了main.cpp文件，如图

2. 写交叉编译脚本 generate.sh

由于这里命令比较短，也可直接在命令行里写，这里还是将内容写到脚本中，步骤如下:

        2.1 执行sudo touch generate.sh命令创建generate.sh文件
    
        2.2 执行sudo chmod +x generate.sh赋予执行权限
        2.3 执行sudo vim generate.sh命令，进入编辑模式，编辑内容如下，编辑完成，保存退出
    
    $NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android26-clang++ main.cpp -o hello
     
    或者
    buidl(){
        $NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android26-clang++ main.cpp -o hello    
    }
    build

其中:

 NDK_HOME为自己解压的目录。
 编译器要选择目的终端的架构，这里用的是arm64，所以是aarch64-linux-android。
 编译器要选择android的api版本，这里用的是anroid 8.0.0，对应api是26。

 按照官网说明，NDK在r21之后，NDK 默认安装的工具链可供使用。
 可以不需要使用 make_standalone_toolchain.py 脚本生成独立工具链来使用。
 这样使用自带的工具链就比较方便，不用再配置`sysroot`等编译选项。

3. 交叉编译出可执行程序hello
执行./generate.sh即可

注：此时编译生成的文件是无法在x86架构的linux上运行的

4. push到手机上执行

执行adb push hello /data/local/tmp

5. 给hello执行权限
adb shell
cd /data/local/tmp
chmod +x hello

6.执行hello

./hello

可以看到输出
hello liera
————————————————
版权声明：本文为CSDN博主「程序课代表」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_34508943/article/details/113032733

####  STM32 交叉编译环境

常用的STM32的软件开发方法都是基于MDK keil或IAR集成开发环境，但以上两个集成开发环境软件都是需要收费的，且价格较为昂贵。本节介绍一种在ubuntu上安装arm gcc（arm-none-eabi）的方式，用于编译STM32的程序。

1.在arm官网下载gcc-arm 8.2的版本(注意:下载arm-none-eabi的版本，由于stm32属于arm cortex -M架构)，网址如下：Downloads | GNU Arm Embedded Toolchain Downloads – Arm Developer
图1 从ARM官方下载gcc编译器

2.拷贝下载的交叉编译器到ubuntu系统的/opt/pkg/gcc_linaro目录，如下图所示：
图2 拷贝gcc交叉编译器到ubuntu交叉编译器安装目录

3.解压gcc到工作目录

tar -xjvf gcc-arm-none-eabi-8-2018-q4-major-linux.tar.bz2
图3 gcc压缩包解压

4.运行动态配置环境变量，再查看gcc的版本，如下所示，说明gcc安装成功。

     export PATH=/opt/pkg/gcc_linaro/gcc-arm-none-eabi-8-2018-q4-major/bin:$PATH

arm-eabi-gcc -v

————————————————
版权声明：本文为CSDN博主「少林and叔叔」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/q544344318/article/details/129211437



## 1. 嵌入式 Linux 系统环境组成

Linux内核由三部分构成：

- Bootloader：启动引导系统（可执行文件）
- Kernel：内核（可执行文件）
- Root File System：根文件系统

https://www.cnblogs.com/bruce1992/p/17574939.html

## 2. rftp_nfs_dnw 的作用

## 3. ext4 文件系统

[Linux文件系统详解](https://zhuanlan.zhihu.com/p/581250390)

[linux进程管理---实时调度](https://zhuanlan.zhihu.com/p/580503043)

[linux内核内存管理-缺页异常](https://zhuanlan.zhihu.com/p/579482414)

[linux内核内存管理-brk系统调用](https://zhuanlan.zhihu.com/p/579405096)

## **Ext**

全称Linux extended file system,  extfs，即Linux扩展文件系统，Ext2就代表第二代文件扩展系统，Ext3/Ext4以此类推，它们都是Ext2的升级版，只不过为了快速恢复文件系统，减少一致性检查的时间，增加了日志功能，所以Ext2被称为**索引式文件系统**，而Ext3/Ext4被称为**日志式文件系统**。

> 备注：Linux支持很多文件系统，包括网络文件系统(NFS)、Windows的Fat文件系统。

查看Linux支持的文件系统：`ls -l /lib/modules/$(uname -r)/kernel/fs`

![img](https://pic2.zhimg.com/80/v2-f81f7da57c5ec308add068333b59f9e5_720w.jpg)

查看Linux支持的文件系统(已载入到内存中)：`cat /proc/filesystems`

![img](https://pic3.zhimg.com/80/v2-de397b73c7f94389ec1fdba48c678476_720w.jpg)

## **核心设计**

### **数据存放区**

这些元素相对稳定，磁盘格式化后，就固定下来了。

- inode(索引节点)
  记录文件的权限、属性和数据所在块`block`的号码，每个文件都有且仅有一个的`inode`，每个`inode`都有自己的编号，可以把`inode`简单地理解为**文档索引**。

> 备注：在磁盘格式化后，inode的大小和数量都已经固定了，大小均为128Bytes(新的Ext4和xfs为258Bytes)。读取文件时，先读取inode里面记录的文件属性和权限，匹配正确后，才会读取文件内容(block)。**在Linux系统中，实际使用inode来识别文件，而不是文件名，类似于用户标识和昵称的设计**。

- inode table
  存储文件系统的所有inode编号的表格
- block(数据区块)
  存储的文件内容，也叫数据区块(data block)，每个`block`都有自己的编号，`Ext2`支持的单位`block`容量仅为**1k、2k、4k**。

> 备注：为了方便inode的记录，在磁盘格式化后，block的大小都已经固定了。每一个块只能存放一个文件的数据，若文件太大，将占用多个block；若文件太小，block剩余空间就不能被使用了，就会导致**磁盘空间浪费**，所以**在磁盘分区后，文件系统格式化前，请先仔细想想文件系统的预计使用情况**。

### **查看文件或者文件系统的状态**

```text
stat [options] [filename] 
```

![img](https://pic1.zhimg.com/80/v2-88267f9821edf1cc72a4d51dafc3978c_720w.webp)

**查看系统各个文件系统的inode使用情况**

```text
df -i
```

![img](https://pic3.zhimg.com/80/v2-d1a4e963f967b20278d422347acf6ca6_720w.webp)

### **中介数据(metadata)**

这些元素是为了维持文件系统状态而设计出来的，当新增、编辑、删除文档时，都需要变更这些状态信息。

- superblock(超级块)
  记录文件系统(filesystem)的整体信息，包括`inode/block`的总量、使用量、剩余量、大小、以及文件系统的格式和相关信息。

> 备注：整个文件系统的基本信息全部记录在superblock，它的大小一般为1024Bytes，如果它死掉，将会花费大量的时间去补救哦！！！

- block group(区块群组)
  试想一下，假如我们的磁盘容量高达数百G，当我们格式后，inode和block会非常庞大，为了便于管理，Ext文件系统在格式化时，引入了区块群组(block  group)的概念，每个区块群组都保持独立inode/block/superblock，拥有固定数量的block，这样就分成了一群一群最基础的子文件系统。

> 备注：superblock对于文件系统太重要了，但是文件系统的superblock又只有一个，所以除了第一个block group含有superblock外，后续block  group都可能会含有备份的superblock，目的就是为了避免superblock单点无法救援的问题。

- block bitmap(区块对照表)
  一个block只能被一个文件使用，当我们新增文件时，肯定需要使用新的block来记录文件数据。那么如何快速地知道，哪些block是新的？哪些block是已经使用了的？block bitmap就是这样被设计出来，记录所有使用和未使用的block号码。同样的，当我们删除文件时，先从block  bitmap中找到对应的block号码，然后更新标志为未使用，最后释放block。
- inode bitmap(inode 对照表)
  和block bitmap一样的设计理念，只不过它记录地是已使用和未使用的inode号码，这里就不再敖述了。
- group descriptor
  描述每个区段(block group)开始和结束的block号码，以及说明每个区段(inodemap、blockmap、inode table)分别介于哪些block号码之间。

列出目前系统所有被格式化的设备：`blkid`

![img](https://pic3.zhimg.com/80/v2-086b894c0938d6b8cbe3e86bf1c9359e_720w.webp)

挑选一个已格式化好的设备，查看文件系统的详细信息：`dumpe2fs /dev/vda1`

![img](https://pic1.zhimg.com/80/v2-11ff7d13168306d95db638407a144f6c_720w.webp)

![img](https://pic2.zhimg.com/80/v2-13497f82eb1b4e04e50624edc14d6d21_720w.webp)

> 备注：通过上面的Magic签名为0xEF53，说明我们的磁盘分区是一个标准的ext2和ext3文件系统。类似于通过文件开头的Magic，可以判断文件类型一样。

## **示例说明**

### **1. inode的作用**

当用户搜索或者访问一个文件时，UNIX 系统通过 inode 表查找正确的 inode 编号。在找到 inode 编号之后，相关的命令才可以访问该 inode ，并对其进行适当的更改。

### **示例**

例如使用`vi`来编辑一个文件。当您键入`vi<filename>`时，在inode表中找到inode编号之后，才允许您打开该inode 。在 vi 的编辑会话期间，更改了该inode中的某些属性，当您完成操作并键入 :wq 时，将关闭并释放该 inode  。通过这种方式，如果两个用户试图对同一个文件进行编辑， inode 已经在第一个编辑会话期间分配给了另一个用户 ID  (UID)，因此第二个编辑任务就必须等待，直到该 inode 释放为止。

> 备注：大家可以参考百度百科。

### **2. block的重要性**

通过上面的分析，我们知道block是文件数据存储的原子单位，且每一个block只能存储一个文件的数据。当格式化一个文件系统时，如果选择不当，就会造成大量的磁盘空间浪费。

### **示例**

假如文件系统选择的block为4k，存储10000个小文件，每个500bytes，请问此时浪费了多少磁盘空间容量？
每个文件浪费的磁盘容量 = 4096 - 500 = 3596bytes，10000个文件浪费的磁盘容量 = 10000 * 3596 ~=34M，实际文件容量 =  10000 * 500 ~=4.7M，没有对比就没有伤害啊，实际存储容量不到5M，就浪费了34M，浪费率680%，而且文件越多浪费越严重。

> 备注：从原理上分析，只有当实际文件容量刚好等于系统最小存储单位容量时，磁盘不会存在浪费的情况，但这是理想情况，那么我们选择最小的block不就行了，没毛病。不过，此时又有新的问题产生了，大型文件会占用过多的block，造成inode记录过多的block号码，文件系统的读写性能就会下降，所以说凡事都要有个度，把握好这个度，才能从整体上提高文件系统的性能和利用率。

### **3. inode和block与文件大小的关系**

数据实际存储在block，为了能够快速地读取文件，每个文件都对应一个inode索引文件，记录所有的block编号，但是inode的大小只有128bytes或256bytes(ext4)，如果一个文件太大，block数量很有可能会超过inode可记录的数量，为此，inode记录block号码的区域被设计为12个直接、一个间接、一个双间接、一个三间接记录区。

> 备注：所谓的间接就是拿一个block来作为block号码记录区，只有最后一个间接才会真正用来记录block号码，其他的间接层，都只是依次引用。

![img](https://pic4.zhimg.com/80/v2-e46427b66918c104b0b55dadba9febcb_720w.webp)

### **计算单文件最大容量**

每个block号码为数字，需要占据4bytes。

- **假设block的单位容量为1K，每个block能记录的block号码为1k/4=256**。
  - 12个直接容量 = 12 * 1k =12k
  - 单间接容量 = 256 * 1k = 256k
  - 双间接容量 = 256 * 256 * 1k = 65536k
  - 三间接容量 = 256 * 256 * 256 * 1k = 16777216k
  - 单文件最大总量 = 12个直接容量 + 单间接容量 + 双间接容量 + 三间接容量 = (12 + 256 + 65536 + 16777216) / (1024 * 1024) = 16.06G
- **假设block的单位容量为2K，每个block能记录的block号码为2k/4=512**。
  - 12个直接容量 = 12 * 2k =24k
  - 单间接容量 = 512 * 2k = 1024k
  - 双间接容量 = 512 * 512 * 2k = 524288k
  - 三间接容量 = 512 * 512 * 512 * 2k = 268435456k
  - 单文件最大总量 = 12个直接容量 + 单间接容量 + 双间接容量 + 三间接容量 = (24 + 1024 + 524288 + 268435456) / (1024 * 1024) = 256.50G
- **假设block的单位容量为4K，每个block能记录的block号码为4k/4=1024**。
  - 同理，单文件最大总量 = 12个直接容量 + 单间接容量 + 双间接容量 + 三间接容量 = 4.00T

Linux标准的文件系统限制表 

![img](https://pic2.zhimg.com/80/v2-35167902ad855a1b888278ede0d2c9d5_720w.webp)

> 备注：当block单位容量为4K时，由于文件系统本身的限制(2T)，所以才与计算的结果不太吻合。

## **查看磁盘和文档的容量**

### **1. 查看文件系统的整体磁盘容量**

```text
df  [-ahikHTm] [目录或文件名]
```

![img](https://pic1.zhimg.com/80/v2-463e47ab6246d0b860d049c1e5a1aaac_720w.webp)

**2. 查看目录和文件容量**

```text
du [options] []
```

**查看目录geekbuying下所有目录的容量**

```text
du -sm geekbuying/*
```

![img](https://pic2.zhimg.com/80/v2-b7ac829a8328ee964ea1e98a88defdb9_720w.webp)

**统计当前目录容量**

```text
du -sm 单位M
```

![img](https://pic1.zhimg.com/80/v2-a74c6125bfbf1f7d5331da8c2c880604_720w.webp)

## **总结**

Ext家族是Linux支持度最广、最完整的文件系统，当我们格式化磁盘后，就已经为我们规划好了所有的inode/block/metadate等数据，这样系统可以直接使用，不需要再进行动态的配置，这也是它最优秀的特点，不过这也是它最显著的缺点，磁盘容量越大，格式化越慢，centos7.x已经选用xfs作为默认文件系统，xfs是一种适合大容量磁盘和处理巨型文件的文件系统。

https://zhuanlan.zhihu.com/p/649920886





# 第八章：系统内核

## 1. 嵌入式操作系统的构建方法

spl-》uboot-》kernel-》rootfs



## 2. uboot 的功能和作用

## uboot简介

uboot是从FADSROM、8xxROM、PPCBOOT逐步发展演化而来的。uboot发展至今，已经可以实现非常多的功能， 在操作系统方面，它不仅支持嵌入式Linux系统的引导，还支持NetBSD,VxWorks, QNX, RTEMS, ARTOS,  LynxOS, Android等嵌入式操作系统的引导。在CPU架构方面，  uboot支持PowerPC、MIPS、x86、ARM、NIOS、XScale等诸多常用系列的处理器。

一般来说BootLoader必须提供系统上电时的初始化代码，在系统上电时初始化相关环境后， BootLoader需要引导完整的操作系统，然后将控制器交给操作系统。  简单来说BootLoader是一段小程序，它在系统上电时执行，通过这段小程序可以将硬件  设备进行初始化，如CPU、SDRAM、Flash、串口、网络等，初始化完毕后调用操作系统内核。

## 启动uboot

以野火imx6ull 2020.10版本uboot为例，介绍uboot的使用， 在开发板上电uboot启动kernel之前按下键盘的空格或回车键, 进入uboot的命令模式。如下所示

```text
uboot 2020.10-g4f79a1a2 (Feb 20 2021 - 11:25:18 +0800)

CPU:   Freescale i.MX6ULL rev1.1 792 MHz (running at 396 MHz)
CPU:   Industrial temperature grade (-40C to 105C) at 49C
Reset cause: WDOG
Model: Freescale i.MX6 UltraLiteLite 14x14 EVK Board
Board: MX6ULL 14x14 EVK
DRAM:  512 MiB
MMC:   FSL_SDHC: 0, FSL_SDHC: 1
Loading Environment from MMC... OK
In:    serial
Out:   serial
Err:   serial
Net:   eth1: ethernet@20b4000 [PRIME]Could not get PHY for FEC0: addr 2

Hit any key to stop autoboot:  0
=>
```

可以看出uboot打印出了板子的一些基本信息，包括CPU、内存等信息。

## uboot命令

当不清楚uboot支持什么命令时， 可输入**help**或**?**可查看uboot支持的命令列表，如下所示

```text
?         - alias for 'help'
base      - print or set address offset
bdinfo    - print Board Info structure
blkcache  - block cache diagnostics and control
bmode     - sd1|sd2|qspi1|normal|usb|sata|ecspi1:0|ecspi1:1|ecspi1:2|ecspi1:3|esdhc1|esdhc2|esdhc3|esdhc4
bmode - getprisec
boot      - boot default, i.e., run 'bootcmd'
bootd     - boot default, i.e., run 'bootcmd'
bootefi   - Boots an EFI payload from memory
bootelf   - Boot from an ELF image in memory
bootm     - boot application image from memory
bootp     - boot image via network using BOOTP/TFTP protocol
bootvx    - Boot vxWorks from an ELF image
bootz     - boot Linux zImage image from memory
clocks    - display clocks
cmp       - memory compare
coninfo   - print console devices and information
cp        - memory copy
crc32     - checksum calculation
dcache    - enable or disable data cache
dhcp      - boot image via network using DHCP/TFTP protocol
dm        - Driver model low level access
dtfile    - dtoverlay utility commands
echo      - echo args to console
editenv   - edit environment variable
env       - environment handling commands
erase     - erase FLASH memory
exit      - exit script
ext2load  - load binary file from a Ext2 filesystem
ext2ls    - list files in a directory (default /)
ext4load  - load binary file from a Ext4 filesystem
ext4ls    - list files in a directory (default /)
ext4size  - determine a file's size
ext4write - create a file in the root directory
false     - do nothing, unsuccessfully
fatinfo   - print information about filesystem
fatload   - load binary file from a dos filesystem
fatls     - list files in a directory (default /)
fatmkdir  - create a directory
fatrm     - delete a file
fatsize   - determine a file's size
fatwrite  - write file into a dos filesystem
fdt       - flattened device tree utility commands
flinfo    - print FLASH memory information
fstype    - Look up a filesystem type
fstypes   - List supported filesystem types
fuse      - Fuse sub-system
go        - start application at address 'addr'
gpio      - query and control gpio pins
help      - print command description/usage
i2c       - I2C sub-system
icache    - enable or disable instruction cache
iminfo    - print header information for application image
imxtract  - extract a part of a multi-image
itest     - return true/false on integer compare
ln        - Create a symbolic link
load      - load binary file from a filesystem
loadb     - load binary file over serial line (kermit mode)
loads     - load S-Record file over serial line
loadx     - load binary file over serial line (xmodem mode)
loady     - load binary file over serial line (ymodem mode)
loop      - infinite loop on address range
ls        - list files in a directory (default /)
md        - memory display
mm        - memory modify (auto-incrementing address)
mmc       - MMC sub system
mmcinfo   - display MMC info
mtest     - simple RAM read/write test
mw        - memory write (fill)
nfs       - boot image via network using NFS protocol
nm        - memory modify (constant address)
panic     - Panic with optional message
ping      - send ICMP ECHO_REQUEST to network host
pinmux    - show pin-controller muxing
printenv  - print environment variables
protect   - enable or disable FLASH write protection
random    - fill memory with random pattern
reset     - Perform RESET of the CPU
run       - run commands in an environment variable
save      - save file to a filesystem
saveenv   - save environment variables to persistent storage
setenv    - set environment variables
setexpr   - set environment variable as the result of eval expression
sf        - SPI flash sub-system
showvar   - print local hushshell variables
size      - determine a file's size
sleep     - delay execution for some time
source    - run script from memory
test      - minimal test like /bin/sh
tftpboot  - boot image via network using TFTP protocol
true      - do nothing, successfully
version   - print monitor, compiler and linker version
```

可看到uboot支持很多的命令，功能十分强大，与linux类似，在执行某条uboot命令时， 可使用 *tab* 自动补全命令，在没有命令名冲突的情况下可以使用命令的前几个字母作为命令的输入， 例如想要执行 **reset** 命令，输入 *res* 或 *re* 即可。

当需要具体使用哪个命令时，可使用 **“help 命令”** 或 **“? 命令”** 的方式查看具体命令的使用说明。以 **“help printenv”** 为例，

```text
=> help printenv
printenv - print environment variables

Usage:
printenv [-a]
    - print [all] values of all environment variables
printenv name ...
    - print value of environment variable 'name'
```

可以看到printenv命令的说明以及使用方法。

关于uboot命令的使用可参考uboot官方链接： [http://www.denx.de/wiki/DULG/Manual](https://link.zhihu.com/?target=http%3A//www.denx.de/wiki/DULG/Manual) **5.9. uboot Command Line Interface** 部分。

## **uboot常见命令**

uboot命令众多，下面介绍常用的uboot命令,详细的uboot命令使用方式请使用**help [命令]**查看。

![img](https://pic2.zhimg.com/80/v2-b5ae722e8829e9abd92a8cdcc89cd1ad_720w.webp)

以上为用户较为常用使用的部分命令，具体的使用方式可使用**help [命令]**查看。

## **mmc命令**

mmc命令能够对如sd卡以及emmc类的存储介质进行操作，以下进行简单说明， 对于mmc命令不熟悉可使用**help mmc**查看相关命令的帮助，常用功能如下所示

![img](https://pic1.zhimg.com/80/v2-52ffefeafc4dbb82e929c707cfc9ffc0_720w.webp)

### **查看mmc设备**

使用**mmc list**查看板子上相关设备，本人使用的是emmc版本的开发板，并插入了sd卡， 可看到打印信息如下。

```text
=> mmc list
FSL_SDHC: 0 (SD)
FSL_SDHC: 1
```

使用**mmc dev**查看当前使用的mmc设备，打印信息如下，可看到当前设备为mmc0即sd卡。

```text
=> mmc dev
switch to partitions #0, OK
mmc0 is current device
```

可使用**mmc dev 1**命令切换当前设备为emmc设备

使用**mmc info**查看当前使用的sd卡设备的信息。

```text
=> mmc info
Device: FSL_SDHC
Manufacturer ID: 3
OEM: 5344
Name: SC16G
Bus Speed: 50000000
Mode: SD High Speed (50MHz)
Rd Block Len: 512
SD version 3.0
High Capacity: Yes
Capacity: 14.8 GiB
Bus Width: 4-bit
Erase Group Size: 512 Bytes
```

### **查看分区信息**

使用**mmc part**列出当前mmc设备分区

```text
=> mmc part

 Partition Map for MMC device 0  --   Partition Type: DOS

 Part    Start Sector    Num Sectors     UUID            Type
 1     8192            81920           2ba51413-01     0e Boot
 2     90112           31026176        2ba51413-02     83
```

### **mmc操作**

可使用以下指令对mmc存储介质以block为操作单位进行读、写、擦除操作，根据上面sd的信息可知， 一个block为512字节。

mmc read addr blk# cnt    *#读*
 mmc write addr blk# cnt   *#写*
 mmc erase blk# cnt        *#擦除*

简单实例：将mmc设备的的前10个block读取到0x80000000地址处:**mmc read 0x80000000 0 10**

## 文件系统操作命令

uboot能够对ext2/3/4以及fat文件系统设备进行访问， 可使用fstype命令判断存储介质分区使用的是什么类型的文件系统。 以mmc介质为例，判断sd的两个分区的文件系统类型

```text
=> fstype mmc 0:1
fat
=> fstype mmc 0:2
ext4
```

野火linux开发板具有U盘功能，能够通过PC以访问U盘的形式访问/boot目录下的文件， /boot目录对应的即是 mmc 0:1 分区。

而ext4分区对应的则是Debian根文件系统。

知道了文件系统的类型即可使用相对应的命令对分区内容进行操作了。

### FAT格式文件系统

uboot提供了能够对于FAT格式文件系统操作的各个指令， 如下所示，详细可通过**help [命令]**查看

![img](https://pic2.zhimg.com/80/v2-6f04cbb98a7c3425358d4c38cf8c4555_720w.webp)

**查看文件系统信息**

使用fatinfo查看文件系统信息，打印信息如下

```text
=> fatinfo mmc 0:1
Interface:  MMC
  Device 0: Vendor: Man 000003 Snr 6d8b9601 Rev: 1.0 Prod: SC16G▒
            Type: Removable Hard Disk
            Capacity: 15193.5 MB = 14.8 GB (31116288 x 512)
Filesystem: FAT16 "BOOT       "
```

**查看分区下的文件目录**

使用fatls查看分区下的文件目录，打印信息如下

```text
 => fatls mmc 0:1
 38   ID.txt
         kernel/
 2418   uEnv.txt
 577   SOC.sh
         boot/
 34   autorun.inf
         System Volume Information/
         dtbs/
 1472   BOOTEX.LOG

 5 file(s), 4 dir(s)
```

若想要查看其它目录下的文件列表，只要加上文件路径即可，如下

```text
=> fatls mmc 0:1 kernel/
 ./
 ../
 9187912   vmlinuz-4.19.35-imx6
 143341   config-4.19.35-imx6
 3104898   System.map-4.19.35-imx6
 5160838   initrd.img-4.19.35-imx6

 4 file(s), 2 dir(s)
```

**读取文件内容**

使用fatload将FAT文件系统的文件加载到内存中，如下所示

```text
=> fatload mmc 0:1 0x80000000 uEnv.txt
 2418 bytes read in 13 ms (181.6 KiB/s)
```

可使用md命令查看0x80000000内存中的部分数据内容

```text
=> md.b 0x80000000 0x80
80000000: 23 44 6f 63 73 3a 20 68 74 74 70 73 3a 2f 2f 65    #Docs: https://e
80000010: 6d 62 65 64 2d 6c 69 6e 75 78 2d 74 75 74 6f 72    mbed-linux-tutor
80000020: 69 61 6c 2e 72 65 61 64 74 68 65 64 6f 63 73 2e    ial.readthedocs.
80000030: 69 6f 2f 7a 68 5f 43 4e 2f 6c 61 74 65 73 74 2f    io/zh_CN/latest/
80000040: 52 45 41 44 4d 45 2e 68 74 6d 6c 0a 0a 75 6e 61    README.html..una
80000050: 6d 65 5f 72 3d 34 2e 31 39 2e 33 35 2d 69 6d 78    me_r=4.19.35-imx
80000060: 36 0a 23 75 75 69 64 3d 0a 6d 6d 63 5f 64 74 62    6.#uuid=.mmc_dtb
80000070: 3d 69 6d 78 36 75 6c 6c 2d 6d 6d 63 2d 6e 70 69    =imx6ull-mmc-npi
```

读取到的内容就是我们日常在/boot/uEnv.txt文件中的看到的内容了。

**FAT文件系统其他操作**

uboot还提供了FAT文件系统的其他操作命令，可用于创建目录、写入、删除等操作， 通常情况下在uboot中需要使用这类命令的场景很少，简单介绍如下：

- fatmkdir：创建目录
- fatrm：删除文件

###  ext4格式文件系统

ext4文件系统的命令使用方式和FAT使用方式相似，仅命令名不同， uboot提供的ext文件系统命令如下

![img](https://pic3.zhimg.com/80/v2-6c9afe6c77555a46862f34a57ce0abd6_720w.webp)

ext4文件系统操作

下面以将/etc/apt/sources.list的内容读取到内存实例，简单说明uboot对ext4文件系统操作。

1.查看/etc/apt目录中的文件内容，

```text
=> ext4ls mmc 0:2 /etc/apt/
 <DIR>       1024 .
 <DIR>       5120 ..
 <DIR>       3072 trusted.gpg.d
             865 sources.list
             2175 trusted.gpg
 <DIR>       1024 auth.conf.d
 <DIR>       1024 apt.conf.d
 <DIR>       1024 sources.list.d
 <DIR>       1024 preferences.d
             382 trusted.gpg~
```

2. 将/etc/apt/sources.list 文件读取到内存地址0x8000 0000处

```text
=> ext4load mmc 0:2  0x80000000  /etc/apt/sources.list
865 bytes read in 30 ms (27.3 KiB/s)
```

查看内存0x8000 0000的部分数据内存

```text
=> md.b 0x80000000 0x80
80000000: 64 65 62 20 68 74 74 70 3a 2f 2f 6d 69 72 72 6f    deb http://mirro
80000010: 72 73 2e 74 75 6e 61 2e 74 73 69 6e 67 68 75 61    rs.tuna.tsinghua
80000020: 2e 65 64 75 2e 63 6e 2f 64 65 62 69 61 6e 20 62    .edu.cn/debian b
80000030: 75 73 74 65 72 20 6d 61 69 6e 20 63 6f 6e 74 72    uster main contr
80000040: 69 62 20 6e 6f 6e 2d 66 72 65 65 0a 23 64 65 62    ib non-free.#deb
80000050: 2d 73 72 63 20 68 74 74 70 3a 2f 2f 6d 69 72 72    -src http://mirr
80000060: 6f 72 73 2e 74 75 6e 61 2e 74 73 69 6e 67 68 75    ors.tuna.tsinghu
80000070: 61 2e 65 64 75 2e 63 6e 2f 64 65 62 69 61 6e 20    a.edu.cn/debian
```

## uboot启动内核过程

bootcmd与bootargs可以说是uboot最重要的两个环境参数， uboot执行完毕之后，如果没有按下回车，则会自动执行bootcmd命环境参数里的内容， 而bootargs则是传递给内核的启动参数。

使用 **printenv bootcmd** 可查看bootcmd的内容。

```text
=> printenv bootcmd
 bootcmd=run distro_bootcmd
```

bootcmd执行了distro_bootcmd，同样可以使用 printenv distro_bootcmd 查看distro_bootcmd的内容如下

```text
=> printenv distro_bootcmd
distro_bootcmd=for target in ${boot_targets}; do run bootcmd_${target}; done

#boot_targets的值如下
boot_targets=mmc0 mmc1
```

也就是说distro_bootcmd会执行**bootcmd_mmc0、bootcmd_mmc1**这两个环境参数， 在前面我们知道，mmc0表示的sd卡的存储设备，mmc1表示的emmc设备， 也就是说当sd卡插在板子时，若sd卡装有系统则会优先从sd卡内启动。

```text
 => printenv bootcmd_mmc0
 bootcmd_mmc0=setenv devtype mmc; setenv mmcdev 0; setenv bootpart 0:1 ; setenv rootfpart 0:2 ; run boot
 => printenv bootcmd_mmc1
 bootcmd_mmc1=setenv devtype mmc; setenv mmcdev 1; setenv bootpart 1:1 ; setenv rootfpart 1:2 ; run boot
```

bootcmd_mmc0与bootcmd_mmc1均设置各自**devtype、mmcdev、bootpart、rootfpart**环境参数的值， 最后运行 boot 环境参数，boot内容如下

```text
 "boot=mmc check;${devtype} dev ${mmcdev};mmc rescan; " \
 "echo loading [${devtype} ${bootpart}] /uEnv.txt ...; "\
 "if run loaduEnv; then " \
     "run importbootenv;" \
     "if test ${second_flash} = emmc; then " \
             "setenv dtb ${mmc_dtb};"  \
             "setenv storage_media init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh;"  \
         "else " \
             "setenv dtb ${nand_dtb};"  \
             "setenv storage_media init=/opt/scripts/tools/Nand/init-Nand-flasher-v1.sh;"  \
         "fi; " \
     "if test -n ${flash_firmware}; then "  \
             "echo setting flash firmware...;"  \
             "setenv flashtype ${storage_media};"  \
     "fi;" \
     "run args_mmc_old;" \
     "echo loading vmlinuz-${uname_r} ...; "\
     "load ${devtype} ${bootpart} 0x80800000 /kernel/vmlinuz-${uname_r};"\
     "echo loading ${dtb} ...; "\
     "load ${devtype} ${rootfpart} 0x83000000 /usr/lib/linux-image-${uname_r}/${dtb};"\
     "dtfile 0x83000000 0x87000000  /uEnv.txt ${loadaddr};"   \
     "load ${devtype} ${bootpart} 0x88000000 /kernel/initrd.img-${uname_r};"\
     "echo debug: [${bootargs}] ... ;" \
     "echo debug: [bootz] ...  ;" \
     "bootz 0x80800000 0x88000000:${filesize} 0x83000000;"   \
 "fi;\0" \
```

若从uboot中直接使用printenv查看boot的内容会显得格式很乱，推荐在uboot源include/configs/mx6ullfire.h 中查看。

第3行，运行loading，loading的内容是将uEnv.txt文件的内容读取到内存中， 如下所示

```text
#其中loadaddr的值为0x8200 0000
loaduEnv=load ${devtype} ${bootpart} ${loadaddr} /uEnv.txt;
```

第4行，运行importbootenv，从内存地址中导入环境参数。

```text
"importbootenv=echo Importing environment from ${devtype} ...; " \
"env import -t ${loadaddr} ${filesize}\0" \
```

- 第5-11行，判断启动介质类型，设置 **dtb、storage、init** 环境参数。
- 第12-15行，判断是否需要使用利用现有镜像烧录固件到其他介质。
- 第16行，args_mmc_old 的作用主要用于设置 **bootargs** 环境参数。如下所示

```text
"args_mmc_old=setenv bootargs console=ttymxc0 " \
"root=/dev/mmcblk${mmcdev}p2 rw " \
"rootfstype=ext4 " \
"rootwait ${cmdline} ${flashtype}\0" \
```

- 第18行，将kernel内核加载到内存地址0x8080 0000处。
- 第20行，将主设备树加载到内存地址 0x8300 0000处。
- 第21行，将设备树插件的内容解析合成到主设备树上，dtfile命令并不是原来uboot就有的， 为了方便用户使用/boot/uEnv.txt文件使用设备树插件而添加的，有兴趣的读者可自行查看相关源码。
- 第22行，将虚拟文件系统加载到0x8800 0000中。
- 第25行，启动linux内核。

##  uboot环境参数介绍

uboot中环境参数为我们提供一种不修改uboot源码的情况下， 能够修改kernel启动倒计时、ip地址、以及向内核传递不同的参数等。

在板子上使用 **printenv** 可查看板子上所有的环境参数， 使用 **setenv** 添加/修改/删除环境参数，具体说明如下所示

```text
#设置新的环境参数名为abc，值为100
=> setenv abc 100
=> echo $abc
= 100

#将值修改为200
=> setenv abc 200
=> echo $abc
200

#删除abc环境参数
=> setenv abc
=> echo $abc

=>
```

默认情况下使用setenv命令修改环境参数重启后就会消失， 若想要掉电保存需要执行**saveenv**将环境参数保存到存储介质。

uboot上有一些官方规定的环境变量，这些环境变量在uboot有着特殊的作用， 可通过以下链接查看：[https://www.denx.de/wiki/view/DULG/UBootEnvVariables](https://link.zhihu.com/?target=https%3A//www.denx.de/wiki/view/DULG/UBootEnvVariables)

https://zhuanlan.zhihu.com/p/656662971





## 3. uboot 编译与配置

## Linux U-Boot 开发指南

### 1 前言

### 1.1 编写目的

介绍 U-Boot 的编译打包、基本配置、常用命令的使用、基本调试方法等, 为 U-BOOT 的移植及应用开发提供了基础。

### 1.2 适用范围

本文档适用于 brandy2.0, 即 U-Boot-2018 平台。

### 1.3 相关人员

U-Boot 开发/维护人员，内核开发人员。

### 2 LICHEE 类宏关键字解释

请到 longan 目录下的.buildconfig 查看目前使用了以下 LICHEE 类宏。

```text
LICHEE_IC    ——> IC名\
LICHEE_CHIP  ——> 平台名\
LICHEE_BOARD ——> 板级名\
LICHEE_ARCH  ——> 所属架构\
LICHEE_BOARD_CONFIG_DIR ——> 板级目录\
LICHEE_BRANDY_OUT_DIR   ——> bin文件所在目录\
LICHEE_PLAT_OUT         ——> 平台临时bin所在目录\
LICHEE_CHIP_CONFIG_DIR  ——> IC目录
```

### 3 编译方法介绍

### 3.1 准备编译工具链

准备编译工具链接执行步骤如下：

```text
1）cd longan/brandy/brandy-2.0/\
2）./build.sh -t
```

### 3.2 快速编译 boot0 及 U-Boot

在longan/brandy/brandy-2.0/目录下，执行 ./build.sh -p 平台名称，可以快速完成整个 boot 编译动作。这个平台名称是指，LICHEE_CHIP。

```text
./build.sh -p {LICHEE_CHIP}            //快速编译spl/U-Boot
./build.sh -o spl-pub -p {LICHEE_CHIP} //快速编译spl-pub
./build.sh -o uboot -p {LICHEE_CHIP}   //快速编译U-Boot
```

### 3.3 编译 U-Boot

cd longan/brandy/brandy-2.0/u-boot-2018/进入 u-boot-2018 目录。以{LICHEE_CHIP}为例，依次执行如下操作即可。

```text
1）make {LICHEE_CHIP}_defconfig
2）make -j
```

### 3.4 编译 boot0/fes/sboot

cd longan/brandy/brandy-2.0/spl-pub进入spl-pub目录，需设置平台和要编译的模块参数。以{LICHEE_CHIP}为例，编译 nand/emmc 的方法如下：

1. 编译boot0

```text
make distclean
make p={LICHEE_CHIP} m=nand
make boot0

make distclean
make p={LICHEE_CHIP} m=emmc
make boot0
```

1. 编译fes

```text
make distclean
make p={LICHEE_CHIP} m=fes
make fes
```

1. 编译sboot

```text
make distclean
make p={LICHEE_CHIP} m=sboot
make sboot
```

### 4 U-Boot 功能及其配置方法/文件介绍

### 4.1 U-Boot 功能介绍

在嵌入式操作系统中，BootLoader/U-Boot  是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。在 sunxi 平台中，除了必须的引导系统启动功能外，BOOT 系统还提供烧写、升级等其它功能。

U-Boot 主要功能可以分为以下几类

1. 引导内核

能从存储介质（nand/mmc/spinor）上加载内核镜像到 DRAM 指定位置并运行。

1. 量产 & 升级

包括卡量产，USB 量产，私有数据烧录，固件升级

1. 开机提示信息

开机能显示启动 logo 图片（BMP 格式)

1. Fastboot 功能

实现 fastboot 的标准命令，能使用 fastboot 刷机

### 4.2 U-Boot 功能配置方法介绍

U-Boot 中的各项功能可以通过 defconfig 或配置菜单 menuconfig 进行开启或关闭, 具体配置

方法如下:

### 4.2.1 通过 defconfig 方式配置

1.  vim /longan/brandy/brandy-2.0/u-boot-2018/configs/{LICHEE_CHIP}_defconfig
    
2.   开{LICHEE_CHIP}_defconfig或{LICHEE_CHIP}_nor_defconfig后，在相应的宏定义前去掉或添加"#"即可将相应功能开启或关闭。如下图，只要将CONFIG_SUNXI_NAND前的#去掉即可支持 NAND 相关功能，其他宏定义的开启关闭也类似。修改后需要运行make xxx_defconfig使修改后的配置生效。




![img](https://pic3.zhimg.com/80/v2-618db48908b0a82347d0e2ff033e6172_720w.webp)



​                                                                           图 4-1: defconfig 配置图

### 4.2.2 通过 menuconfig 方式配置

通过 menuconfig 方式配置的方法步骤如下：

1.  cd brandy/brandy-2.0/u-boot-2018/
    
2.  执行make menuconfig命令，会弹出 menuconfig 配置菜单窗口，如下图所示。此时即可对各模块功能进行配置，配置方法 menuconfig 配置菜单窗口中有说明。
    
3.  修改后配置已经生效，直接 make 即可生成对应 bin。如果重新运行make xxx_defconfig，通过menuconfig 方式修改的配置会在运行make xxx_defconfig后被xxx_defconfig中的配置覆盖。
    



![img](https://pic4.zhimg.com/80/v2-5d6fe2bf469aeda2bece4eb25e0119e7_720w.webp)



​                                                                       图 4-2: menuconfig 配置菜单图

### 4.3 U-Boot 配置参数文件介绍

U-Boot 自 linux-5.4 以后不再使用 sysconfig 和内核 dts 作为配置文件，而是使用 U-Boot 自带的 dts 来配置参数。kernel-dts 与 U-Boot-dts 完全独立。

### 4.3.1 U-Boot-dts 路径

U-Boot-dts 路径为：vim longan/brandy/brandy-2.0/u-boot-2018/arch/arm/dts

### 4.3.2 U-Boot-dts，defconfig 配置

| 配置项                             | 配置项含义                             |
| ---------------------------------- | -------------------------------------- |
| CONFIG_OF_SEPARATE                 | 构建 U-Boot 设备树成为 U-Boot 的一部分 |
| CONFIG_OF_BOARD                    | 关闭使用外部 dts                       |
| CONFIG_DEFAULT_DEVICE_TREE         | 选择构建的 dts 文件文件名              |
| CONFIG_SUNXI_NECESSARY_REPLACE_FDT | 开启选项, 实现内部 dts 换成外部 dts    |

| 配置项                             | 选项                       |
| ---------------------------------- | -------------------------- |
| CONFIG_OF_SEPARATE                 | y                          |
| CONFIG_OF_BOARD                    | n                          |
| CONFIG_DEFAULT_DEVICE_TREE         | “{LICHEE_CHIP}-soc-system” |
| CONFIG_SUNXI_NECESSARY_REPLACE_FDT | y                          |

### 4.3.3 U-Boot-dts 注意事项

### 4.3.3.1 编译注意事项

1.dts 分为板级 dts，和系统 dts。

系统 dts 由 CONFIG_DEFAULT_DEVICE_TREE 决定，可以在 $(CONFIG_SYS_CONFIG_NAME)_defconfig找到该宏的定义。

系统 dts 最终会 include 板级 dts，文件路径 {LICHEE_BOARD_CONFIG_DIR}，文件名:uboot-board.dts。

1. 我们可以通过编译时的打印判断启动的 dts

```text
OBJCOPY examples/standalone/hello_world.srec
OBJCOPY examples/standalone/hello_world.bin
LD u-boot
OBJCOPY u-boot.srec
OBJCOPY u-boot-nodtb.bin
‘{LICHEE_BOARD_CONFIG_DIR}/uboot-board.dts’ -> ‘~/longan/brandy/brandy-2.0/u-boot-2018/
arch/{LICHEE_ARCH}/dts/.board-uboot.dts’
DTC arch/{LICHEE_ARCH}/dts/{LICHEE_CHIP}-soc-system.dtb
SYM u-boot.sym
SHIPPED dts/dt.dtb
FDTGREP dts/dt-spl.dtb
COPY u-boot.dtb
CAT u-boot-dtb.bin
COPY u-boot.bin
‘u-boot.bin’ -> ‘{LICHEE_CHIP}.bin’ ‘u-boot-g{LICHEE_CHIP}.bin’ -> ‘{LICHEE_BRANDY_OUT_DIR}/bin/u-boot-g{LICHEE_CHIP}.bin’ ‘u-boot-g{LICHEE_CHIP}.bin’ -> ‘{LICHEE_PLAT_OUT}/u-boot-g{LICHEE_CHIP}.bin’
CFGCHK u-boot.cfg
```

### 4.3.3.2 语法注意事项

当系统 dts 与板级 dts 存在同路径下同名节点时，板级 dts 将会覆盖系统 dts。

### 4.3.3.3 运行时注意事项

1. 为了在启动内核前更新参数到内核 dts 和可以在 U-Boot 控制台查看修改 dts。按阶段划分可以分为使用内部 dts 阶段和使用内核 dts 阶段，如下图所示。



![img](https://pic2.zhimg.com/80/v2-741c42a155388d2ed9860919b280e995_720w.webp)



​                                                                   图 4-3: dts 变化图

1. 可以通过命令set_working_fdt来切换当前生效的 fdt。

```text
[04.562]update bootcmd
[04.576]change working_fdt 0x7bebee58 to 0x7be8ee58
[04.587]update dts
Hit any key to stop autoboot: 0
=> set
    set_working_fdt setenv setexpr
=> set_working_fdt 0x7bebee58
change working_fdt 0x7be8ee58 to 0x7bebee58
=>
```

### 5 U-Boot 常用命令介绍

### 5.1 env 命令说明

通过env命令可以对{LICHEE_CHIP_CONFIG_DIR}/configs/default/env.cfg中的环境变量进行查看及更改。在小机启动过程中按任意键进入 U-Boot shell 命令状态，输入命令"env"即可查看命令帮助信息。

具体示例如下：

1. 输入命令"env print"，可查看当前所有的环境变量信息，如下：

```text
=> pri
ab_partition_list=bootloader,env,boot,vendor_boot,dtbo,vbmeta,vbmeta_system,vbmeta_vendor
android_trust_chain=true
boot_fastboot=fastboot
boot_normal=sunxi_flash read 45000000 boot;bootm 45000000
boot_recovery=sunxi_flash read 45000000 recovery;bootm 45000000
bootcmd=run setargs_mmc boot_normal
bootdelay=0
bootreason=charger
bt_mac=20:A1:11:12:13:44
cma=8M
console=ttyAS0,115200
earlyprintk=sunxi-uart,0x05000000
fdtcontroladdr=7bed0e60
fileaddr=40000000
filesize=15cf6
force_normal_boot=1
init=/init
initcall_debug=0
keybox_list=widevine,ec_key,ec_cert1,ec_cert2,ec_cert3,rsa_key,rsa_cert1,rsa_cert2,rsa_cert3
loglevel=8
mac=10:14:15:15:9A:CA
mmc_root=/dev/mmcblk0p4
nand_root=/dev/nand0p4
partitions=bootloader_a@mmcblk0p1:bootloader_b@mmcblk0p2:env_a@mmcblk0p3:env_b@mmcblk0p4:
boot_a@mmcblk0p5:boot_b@mmcblk0p6:vendor_boot_a@mmcblk0p7:vendor_boot_b@mmcblk0p8:
super@mmcblk0p9:misc@mmcblk0p10:vbmeta_a@mmcblk0p11:vbmeta_b@mmcblk0p12:
vbmeta_system_a@mmcblk0p13:vbmeta_system_b@mmcblk0p14:vbmeta_vendor_a@mmcblk0p15:
vbmeta_vendor_b@mmcblk0p16:frp@mmcblk0p17:empty@mmcblk0p18:metadata@mmcblk0p19:
private@mmcblk0p20:dtbo_a@mmcblk0p21:dtbo_b@mmcblk0p22:media_data@mmcblk0p23:
UDISK@mmcblk0p24
rotpk_status=0
setargs_mmc=setenv bootargs earlyprintk=${earlyprintk} clk_ignore_unused initcall_debug=${
initcall_debug} console=${console} loglevel=${loglevel} root=${mmc_root} init=${init}
cma=${cma} snum=${snum} mac_addr=${mac} wifi_mac=${wifi_mac} bt_mac=${bt_mac}
specialstr=${specialstr} gpt=1 androidboot.force_normal_boot=${force_normal_boot}
androidboot.slot_suffix=${slot_suffix}
setargs_nand=setenv bootargs earlyprintk=${earlyprintk} clk_ignore_unused initcall_debug=${
initcall_debug} console=${console} loglevel=${loglevel} root=${nand_root} init=${init}
cma=${cma} snum=${snum} mac_addr=${mac} wifi_mac=${wifi_mac} bt_mac=${bt_mac}
specialstr=${specialstr} gpt=1 androidboot.force_normal_boot=${force_normal_boot}
androidboot.slot_suffix=${slot_suffix}
slot_suffix=_a
snum=A100B3N041
wifi_mac=10:A1:11:12:13:44
Environment size: 2078/131068 bytes
=>
```

1.  输入命令"env set bootdelay 3"，可更改环境变量bootdelay（即 boot 启动时 log 中的倒计时延迟时间）值的大小。
    
2.  输入命令"env save"，即可将上述更改进行保存，保存后重新上电，或输入命令"reset"，即可看到上述更改bootdelay的延时时间被更改生效。
    
3.  其他env命令请查看env帮助信息。
    

### 5.2 sunxi_flash read 命令说明

### 5.2.1 使用方法

用以下命令将 flash 指定地址中数据读到 DRAM 的指定地址处：

```text
sunxi_flash read dram_addr flash_addr
```

### 5.2.2 使用示例

```text
sunxi_flash read 0x45000000 env—将env分区数据读到DRAM的0x45000000地址处
sunxi_flash read 45000000 boot;bootm 45000000—将flash中boot分区数据读到DRAM的0x45000000地     址,并 从0x45000000处启动。
```

### 5.3 fastboot 命令说明

   fastboot 是 Android 平台上一个通用的刷机工具，也是一个很好的开发调试工具，以下介绍 fastboot 的基本使用方法。

### 5.3.1 使用前提

fastboot PC 端工具可以从 Google Android SDK(Android-sdk-windows/tools) 中获得，也可以在 Android 源代码编译过后的生成文件获得 (out/host/linux-x86/bin)。 

在 Linux 系统中，使用 fastboot 不需要安装驱动。但在 Windows 系统中，使用 fastboot 前需安装 fastboot  相关驱动。adb 的驱动在 fastboot 模式下也可以安装成功，但是无法使用，请使用我们提供的驱动，并手动安装。

### 5.3.2 使用步骤

1.  小机上电启动，按任意键进入 U-Boot 命令状态；
    
2.  串口端输入"fastboot"命令；
    
3.  打开 PC 端 fastboot 工具，并输入"fastboot devices"命令，看是否有 fastboot 设备显示；
    
4.  在正确获取 fastboot 设备的前提下，输入命令"fastboot flash env  /path/to/env.fex"，将env.fex写到env分区（/path/to/目录下的env.fex中bootdelay值应该与  flash 中原有env中bootdelay值不同，这样可根据bootdelay值不同来确定 fastboot 烧写是否成功）,  同下载env.fex分区一样, 输入命令“fastboot flash boot /path/to/boot.img”将内核下载到内存中；
    
5.  输入"fastboot reboot"命令重启，查看启动倒计时即bootdelay的值是否改变；
    

### 5.3.3 fastboot 基本命令使用示例

1. fastboot 几个基本命令示例如下:

fastboot devices ：显示 fastboot 的设备。

fastboot erase ：擦除分区，例如fastboot erase boot，擦除boot分区。

fastboot flash：旧分区（待写分区），例如fastboot flash boot/path/to/boot.img，将boot.img写到boot分区。

1. 注意事项:

fastboot 中使用的分区和sys_partition.fex中分区一致，具体的分区信息可以从小机上电启动进入 U-Boot shell 命令状态，输入命令"part list sunxi_flash 0"中获取，分区信息如下：

```text
=> part list sunxi_flash 0

Partition Map for UNKNOWN device 0 -- Partition Type: EFI

Part         Start LBA          End LBA          Name
             Attributes
             Type GUID
        Partition GUID
1       0x00008000      0x00017fff      "bootloader"
        attrs: 0x8000000000000000
        type: ebd0a0a2-b9e5-4433-87c0-68b6b72699c7
        guid: a0085546-4166-744a-a353-fca9272b8e45
2       0x00018000      0x0001ffff      "env"
        attrs: 0x8000000000000000
        type: ebd0a0a2-b9e5-4433-87c0-68b6b72699c7
        guid: a0085546-4166-744a-a353-fca9272b8e46
3       0x00020000      0x0002ffff      "boot"
        attrs: 0x8000000000000000
        type: ebd0a0a2-b9e5-4433-87c0-68b6b72699c7
        guid: a0085546-4166-744a-a353-fca9272b8e47
4       0x00030000      0x0032ffff      "super"
        attrs: 0x8000000000000000
        type: ebd0a0a2-b9e5-4433-87c0-68b6b72699c7
        guid: a0085546-4166-744a-a353-fca9272b8e48
5       0x00330000      0x00337fff      "misc"
        attrs: 0x8000000000000000
        type: ebd0a0a2-b9e5-4433-87c0-68b6b72699c7
        guid: a0085546-4166-744a-a353-fca9272b8e49
6       0x00338000      0x00347fff      "recovery"
        attrs: 0x8000000000000000
        type: ebd0a0a2-b9e5-4433-87c0-68b6b72699c7
        guid: a0085546-4166-744a-a353-fca9272b8e4a
```

### 5.4 fat 命令说明

fat命令可以对 FAT 文件系统的相关存储设备进行查询及文件读写操作，在打包固件的时候, 我们会制作启动资源分区镜像,  把指定的目录下的文件按照文件系统的格式排布，文件中包括了原来目录中的所有文件，并完全按照目录结构排列。当把这个镜像文件烧写到存储设备上的某一个分区的时候，可以看到这个分区和原有目录的内容一样。使用fat可以方便地以文件和目录的方式对小机 flash 进行数据访问，如显示 logo。这些指令基本上要和 U 盘或者 SD 卡同时使用，主要用于读取这些移动存储器上的 FAT  分区。其相关操作命令如下：

1. fatls : 列出相应设备目录上的所有文件，示例如下图：



![img](https://pic1.zhimg.com/80/v2-ecd0e1a16ab6509ba3eaf4d63d3cc838_720w.webp)



​                                                                   图 5-1: fatls 命令执行示例图

说明

**补充说明，fatls mmc 2:2 中的第一个 2 表示的是 emmc 设备，2 表示其分区号，其说明如下图：**



![img](https://pic2.zhimg.com/80/v2-db92626a384167cd63c66407212d7ca1_720w.webp)



​                                                                   图 5-2: fatls 命令参数说明图

1. fatinfo: 打印出相应设备目录的文件系统信息，示例如下图：



![img](https://pic4.zhimg.com/80/v2-28a627f3f32fa43bd2c1cdaf445cc3bf_720w.webp)



​                                                                   图 5-3: fatinfo 命令执行示例图

1. fatload: 从 FAT 文件系统中读取二进制文件到 RAM 存储中，示例如下：

```text
sunxi#usb start
(Re)start USB...
USB0: start sunxi ehci1...
config usb pin success
config usb clk ok
sunxi ehci1 init ok...
USB EHCI 1.00
scanning bus 0 for devices... 3 USB Device(s) found
scanning usb for storage devices... 1 Storage Device(s) found
sunxi#fatls usb 0:1 /
16024600 sandisksecureaccessv3_win.exe
sandisk secureaccess/
lost.dir/
Android/
test/
video test/
amapauto/
0 vid_20161017_160818.ts
phoenixsuit/
system volume information/
0 vid_20161017_160919.ts
video/
156672 wifi pro_com su.exe
495 sys.ini
1035 pr_80211g_all.ini
config/
158208 wifi pro_new.exe
158208 wifi pro.exe
0 vid_20161017_164822.ts
0 vid_20161017_164906.ts
sunxi-tvd/
71149 sys_config.fex
vga/
397836884 system.img
14180352 boot.img
13 file(s), 13 dir(s)
sunxi#fatload usb 0:1 0x42000000 boot.img
reading boot.img
14180352 bytes read in 1149 ms (11.8 MiB/s)
sunxi#mmc dev 2
mmc2(part 0) is current device
sunxi#mmc write 0x42000000 0x15000 5000
MMC write: dev # 2, block # 86016, count 20480 ... 20480 blocks written: OK
```

说明：以上操作即将 U 盘的boot.img写到对应的 mmc 分区地址处。

1. fatwrite: 从内存中将对应的文件写到设备文件系统中。

### 5.5 md 命令说明

md命令可以对指定内存的数据进行查看，方便了解内存的数据情况及调试工作。其使用方法如下：

```text
md 0xF0000000： 即用md命令查看内存DRAM 0xF0000000处内容
```

### 5.6 FDT 命令说明

FDT：flattened device tree 的缩写在 U-Boot 控制台停下后，输入fdt，可以查看fdt命令帮助。

```text
sunxi#fdt
fdt - flattened device tree utility commands
Usage:
fdt addr [-c] <addr> [<length>] - Set the [control] fdt location to <addr>
fdt move <fdt> <newaddr> <length> - Copy the fdt to <addr> and make it active
fdt resize - Resize fdt to size + padding to 4k addr
fdt print <path> [<prop>] - Recursive print starting at <path>
fdt list <path> [<prop>] - Print one level starting at <path>
fdt get value <var> <path> <prop> - Get <property> and store in <var>
fdt get name <var> <path> <index> - Get name of node <index> and store in <var>
fdt get addr <var> <path> <prop> - Get start address of <property> and store in <var>
fdt get size <var> <path> [<prop>] - Get size of [<property>] or num nodes and store in <var>
fdt set <path> <prop> [<val>] - Set <property> [to <val>]
fdt mknode <path> <node> - Create a new node after <path>
fdt rm <path> [<prop>] - Delete the node or <property>
fdt header
fdt bootcpu <id> - Set boot cpuid
fdt memory <addr> <size> - Add/Update memory node
fdt rsvmem print - Show current mem reserves
fdt rsvmem add <addr> <size> - Add a mem reserve
fdt rsvmem delete <index> - Delete a mem reserves
fdt chosen [<start> <end>] - Add/update the /chosen branch in the tree
<start>/<end> - initrd start/end addr
NOTE: Dereference aliases by omiting the leading '/', e.g. fdt print ethernet0。
sunxi#
```

说明

**其中常用的命令就是fdt list 和 fdt set,fdt list 用来查询节点配置,fdt set 用来修改节点配置。**

### 5.6.1 查询配置

首先确定要查询的字段在 device tree 的路径，如果不知道路径，则需要用fdt命令按以下步骤进

行查询。1. 在根目录下查找。

```text
sunxi#fdt list /
/ {
    model = "{LICHEE_CHIP}";
    compatible = "arm,{LICHEE_CHIP}", "arm,{LICHEE_CHIP}";
    interrupt-parent = <0x00000001>;
    #address-cells = <0x00000002>;
    #size-cells = <0x00000002>;
    ......................
    cpuscfg {
    };
    ion {
    };
    dram {
    };
    memory@40000000 {
    };
    interrupt-controller@1c81000 {
    };
    sunxi-chipid@1c14200 {
    };
    timer {
    };
    pmu {
    };
    dvfs_table {
    };
    dramfreq {
    };
    gpu@0x01c40000 {
    };
    wlan {
    };
    bt {
    };
    btlpm {
    };
};
```

如果找到需要的配置，比如wlan的配置，运行如下命令即可。

```text
sunxi#fdt list /wlan //注意路径中的 /
wlan {
    compatible = "allwinner,sunxi-wlan";
    clocks = <0x00000096>;
    wlan_power = "vcc-wifi";
    wlan_io_regulator = "vcc-wifi-io";
    wlan_busnum = <0x00000001>;
    status = "okay";
    device_type = "wlan";
    wlan_regon = <0x00000077 0x0000000b 0x00000002 0x00000001 0xffffffff 0xffffffff 0
    x00000000>;
    wlan_hostwake = <0x00000077 0x0000000b 0x00000003 0x00000006 0xffffffff 0xffffffff
    0x00000000>;
};
```

1. 在 soc目录下找。如果在第一步中没有发现要找的配置，比如nand0的配置，则该配置可能在soc目录下。

```text
sunxi#fdt list /soc
soc@01c00000 {
    compatible = "simple-bus";
    #address-cells = <0x00000002>;
    #size-cells = <0x00000002>;
    ranges;
    device_type = "soc";
    ......................
    hdmi@01ee0000 {
    };
    tr@01000000 {
    };
    pwm@01c21400 {
    };
    nand0@01c03000 {
    };
    thermal_sensor {
    };
    cpu_budget_cool {
    };
    .......................
};
```

然后用如下命令显示即可:

```text
sunxi#fdt list /soc/nand0
nand0@01c03000 {
    compatible = "allwinner,sun50i-nand";
    device_type = "nand0";
    reg = <0x00000000 0x01c03000 0x00000000 0x00001000>;
    interrupts = <0x00000000 0x00000046 0x00000004>;
    clocks = <0x00000004 0x0000007e>;
    pinctrl-names = "default", "sleep";
    pinctrl-1 = <0x00000081>;
    nand0_regulator1 = "vcc-nand";
    nand0_regulator2 = "none";
    nand0_cache_level = <0x55aaaa55>;
    nand0_flush_cache_num = <0x55aaaa55>;
    nand0_capacity_level = <0x55aaaa55>;
    nand0_id_number_ctl = <0x55aaaa55>;
    nand0_print_level = <0x55aaaa55>;
    nand0_p0 = <0x55aaaa55>;
    nand0_p1 = <0x55aaaa55>;
    nand0_p2 = <0x55aaaa55>;
    nand0_p3 = <0x55aaaa55>;
    status = "disabled";
    nand0_support_2ch = <0x00000000>;
    pinctrl-0 = <0x000000a9 0x000000aa>;
};
```

1. 使用路径别名查找。别名是 device tree 中完整路径的一个简写，有一个专门的节点 ( /aliases) 来表示别名的相关信息，用如下命令可以查看系统中别名的配置情况：

```text
sunxi#fdt list /aliases
aliases {
    serial0 = "/soc@01c00000/uart@01c28000";
    ..............
    mmc0 = "/soc@01c00000/sdmmc@01c0f000";
    mmc2 = "/soc@01c00000/sdmmc@01C11000";
    nand0 = "/soc@01c00000/nand0@01c03000";
    disp = "/soc@01c00000/disp@01000000";
    lcd0 = "/soc@01c00000/lcd0@01c0c000";
    hdmi = "/soc@01c00000/hdmi@01ee0000";
    pwm = "/soc@01c00000/pwm@01c21400";
    boot_disp = "/soc@01c00000/boot_disp";
};
sunxi#
```

由于配置了nand0节点的路径别名，因此可以用如下命令来显示nand0的配置信息。

```text
sunxi#fdt list nand0
nand0@01c03000 {
    compatible = "allwinner,sun50i-nand";
    device_type = "nand0";
    reg = <0x00000000 0x01c03000 0x00000000 0x00001000>;
    ..................
    pinctrl-names = "default", "sleep";
    pinctrl-1 = <0x00000081>;
};
```

注：在fdt的所有命令中，alias 可以用作path参数。

```text
fdt list <path> [<prop>] - Print one level starting at <path>
fdt set <path> <prop> [<val>] - Set <property> [to <val>]
```

### 5.6.2 修改配置

### 5.6.2.1 修改整数配置

命令格式：fdt set path prop  示例：fdt set /wlan wlan_busnum <0x2>

```text
sunxi#fdt list /wlan
wlan {
    compatible = "allwinner,sunxi-wlan";
    clocks = <0x00000096>;
    wlan_power = "vcc-wifi";
    wlan_io_regulator = "vcc-wifi-io";
    wlan_busnum = <0x00000001>;
    status = "disable";
    device_type = "wlan";
};
sunxi#fdt set /wlan wlan_busnum <0x2>
sunxi#fdt list /wlan
wlan {
    compatible = "allwinner,sunxi-wlan";
    clocks = <0x00000096>;
    wlan_power = "vcc-wifi";
    wlan_io_regulator = "vcc-wifi-io";
    wlan_busnum = <0x00000002>; //修改后
    status = "disable";
    device_type = "wlan";
};
```

注：修改整数时，根据需要也可配置为数组形式，需要用空格来分隔。命令格式：fdt set path prop <0x1 0x2 0x3>

### 5.6.2.2 修改字符串配置

命令格式：fdt set path prop "xxxxx" 示例：fdt set /wlan status "disable"

```text
sunxi#fdt list /wlan
wlan {
    compatible = "allwinner,sunxi-wlan";
    clocks = <0x00000096>;
    wlan_power = "vcc-wifi";
    wlan_io_regulator = "vcc-wifi-io";
    wlan_busnum = <0x00000001>;
    status = "okay";
    device_type = "wlan";
};
sunxi#fdt set /wlan status "disable"
sunxi#fdt list /wlan
wlan {
    compatible = "allwinner,sunxi-wlan";
    clocks = <0x00000096>;
    wlan_power = "vcc-wifi";
    wlan_io_regulator = "vcc-wifi-io";
    wlan_busnum = <0x00000001>;
    status = "disable"; //修改后
    device_type = "wlan";
};
sunxi#
```

注：修改字符串时，根据需要也可配置为数组形式，需要用空格来分隔。命令格式：fdt set path prop "string1" "string2"

### 5.6.3 GPIO 或者 PIN 配置特殊说明

接口对应的数字编号说明如下：

```text
#define PA 0
#define PB 1
#define PC 2
#define PD 3
#define PE 4
#define PF 5
#define PG 6
#define PH 7
#define PI 8
#define PJ 9
#define PK 10
#define PL 11
#define PM 12
#define PN 13
#define PO 14
#define PP 15
#define default 0xffffffff
```

Sysconfig 中描述 gpio 的形式如下：Port:端口+组内序号<功能分配><内部电阻状态><驱动能力><输出电平状态>

### 5.6.3.1 Pin 配置说明

Pinctrl 节点分为 cpux 和 cpus，对应的节点路径如下：Cpux : /soc/pinctrl@01c20800 Cpus:/soc/pinctrl@01f02c00

### 5.6.3.2 查看 PIN 配置

PIN 配置属性字段说明:

| 属性字段           | 含义                                        |
| ------------------ | ------------------------------------------- |
| allwinner,function | 对应于 sysconfig 中的主键名                 |
| allwinner,pins     | 对应于 sysconfig 中每个 gpio 配置中的端口名 |
| allwinner,pname    | 对应于 sysconfig 中主键下面子键名字         |
| allwinner,muxsel   | 功能分配                                    |
| allwinner,pull     | 内部电阻状态                                |
| allwinner,drive    | 驱动能力                                    |
| allwinner,data     | 输出电平状态                                |

说明

**其中0xffffffff表示使用默认值。**

按以下方法查看cpux的 PIN 配置。

```text
sunxi#fdt list /soc/pinctrl@01c20800/lcd0
lcd0@0 {
    linux,phandle = <0x000000ab>;
    phandle = <0x000000ab>;
    allwinner,pins = "PD12", "PD13", "PD14", "PD15", "PD16", "PD17", "PD18", "PD19", "PD20", "PD21";
    allwinner,function = "lcd0";
    allwinner,pname = "lcdd0", "lcdd1", "lcdd2", "lcdd3", "lcdd4", "lcdd5", "lcdd6", "lcdd7", "lcdd8", "lcdd9";
    allwinner,muxsel = <0x00000003>;
    allwinner,pull = <0x00000000>;
    allwinner,drive = <0xffffffff>;
    allwinner,data = <0xffffffff>;
};
sunxi#
```

按以下方法查看cpus的 PIN 配置。

```text
sunxi# fdt list /soc/pinctrl@01f02c00/s_uart0
s_uart0@0 {
    linux,phandle = <0x000000b4>;
    phandle = <0x000000b4>;
    allwinner,pins = "PL2", "PL3";
    allwinner,function = "s_uart0";
    allwinner,pname = "s_uart0_tx", "s_uart0_rx";
    allwinner,muxsel = <0x00000002>;
    allwinner,pull = <0xffffffff>;
    allwinner,drive = <0xffffffff>;
    allwinner,data = <0xffffffff>;
};
sunxi#
```

### 5.6.3.3 修改 PIN 配置

使用fdt set命令可以修改 PIN 中相关属性字段

```text
sunxi#fdt set /soc/pinctrl@01c20800/lcd0 allwinner,drive <0x1>
sunxi#fdt list /soc/pinctrl@01c20800/lcd0
lcd0@0 {
    linux,phandle = <0x000000ab>;
    phandle = <0x000000ab>;
    allwinner,pins = "PD12", "PD13", "PD14", "PD15", "PD16", "PD17", "PD18", "PD19", "PD20", "PD21";
    allwinner,function = "lcd0";
    allwinner,pname = "lcdd0", "lcdd1", "lcdd2", "lcdd3", "lcdd4", "lcdd5", "lcdd6", "lcdd7", "lcdd8", "lcdd9";
    allwinner,muxsel = <0x00000003>;
    allwinner,pull = <0x00000000>;
    allwinner,drive = <0x00000001>;
    allwinner,data = <0xffffffff>;
};
```

说明

**示例中该处修改会影响allwinner,pins表示的所有端口的驱动能力配置，修改allwinner,muxsel, allwinner,pull,allwinner,data的值也会产生类似效果。**

### 5.6.3.4 GPIO 配置说明

Device tree 中 GPIO 对应关系，以 usb 中usb_id_gpio为例

```text
sunxi#fdt list /soc/usbc0
usbc0@0 {
    test = <0x00000002 0x00000003 0x12345678>;
    device_type = "usbc0";
    compatible = "allwinner,sun50i-otg-manager";
    ........
    usb_serial_unique = <0x00000000>;
    usb_serial_number = "20080411";
    rndis_wceis = <0x00000001>;
    status = "okay";
    usb_id_gpio = <0x00000030 0x00000007 0x00000009 0x00000000 0x00000001 0xffffffff 0xffffffff>;
};
```

对应于 device tree 中 usb_id_gpio = <0x00000030 0x00000007 0x00000009 0x00000000 0x00000001 0xffffffff 0xffffffff>，解释如下：

| 属性数值   | 含义                                           |
| ---------- | ---------------------------------------------- |
| 0x00000030 | device tree 内部一个节点相关信息，这里可以略过 |
| 0x00000007 | 端口 PH, 即 #define PH 7                       |
| 0x00000009 | 组内序号, 即 PH09                              |
| 0x00000000 | 功能分配, 即将 PH09 配为输入                   |
| 0x00000001 | 内部电阻状态, 即配为上拉                       |
| 0xffffffff | 驱动能力, 默认值                               |
| 0xffffffff | 输出电平, 默认值                               |

如果需要修改 usb_id_gpio的配置，可按如下方式（示例修改了驱动能力，输出电平两项）：

```text
sunxi#fdt set /soc/usbc0 usb_id_gpio <0x00000030 0x00000007 0x00000009 0x00000000 0x00000001 0x2 0x1>
sunxi#fdt list
usbc0@0 {
    test = <0x00000002 0x00000003 0x12345678>;
    device_type = "usbc0";
    compatible = "allwinner,sun50i-otg-manager";
    ........
    usb_serial_unique = <0x00000000>;
    usb_serial_number = "20080411";
    rndis_wceis = <0x00000001>;
    status = "okay";
    usb_id_gpio = <0x00000030 0x00000007 0x00000009 0x00000000 0x00000001 0x00000002 0x00000001>; //修改ok
};
sunxi#
```

5.7 其他命令说明（boot, reset, efex）

1.  boot : 启动内核
    
2.  reset: 复位重启系统
    
3.  efex: 进入烧录状态
    

说明

**注：其他更多 U-Boot 命令介绍，请进入 U-Boot shell 命令状态后输入"help"进行了解。**

### 6 基本调试方法介绍

debug 调试信息介绍如下：

1. debug_mode

debug_mode 可以控制 Boot0 的打印等级，打开文件{LICHEE_BOARD_CONFIG_DIR}/sys_config.fex，在主键  [platform] 下添加子键"debug_mode = 8"即表示开启所有打印，debug_mode=0 表示关闭启动时 Boot0 的打印 log,未显式配置 debug_mode 时，按 debug_mode=8 处理。目前常用的打印等级有  0（关闭所有打印）、1（只显示关键节点打印）、4（打印错误信息）、8（打印所有 log 信息）。

debug_mode 可以控制 U-Boot 的打印等级，打开文件{LICHEE_BOARD_CONFIG_DIR}/b3/uboot-board.dts，在  platform 节点下添加子键"debug_mode = 8"即表示开启所有打印，debug_mode=0 表示关闭启动时 U-Boot  的打印log, 未显式配置 debug_mode 时，按 debug_mode=8 处理。目前常用的打印等级有  0（关闭所有打印）、1（只显示关键节点打印）、4（打印错误信息）、8（打印所有 log 信息）。

1. usb_debug 在烧录或启动过程中，若遇到烧录失败或启动失败大致挂死在 usb  相关模块，但又不确定具体位置，这时可以打开usb_debug进行调试，开启usb_debug后有关 usb  相关的运行信息会被较详细打印出来。打开usb_debug的方式：打开usb_base.h文件，将其中的#defineSUNXI_USB_DEBUG宏定义打开，打开后重新编译 U-Boot 并打包烧录即可。

### 7 进入烧写的方法

1.  开机时按住 fel 键
    
2.  开机时打开串口按住键盘数字’2’
    
3.  进入 U-Boot 控制台输入efex
    
4.  进入 Android 控制台输入 reboot efex
    

### 8 常用接口函数

### 8.1 fdt 相关接口

1. const void *fdt_getprop(const void *fdt, int nodeoffset, const char *name, int *lenp)

*•* 作用：检索指定属性的值

*•* 参数：

   *•* fdt: 工作 flattened device tree

   *•* nodeoffset: 待修改节点的偏移

   *•* name: 待检索的属性名

   *•* lenp: 检索属性值的长度（会被覆盖）或者为 NULL

*•* 返回：

   *•* 非空（属性值的指针）：成功

   *•* NULL（lenp 为空）：失败

   *•* 失败代码（lenp 非空）：失败

1. int fdt_set_node_status(void *fdt, int nodeoffset, enum fdt_status status, unsigned int error_code)

*•* 作用：设置节点状态

*•* 参数：

   *•* fdt: 工作 flattened device tree

   *•* nodeoffset: 待修改节点的偏移

   *•* status:FDT_STATUS_OKAY, FDT_STATUS_DISABLED, FDT_STATUS_FAIL, FDT_STATUS_FAIL_ERROR_CODE

   *•* error_code:optional, only used if status is FDT_STATUS_FAIL_ERROR_CODE

*•* 返回：

   *•* 0: 成功

   *•* 非 0: 失败

1. int fdt_path_offset(const void *fdt, const char *path)

*•* 作用：通过全路径查找节点的偏移量

*•* 参数：

   *•* fdt: 工作 fdt

   *•* path: 全路径名称

*•* 返回：

   *•* >=0(节点的偏移量): 成功

   *•* <0: 失败代码

1. static inline int fdt_setprop_u32(void *fdt, int nodeoffset, const char *name, uint32_t val)

*•* 作用：将属性值设置为一个 32 位整型数值，如果属性值不存在，则新建该属性

*•* 参数：

   *•* fdt: 工作 flattened device tree

   *•* nodeoffset: 待修改节点的偏移

   *•* name: 待修改的属性名

   *•* val:32 位目标值

*•* 返回：

   *•* 0: 成功

   *•* <0: 失败代码

1. static inline int fdt_setprop_u64(void *fdt, int nodeoffset, const char *name, uint64_t val)

*•* 作用：与fdt_setprop_u32类似，将属性值设置为一个 64 位整型数值，如果属性值不存在，则新建该属性

*•* 参数：

   *•* fdt: 工作 flattened device tree

   *•* nodeoffset: 待修改节点的偏移

   *•* name: 待修改的属性名

   *•* val:64 位目标值

*•* 返回：

   *•* 0: 成功

   *•* <0: 失败代码

1. \#define fdt_setprop_string(fdt, nodeoffset, name, str) fdt_setprop((fdt), (nodeoffset), (name), (str), strlen(str)+1)

*•* 作用：将属性值设置为一个字符串，如果属性值不存在，则新建该属性

*•* 参数：

   *•* fdt: 工作 flattened device tree

   *•* nodeoffset: 待修改节点的偏移

   *•* name: 待修改的属性名

   *•* str: 目标值

*•* 返回：

   *•* 0: 成功

   *•* <0: 失败代码

注意：在sys_config.fex的配置中，节点的启用状态为 0 或 1。转换到 fdt 中对应的 status 属性为disable或okay。

1. int save_fdt_to_flash(void *fdt_buf, size_t fdt_size)

*•* 作用：保存修改到 flash

*•* 参数：

   *•* fdt_buf: 当前工作 flattened device tree

   *•* fdt_size: 当前工作 flattened device tree 的大小，可以通过fdt_totalsize(fdt_buf )获取

*•* 返回：

   *•* 0: 成功

   *•* <0: 失败

1. 应用参考

U-Boot 中 fdt 命令行的实现：cmd/fdt.c

### 8.2 env 相关接口函数

1. int env_set(const char *varname, const char *varvalue)

*•* 作用：将环境变量 varname 的值设置为 varvalue，重启失效

*•* 参数：

   *•* varname: 待设置环境变量的名称     

   *•* varvalue: 将指定的环境变量修改为该值

*•* 返回：

   *•* 0: 成功

   *•* 非 0: 失败

1. char *env_get(const char *name)

*•* 作用：获取指定环境变量的值

*•* 参数：

   *•* name: 变量名称

*•* 返回：

   *•* NULL: 失败

   *•* 非空（环境变量的值）：成功

1. int env_save(void)

*•* 作用：保存环境变量，重启仍保存

*•* 参数: 无 

*•* 返回：

   *•* 0: 成功

   *•* 非 0: 失败

1. 应用参考

board/sunxi/sunxi_bootargs.c update_bootargs通过 cmdline 向 kernel 提供信息，主要是通过更新bootargs变量实现env_set(\"bootargs\", cmdline)。

### 8.3 调用 U-Boot 命令行

1. int run_command_list(const char *cmd, int len, int flag)

*•* 作用：执行 U-Boot 命令行

*•* 参数：

   *•* cmd: 命令字符指针

   *•* len: 命令行长度，设置为-1 则自动获取

   *•* flag: 任意，因为 sunxi 中没有用到

*•* 返回：

   *•* 0: 成功

   *•* 非 0: 失败

1. 应用参考：

common/autoboot.c autoboot_command实现了 U-Boot 的自动启动命令

s = env_get(\"bootcmd\");

run_command_list(s, -1, 0)。

### 8.4 Flash 的读写

1. int sunxi_flash_read(uint start_block, uint nblock, void *buffer)

*•* 作用：将指定起始位置start_block的nblock读取到buffer

*•* 参数：

   *•* start_block: 起始地址

   *•* nblock:block 个数

   *•* buffer: 内存地址

*•* 返回：

   *•* 0: 成功

   *•* 非 0: 失败

1. int sunxi_flash_write(uint start_block, uint nblock, void *buffer)

*•* 作用：将buffer写入指定起始位置start_block的nblock中 

*•* 参数：

   *•* start_block: 起始地址

   *•* nblock:block 个数

   *•* buffer: 内存地址

*•* 返回：

   *•* 0: 成功

   *•* 非 0: 失败

1. int sunxi_sprite_read(uint start_block, uint nblock, void *buffer)

*•* 作用与sunxi_flash_read相似

1. int sunxi_sprite_write(uint start_block, uint nblock, void *buffer)

*•* 作用与sunxi_flash_write相似

1. 应用参考

common/sunxi/board_helper.c sunxi_set_bootcmd_from_mis实现了对 misc 分区的读写操作

### 8.5 获取分区信息

1. int sunxi_partition_get_partno_byname(const char *part_name)

*•* 作用：根据分区名称获取分区号

*•* 参数：

   *•* part_name: 分区名称

*•* 返回：

   *•* <0: 失败

   *•* >0（分区号）：成功

1. int sunxi_partition_get_info_byname(const char *part_name, uint *part_offset, uint *part_size) 

*•* 作用：根据分区名称获取分区的偏移量和大小

*•* 参数：

   *•* part_name: 分区名称

   *•* part_offset: 分区的偏移量

   *•* part_size: 分区的大小

*•* 返回：

   *•* 0: 成功

   *•* -1: 失败

1. uint sunxi_partition_get_offset_byname(const char *part_name)

*•* 作用：根据分区名称获取偏移量

*•* 参数：

   *•* part_name: 分区名称

*•* 返回：

   *•* <=0 : 失败

   *•* >0 : 成功

1. int sunxi_partition_get_info(const char *part_name, disk_partition_t *info)

*•* 作用：根据part_name获取分区信息

*•* 参数：

   *•* part_name: 分区名称

   *•* info: 分区信息

*•* 返回：

   *•* 非 0: 失败

   *•* 0: 成功

1. lbaint_t sunxi_partition_get_offset(int part_index)

*•* 作用：card sprite 模式下获取分区的偏移量

*•* 参数：

   *•* part_index: 分区号

*•* 返回：

   *•* >=0（偏移量）：成功

   *•* -1: 失败

1. 应用参考

启动时加载图片：drivers/video/sunxi/logo_display/sunxi_load_bmp.c

### 8.6 GPIO 相关操作

1. int fdt_get_one_gpio(const char* node_path, const char* prop_name,user_gpio_set_t* gpio_list)

*•* 作用：根据路径node_path和 gpio 名称prop_name获取 gpio 配置

*•* 参数：

   *•* node_path：fdt 路径

   *•* prop_name：gpio 名称

   *•* gpio_list：待获取的 gpio 信息

*•* 返回：

   *•* 0：成功

   *•* -1：失败

1. ulong sunxi_gpio_request(user_gpio_set_t *gpio_list, __u32 group_count_max)

*•* 作用：根据 gpio 配置获取 gpio 操作句柄

*•* 参数：

   *•* gpio_list：gpio 配置列表，可以由fdt_get_one_gpio获得

   *•* group_count_max: gpio_list中最大的 gpio 配置个数

*•* 返回：

   *•* 0：失败

   *•* >0（gpio 操作句柄）：成功

1. __s32 gpio_write_one_pin_value(ulong p_handler, __u32 value_to_gpio, const char *gpio_name)

*•* 作用：根据 gpio 操作句柄写数据

*•* 参数：

   *•* p_handler：gpio 操作句柄，可由sunxi_gpio_request获取

   *•* value_to_gpio：待写入数据，0 或 1 

   *•* gpio_name：gpio 名称

*•* 返回：

   *•* EGPIO_SUCCESS：成功

   *•* EGPIO_FAIL：失败

1. 应用参考

操作 led 状态：

```text
ssprite/sprite_led.c

user_gpio_set_t gpio_init;

fdt_get_one_gpio("/soc/card_boot", "sprite_gpio0", &gpio_init); //获取/soc/card_boot中sprite_gpio0的gpio配置

sprite_led_hd = sunxi_gpio_request(&gpio_init, 1); //获取gpio操作句柄

gpio_write_one_pin_value(sprite_led_hd, sprite_led_status, "sprite_gpio0"); //操作led状态
```

### 9 常用资源的初始化阶段

*•* env ：环境变量初始化后可以访问

*•* fdt ：在 U-Boot 运行开始即可访问

*•* malloc ：在重定位后才能访问

https://zhuanlan.zhihu.com/p/609754486?utm_id=0





## 4. Linux 内核配置

一、Linux内核的配置

驱动进入内核有两种方式：模块和直接编译进内核
Linux内核的配置系统由三个部分组成，分别是：
1、Makefile：分布在 Linux 内核源代码根目录及各层目录中，定义 Linux 内核的编译规则
2、配置文件：.config可执行的脚本文件，给用户提供配置选择的功能
3、配置工具：包括配置命令解释器（对配置脚本中使用的配置命令进行解释）和配置用户界面（提供基于字符界面、基于 Ncurses 图形界面以及基于 Xwindows 图形界面的用户配置界面，各自对应于 Make config、Make menuconfig 和 make xconfig）
1.1 配置用户界面

主要分为三种方式：

1、make config（基于文本的最为传统的配置界面，不推荐使用） 
2、make menuconfig（基于文本选单的配置界面，字符终端下推荐使用） 
3、make xconfig（基于图形窗口模式的配置界面，Xwindow下推荐使用） 

    1
    2
    3

目的都是生成一个.config文件，有三种选择，它们分别代表的含义如下：
Y－-将该功能编译进内核
N－-不将该功能编译进内核
M－-将该功能编译成可以在需要时动态插入到内核中的模块
二、make menuconfig

Menuconfig 配置内核原理： 在Linux里面我们所看到的 menuconfig 界面是通过配置内核顶层的Kconfig产生的，而当输入make menuconfig命令的时候系统会读取Makefile来解析Kconfig。 通常会在Kconfig里面编写以下四项：

1、模块的名字，用module开头
2、选项，通常设为bool(二选一)或者trastate(三选一)
3、默认选项
4、帮助说明

    1
    2
    3
    4

2.1 Loadable module support

含义：对模块的支持
2.2 Networking options

含义：网络选项

    Packet Socket：该选项用来与网卡进行通信而不需要在内核中实现网络协议
    TCP/IP networking：内核将支持TCP/IP协议

2.3 Console drivers

含义：配置控制台驱动

    VGA text console：在VGA模式下启动字符模式。多数人都需要它
    video mode selection support：使启动的时候能够使用字符模式的分辨率
    Sound sound：声卡驱动，可以配置声卡
————————————————
版权声明：本文为CSDN博主「future_sky_word」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/future_sky_word/article/details/128512412

## 5. 添加一个 Linux 源码文件

参考用书：《操作系统实践：基于Linux的应用与内核编程》

一．添加一个内核模块

1.1需求分析

对于一个应用程序而言，源代码经编译后与标准运行库链接，通过系统调用执行操作系统内核中的特权指令，指令返回的结果通过系统调用返回给用户，完成程序。

由于Linux是单内核多模块的操作系统，整个操作系统只包含一个由多个不同功能模块组成的内核，通过Linux系统的这种特性,可以动态添加自己编写的内核模块，并由系统每次启动时进行加载。

通过内核模块的动态添加和删除，可以直观的感受到内核模块的编写以及动态添加和删除的过程。可以通过此次实验理解用户态（User Model）和内核态（Kernel Model）的关系。并掌握内核模块代码中的一些常见宏和参数以及内核模块程序和应用程序的差异。

实验流程为：编写kello.c文件和Makefile文件，并使用insmod和rmmmod命令对内核模块进行安装和卸载。观察终端输出的不同信息。同时编写代码时应注意安全问题，不要对内核进行不当访问从而使系统出现错误。

输入：使用insmod安装所编写的内核模块。

输出：通过dmesg命令观察安装内核模块和卸载内核模块所输出的信息。

1.2概要设计

本次实验包含两个文件：kello.c和编译所需的Makefile文件，kello.c文件包含模块初始化函数hello_init，在模块初始化时被调用，以及模块回收函数hello_exit，在模块被撤销时使用。

在该文件的最后，需要添加两行声明module_init(hello_init)和module_exit(hello_exit)，使模块被更高效的加载执行和撤销，加快内存的分配和回收

对于Makefile文件内容，KERNELRELEASE定义在linux内核源代码中的顶层makefile，boj-m表示所安装内核模块的名称，需要和c文件名字相同。

KDIR和PWD目录分别代表内核的源代码目录和当前的工作路径，defult中为编译命令以及一些文件的删除命令。

1.3详细设计

Kello.c的hello_init调用printk输出一段初始化信息，hello_exit调用printk输出模块回收时打印的信息。

对于Makefile文件，KERNELRELEASE是在Linux内核源代码顶层Makelile中定义的一个变量，在第一次读取执行此 Makefile文件时，KERNELRELEASE没有被定义，所以make将读取执行else之后的内容。

如果make的目标是clean. 直接执行clean操作,然后结束。

当没有声明make的目标时,make执行默认操作,即default 后的指令，此时-C$ (KDIR)指明跳转到内核源代码目录下读取那里的Makefiles SUBDIRS $ (PWD) 表明需要返回到当前目录继续读入并执行当前的Makefile.当从内核源代码目录返回时, KERNELRELEASE已被定义,kbuild也被启动去解析kbuild语法的语句，make将继续读取else之前的内容。

实验过程：

在当前文件夹下执行make命令

观察当前文件夹是否生成所需文件

sudo insmod 安装LKM

观察安装LKM后dmesg输出的内核初始化信息

sudo rmmod 卸载LKM

观察卸载LKM后dmesg输出的内核初始化和撤销信息

1.4调试分析

分析一:make命令提示空变量名错误

首先遇到的错误为，make命令报告空变量名。是make文件的格式问题，注意在$(MAKE) -C $(KDIR) SUBDIRS =$(shell pwd) modules，SUBDIRS的后没有空格，去掉空格后问题解决。

分析二：mkdir创建目录权限不够

mkdir创建目录权限不够，错误定位在fixdep.c文件的404行，fatal error打开依赖文件的权限不够，并显示compilation terminated（编译结束）。

fixdep.c文件是make的一个工具，由make在编译时调用。问题出在make -C SUBDIRS=处，应修改为make -C M=。二者的区别在于，$(MAKE)相当于make，-C 选项的作用是指将当前工作目录转移到所指定的位置。“M=”表示当用户需要以某个内核为基础编译一个外部模块的话，需要在make modules 命令中加入“M=dir”，程序会到所指定的dir目录中查找模块源码，将其编译，生成.ko文件。

M并非随意命名，在新的内核模块编程中的make命令中有个M选项，是makefile脚本中的一个变量，$(MAKE) -C $(KDIR) M=$(PWD)与$(MAKE) -C $(KDIR) SUBDIRS =$(PWD)的作用是一样的，不过SUBDIRS是过时的使用方法，修改后问题得以解决。

make文件和c文件如下：

    ifneq ($(KERNELRELEASE),)
    obj-m := kello.o
    else 
    KDIR := /lib/modules/$(shell uname -r)/build
    PWD := $(shell pwd)
    default:
        $(MAKE) -C $(KDIR) M=$(shell pwd) modules
        rm -r -f .tmp_versions *.mod.c .*.cmd *.o *.symvers
    endif
    
    #include<linux/module.h>
     
    /*
    此函数为模块初始化实例，
    将在模块初始化时被调用
    */
    int hello_init(void)
    {
        printk("\nI AM HERE IN KERNEL:)\n");
        return 0;
    }
     
    /*
    此函数为模块回收实例，
    将在模块被撤销时使用
    */
    void hello_exit(void){
        printk("\n I AM OUT BYE BYE :)\n");
    }
     
    MODULE_AUTHOR("zhuoge04");//描述模块作者为本人
    MODULE_LICENSE("GPL");
     
    /*
    以下两行声明可以使模块被更高效的加载执行和撤销，
    加快内存的分配和回收
    */
    module_init(hello_init);
    module_exit(hello_exit);
————————————————
版权声明：本文为CSDN博主「日赴一日」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_49071428/article/details/128577284

## 6. busybox 功能和作用



在嵌入式系统构建中，Busybox可用于构建轻量级的[根文件系统](https://www.zhihu.com/search?q=根文件系统&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2714183182})

，本文从源码结构和源码入口角度分析busybox，了解其背后的运作机制。

>  busybox版本：1.35.0
>  

## **一、Busybox简介**

### **（1-1）开源项目**

Busybox是一个开源项目，遵循GPL v2协议。Busybox将众多的UNIX命令集合进了一个很小的可执行程序中，可以用来替代GNU  fileutils、shellutils等工具集。Busybox中各种命令与相应的GNU工具相比，所能提供的选项比较少，但是对于一般的应用场景也足够了，特别是在嵌入式系统的设计中。

### **（1-2）程序本体较小**

Busybox在设计过程中对文件大小进行了优化，并考虑了系统资源有限(比如内存等)的情况。与一般的GNU工具集动辄几M的体积相比，动态链接的Busybox只有几百K，即使是采用静态链接也只有1M左右。除此之外，Busybox按模块设计，可以很容易地加入、去除某些命令，或增减命令的某些选项。

### **（1-3）使用简单**

如果使用Busybox来创建根文件系统，使用起来比较方便，只需要在/dev目录下创建必要的设备节点，在/etc目录下增加一些配置文件即可，当然如果Busybox是动态链接的，那么还需要在/lib目录下包含相关的运行库文件。

## **二、Busybox源码目录结构**

在较老版本的Busybox中，对于Busybox的多个程序是全部塞进了一个名为`utility.c`的文件中，后来更改了Busybox的整体源码结构和设计，将这些程序拆分成了各个工具模块。其目录结构如下图所示：

![img](https://picx.zhimg.com/80/v2-5c5d2b35f65640f329c655eb6925751b_720w.webp?source=2c26e567)

| 序号 | 目录名称      | 功能说明                                                     |
| ---- | ------------- | ------------------------------------------------------------ |
| 1    | applets       | 实现applets框架的文件。目录中包含了几个main()的文件          |
| 2    | applets_sh    | 此目录包含了几个作为shell脚本实现的applet示例。在“make install”时不会被自动安装，需要使用时，手动处理 |
| 3    | arch          | 包含用于不同体系架构的makefile文件。约束busybox在不同架构体系下的编译构建过程 |
| 4    | archival      | 与压缩相关命令的实现源文件。                                 |
| 5    | configs       | busybox自带的默认配置文件                                    |
| 6    | console-tools | 与控制台相关的一些命令                                       |
| 7    | coreutils     | 常用的一些核心命令。例如chgrp、rm等                          |
| 8    | debianutils   | 针对Debian的套件。                                           |
| 9    | e2fsprogs     | 针对Linux Ext2 FS prog的命令。例如chattr、lsattr             |
| 10   | editors       | 常用的编辑命令。例如diff、vi等                               |
| 11   | findutils     | 用于查找的命令                                               |
| 12   | include       | busybox项目的头文件                                          |
| 13   | init          | init进程的实现源码目录                                       |
| 14   | klibc-utils   | klibc命令套件                                                |
| 15   | libbb         | 与busybox实现相关的库文件                                    |
| 16   | libpwdgrp     | libpwdgrp相关的命令                                          |
| 17   | loginutils    | 与用户管理相关的命令                                         |
| 18   | mailutils     | 与mail相关的命令套件                                         |
| 19   | miscutils     | 该文件下是一些杂项命令，针对特定应用场景                     |
| 20   | modutils      | 与模块相关的命令                                             |
| 21   | networking    | 与网络相关的命令，例如arp                                    |
| 22   | printutils    | Print相关的命令                                              |
| 23   | procps        | 与内存、进程相关的命令                                       |
| 24   | runit         | 与Runit实现相关的命令                                        |
| 25   | shell         | 与shell相关的命令                                            |
| 26   | sysklogd      | 系统日志记录工具相关的命令                                   |
| 27   | util-linux    | Linux下常用的命令，主要与文件系统操作相关的命令。            |

## **三、Busybox程序主体**

Busybox是在linux内核启动后加载运行的用户空间程序，在源码设计上是基于C语言完成设计和开发的。与常规程序一样，Busybox的入口同样是`main()`，定义在libbb/appletlib文件的末尾处。在函数开始处，使用`ENABLE_BUILD_LIBBUSYBOX`对函数名称进行了条件分支处理：如果`ENABLE_BUILD_LIBBUSYBOX`为真，则表示将Busybox以库的方式进行构建。

在函数体中，以条件宏定义进行代码的编译逻辑控制：

```text
 /* Tweak malloc for reduced memory consumption */
#ifdef M_TRIM_THRESHOLD
 /* M_TRIM_THRESHOLD是释放的最顶层内存的最大数量
  * 默认值太大，是256k
  */
 mallopt(M_TRIM_THRESHOLD, 8 * 1024);
#endif
#ifdef M_MMAP_THRESHOLD
 /* M_MMAP_THRESHOLD是使用mmap()的请求大小阈值。
  * 默认值是256k
  */
 mallopt(M_MMAP_THRESHOLD, 32 * 1024 - 256);
#endif
```

上述代码都调用了`mallopt()`函数，该函数用于设置内存的分配参数，由于默认值太大（为256KB），故此处调整内存分配大小，让出多余的内存。

接着，是一个由`#if -- #elif -- #else -- #endif`控制的条件宏多分支判断结构语句，此处以Busybox的一般运行情况为例（在Linux内核启动后期，加载并运行Busybox构建出的`init`程序）。其执行逻辑如下：

首先Busybox是一个linux下的工具集合，本质则是一个个的命令，例如：ls、mv、cp等，在命令行我们输入想要执行的操作时，例如：`mkdir iriczhao`，则会将参数传递给Busybox，然后由他完成对应的操作。

在源码中，使用`char * applet_name`表示工具的名称（本质是字符串），首先会调用`lbb_prepare()`函数：

```text
lbb_prepare("busybox" IF_FEATURE_INDIVIDUAL(, argv));
```

将会设置`applet_name`的值为“busybox“，用于执行`ENABLE_FEATURE_INDIVIDUAL`为真时的逻辑操作：

```text
void lbb_prepare(const char *applet
      IF_FEATURE_INDIVIDUAL(, char **argv))
{
#ifdef bb_cached_errno_ptr
 ASSIGN_CONST_PTR(&bb_errno, get_perrno());
#endif
 applet_name = applet;

 if (ENABLE_LOCALE_SUPPORT)
  setlocale(LC_ALL, "");

#if ENABLE_FEATURE_INDIVIDUAL
 /* Redundant for busybox (run_applet_and_exit covers that case)
  * but needed for "individual applet" mode */
 if (argv[1] && !argv[2] && strcmp(argv[1], "--help") == 0 && !is_prefixed_with(applet, "busybox"))
 {
  /* Special cases. POSIX says "test --help"
   * should be no different from e.g. "test --foo".
   */
  if (!(ENABLE_TEST && strcmp(applet_name, "test") == 0) && !(ENABLE_TRUE && strcmp(applet_name, "true") == 0) && !(ENABLE_FALSE && strcmp(applet_name, "false") == 0) && !(ENABLE_ECHO && strcmp(applet_name, "echo") == 0))
   bb_show_usage();
 }
#endif
}
```

接着，会解析命令行传递的第一个参数：

```text
 applet_name = argv[0];
 if (applet_name[0] == '-')
  applet_name++;
 applet_name = bb_basename(applet_name);
```

例如，在命令行输入`mkdir iriczhao`命令，则会解析到`mkdir`命令传递给applet_name，至于后面的参数（此处是iriczhao）是如何传递的，后文会描述到。

如果配置了`FEATURE_SUID_CONFIG`宏定义，在`parse_config_file()`函数中还将从/etc/busybox.conf文件中解析关于busybox的配置参数。

在最后，则是busybox的重要函数：`run_applet_and_exit()`，该函数定义如下：

```text
static NORETURN void run_applet_and_exit(const char *name, char **argv)
{
#if ENABLE_BUSYBOX
  //检查是否是带有busybox前缀的字符串，如果不是，则返回NULL。
  //如果在命令行下输入具体的命令，则不是带有busybox前缀的命令字符串，则不会执行该条件下的语句
 if (is_prefixed_with(name, "busybox"))
  exit(busybox_main(/*unused:*/ 0, argv));
#endif
#if NUM_APPLETS > 0
 /* find_applet_by_name() search is more expensive, so goes second */
 {
  int applet = find_applet_by_name(name);
  if (applet >= 0)
   run_applet_no_and_exit(applet, name, argv);
 }
#endif

 /*bb_error_msg_and_die("applet not found"); - links in printf */
 full_write2_str(applet_name);
 full_write2_str(": applet not found\n");
 /* POSIX: "If a command is not found, the exit status shall be 127" */
 exit(127);
}
```

如果NUM_APPLETS大于0，则会执行对应的命令操作，并退出；否则，busybox将会报错：

```text
#if NUM_APPLETS > 0
 /* find_applet_by_name() search is more expensive, so goes second */
 {
  int applet = find_applet_by_name(name);
  if (applet >= 0)
   run_applet_no_and_exit(applet, name, argv);
 }
#endif
  
  //正常情况下（NUM_APPLETS > 0），不会执行下述代码。
 /*bb_error_msg_and_die("applet not found"); - links in printf */
 full_write2_str(applet_name);
 full_write2_str(": applet not found\n");
 /* POSIX: "If a command is not found, the exit status shall be 127" */
 exit(127);
  
```

从上述代码可知，在命令行键入命令后，实则起关键作者的函数是：`find_applet_by_name()和run_applet_no_and_exit()`。下文将继续分析。

## **四、Busybox程序运行剖析和实列**

在上一小节中，已经知道当我们在busybox的命令行下，键入命令后，执行具体操作的函数是：`find_applet_by_name()和run_applet_no_and_exit()`。

在编译构建源码并安装busybox后，在安装目录下的文件结构则是一个名为busybox的可执行程序和很多的链接，这些链接实则是我们在命令行键入的命令名称。如下图所示：

![img](https://picx.zhimg.com/80/v2-f26d263ea0666e60234b40d49a3d21e0_720w.webp?source=2c26e567)

从源码角度看，busybox中的命令都有一一对应的执行函数，其函数命名格式为`xxx_main()`，在源码设计上，其内部在/include/applet_tabls.h头文件中维护了一张**命令表**，定义如下（代码太长，有省略）：

```text
int (*const applet_main[])(int argc, char **argv) = {
test_main,
test_main,
acpid_main,
add_remove_shell_main,
addgroup_main,
adduser_main,
adjtimex_main,
uname_main,
arp_main,
arping_main,
ascii_main,
ash_main,
awk_main,
baseNUM_main,
baseNUM_main,
basename_main,
//省略大量内容
//...
}
```

上述[函数指针](https://www.zhihu.com/search?q=函数指针&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2714183182})

数组中的元素则是分布于busybox源码各个目录下命令入口函数。在代码执行逻辑中，首先会调用`find_applet_by_name()`函数，通过传入的命令名称获取在命令表中的数组下标。并将命令对应的下标applet、命令名称name和命令行参数字符串argv传递给`run_applet_no_and_exit()`函数（注：解释了上一小节中，命令行对应命令后面的参数是如何传递的），该函数定义如下：

```text
void FAST_FUNC run_applet_no_and_exit(int applet_no, const char *name, char **argv)
{
 int argc;

 /*
  * We do not use argv[0]: do not want to repeat massaging of
  * "-/sbin/halt" -> "halt", for example.
  */
 applet_name = name;

 show_usage_if_dash_dash_help(applet_no, argv);

 if (ENABLE_FEATURE_SUID)
  check_suid(applet_no);

 argc = string_array_len(argv);
 xfunc_error_retval = applet_main[applet_no](argc, argv);

 /* Note: applet_main() may also not return (die on a xfunc or such) */
 xfunc_die();
}
#endi
```

在上述代码中，执行命令下的对应具体操作函数的语句是：

```text
xfunc_error_retval = applet_main[applet_no](argc, argv);
```

`applet_main`是命令表数组，`applet_no`是对应命令的数组下标，本质则是调用对应的`applet_main`命令表数组中的元素（函数指针），并将`argc`和`argv`作为参数给了对应的命令执行函数。

https://www.zhihu.com/question/32018633/answer/2714183182



# 第九部分：驱动程序

## 1. Linux 平台设备驱动

前言


        要满足 Linux 设备模型，就必须有总线、设备和驱动。但是有的设备并没有对应的物理总线，比如 LED、RTC 和蜂鸣器等。为此，内核专门开发了一种虚拟总线一-platfomm总线，用来连接这些没有物理总线的设备或者一些不支持热插拔的设备，DM9000 网卡
设备就是挂接在这条总线上的。
一、平台设备

平台设备是用structplatform device 结构来表示的，它的定义如下


        驱动开发者关心的主要成员如下。
    
        name: 设备的名字，在平台总线的 match 函数中可用于同平台驱动的匹配
    
        id:设备的ID 号，用于区别同类型的不同平台设备。
        dev:内的 struct device。
        num_resources:平台设备使用的资源个数。
        resource: 平台设备的资源列表 (数组)，指向资源数组中的首元素.
    
        id_entry:用于同平台驱动匹配的 ID,在平台总线的 match 函数中首先尝试匹配该 ID,如果不成功再尝试用 name 成员来匹配。
    
        在平台设备中，最关键的就是设备使用的资源信息的描述，这是实现设备和驱动分离的关键。struct resource 的定义如下


驱动开发者关心的主要成员如下。
        start: 资源的开始，对于 IO 内存来说就是起始的内存地址，对于中断资源来说就是起始的中断号，对于 DMA 资源来说就是起始的 DMA 通道号。
        end:资源的结束。
        flags:资源的标志，定义在“include/linux/ioport.h”文件中，最常见的有如下几种.

        IORESOURCE_MEM:资源的类型是内存资源，也包括I/O内存。
        IORESOURCE_IRO:资源的类型是中断资源。
        IORESOURCE_DMA:资源的类型是 DMA 通道资源。
        资源可以组成一个树形结构，由成员parent、sibling和child来完成.
    
        平台设备及其资源通常存在于BSP(Board Support Package，板级支持包)文件中,该文件通常包含和目标板相关的一些代码。例如对于 QT2410 目标板，其对应的 BSP文件为arch/arm/mach-s3c24xx/mach-gt2410.c，现将其描述CS8900网卡的平台设备摘录如下。


        CS8900 平台设备有两个资源，分别是 IORESOURCE_MEM 和 IORESOURCE_IRQ两种类型的，并用宏 DEFINE_RES_MEM 和 DEFINE_RES_IRQ 来定义。对于 DEFINERES_MEM 宏，里面的两个参数分别是内存的起始地址和大小:对于 DEFINE_RES_IRQ宏，里面的参数则是中断号。读者可以自行查看这两个宏的定义，最终是对 start、end和flags成员进行了赋值。最终定义的平台设备是 qt2410_cs89x0，ARRAY_SIZE 是用于获取数组元素个数的宏。

向平台总线注册和注销的平台设备的主要函数如下。


        platform_add_devices用于一次注册多个平台设备，platform_device_register 一次只注册一个平台设备。其实，platform_add_devices 是通过多次调用 platform_device_register来实现的。platform_device_unregister 用于注销平台设备。
        当平台总线发现有和平台设备匹配的驱动时，就会调用平台驱动内的一个函数，并传递匹配的平台设备结构地址，平台驱动就可以从中获取设备的资源信息。关于资源操作的主要函数如下。



        platform_get_resource:从平台设备 dev 中获取类型为type、序号为num的资源.
    
        resource_size:返回资源的大小，其值为 end-start +1。
    
        例如，在 CS8900 网卡驱动中就有如下的代码来获取资源及其大小。


        代码第1857行获取了IORESOURCE_MEM资源，序号为0。代码第1858 行获取了IORESOURCE_IRQ 资源，序号也为0。所以，当资源类型不同后，序号重新开始编号.代码第1865行获取了内存资源的大小。代码第1872行使用ioremap将内存资源进行映射得到映射后的虚拟地址。

二、平台驱动


平台驱动是用struct platform_driver 结构来表示的，它的定义如下


驱动开发者关心的主要成员如下。
        probe: 总线发现有匹配的平台设备时调用。

        remove:所驱动的平台设备被移除时或平台驱动注销时调用。
    
        shutdown、suspend 和 resume: 电源管理函数，在要求设备电、挂起和恢复时被调用。内嵌的 struct device_driver 的 pm 成员也有对应的电源管理函数。
    
        id_table: 平台驱动可以驱动的平台设备ID 列表，可用于和平台设备匹配。
    
        向平台总线注册和注销的平台驱动的主要函数如下。


        因为在驱动中，经常在模块初始化函数中注册一个平台驱动，在清除函数中注销一个平台驱动，所以内核定义了一个宏来简化这些代码，宏的定义如下。

三、平台驱动简单实例


        在前面的基础之上，我们可以先来编写一个简单的平台驱动，再编写一个模块来注册两个设备，代码如下


        在 pltdev.c 文件中，代码第 7 行至第 29 行分别定义了两个平台设备，id为0和1以示区别，名字都为 pdev，没有使用任何资源。在模块的初始化函数和清除函数中分别注册和注销了这两个平台设备。
        在 pltdrv.c 文件中，代码第 34 行至第42 行定义了一个平台驱动，名字也为pdev,这样才能和平台设备匹配。pm 是电源管理函数的集合，实现了挂起和恢复两个电源管理操作。因为是虚拟设备，所以并没有做任何电源管理相关的操作。为了简单,probe 和remove函数也只是返回成功而已。代码第44行使用module_platform_driver这个宏来简化模块初始化函数和卸载函数的编写。
        编译和测试的命令如下

 








































































































































从上面的测试结果可以看到，平台驱动驱动了两个设备 pdev.0 和 pdev.1，这是设备名字加过构成的名字。


四、 电源管理


        在平台驱动里面实现了挂起和恢复两个电源管理函数，从而可以管理设备的电源状态。 /sys/devices/platform/pdev.0/power/control 和 /sys/devices/platform/pdev.1/power/control两个文件可以用来管理两个设备的电源控制方式，如果文件的内容为 auto，那么设备的电源会根据系统的状态自动进行管理，为on则表示打开。我们首先确定电源控制方式为自动，可以使用下面的命令进行确认。

貌似只跑一个linux的内核不行捏

没有挂起命令，只使用串口貌似也不能挂起，那这样的话就还是用ubuntu吧

 

 

接下来将 Ubuntu 系统挂起

喵的恢复不了了

 

试试用vm的挂起能不能起到效果

还是不行下面我修改一下驱动程序看看能不能在挂起后立刻自动恢复




 看看上面的选项是不是y并且确定他有唤醒方式

 

 

API和版本貌似对不上换一下试试

 

 

我又修改了一下代码

 这次没挂起直接关机了

使用命令后挂起成功了但是又是黑屏状态估计哪没配置好

服了，这里我环境不行就当成功验证了吧，后面我看看怎么修改一下环境或者直接在板子上跑这样很容易恢复。

系统挂起后,再重新恢复系统,使用 dmesg 命令可以看到,驱动中的 suspend 和 resume函数先后都被调用了两次。
# dmesg
[ 171.396323] pdev: suspend
[ 171.396325] pdev; suspend
......

176.699954] pdev:resume

[ 176.699959] pdev: resume

五、udev 和驱动的自动加载


        在上面的例子中，我们可以通过加载模块来向系统添加两个设备，也可以通过移除模块来删除这两个设备。对于这样的操作，我们想使设备被添加到系统后，其驱动能够自动被加载，这对于实际的可支持热插拔的硬件来说更有必要。比如，我们插入一个USB无线网卡，那么对应的驱动就应该自动加载，而不是由用户来手动加载。要做到这一点,就必须利用到一个工具-udev，在入式系统中通常使用 mdev，其功能比 udev 要弱很多，但也可以移植 udev 到嵌入式系统上。
        使用了 Linux 设备模型后，任何设备的添加、删除或状态修改都会导致内核向用户空间发送相应的事件，这个事件叫 uevent，和 kobiect 密切关联。这样用户空间就可以捕获这些事件来自动完成某些操作，如自动加载驱动、自动创建和删除设备节点、修改权限、创建软链接、修改网络设备的名字等。目前实现这个功能的工具就是 udev(或 mdev)这是一个用户空间的应用程序，捕获来自内核空间发来的事件，然后根据其规则文件进行操作。udev的规则文件为/etc/udev/rules.d 目录下后缀为.rules 的文件。
        udev 规则文件用#来注释，除此之外的就是一条一条的规则。每条规则至少包含一个键值对，键分为匹配和赋值两种类型。如果内核发来的事件匹配了规则中的所有匹配键的值，那么这条规则就可以得到应用，并且赋值键被赋予指定的值。一条规则包含了一个或多个键值对，这些键值对用逗号隔开，每个键由操作符规定一个操作，合法的操作符如下。
        ==和!=       :判等，用于匹配键。
        =、+=和:= : 赋值，用于赋值键，=和:=的区别是前者允许用新值来覆盖原来的值后者则不允许。+=则是追加赋值。
        常见的键如下。
        ACTION:事件动作的名字，如add 表示添加
        DEVPATH:事件设备的路径。
        KERNEL:事件设备的名字。
        NAME:节点或网络接口的名字
        SUBSYSTEM:事件设备子系统
        DRIVER:事件设备驱动的名字。
        ENV{key}:设备的属性。
        OWNER、GROUP、MODE:设备节点的权限。
        RUN:添加一个和设备相关的命令到一个命令列表中。
    
        IMPORT{type):导入一组设备属性的变量，依赖于类型 type。
    
        上面的键有的是匹配键，有的是赋值键，还有的既是匹配键又是赋值键。另外，还有很多其他的键，在此不一一罗列，详细信息请参见 udev 的 man 手册。


​        

 

        值还可以使用?、*和来[]进行通配，这和正则表达式中的含义是一样的。接下来来看一个例子。


        它表示当向 SCSI子系统添加任意设备后都要添加一个命令“/sbin/modprobe sg”到命令列表中，这个命令就是为相应的设备加载 sg 驱动模块。
        在 Ubuntu 中自动加载驱动的规则如下，请将这条规则添加到/etc/udev/rules.d/40-modprobe.rules 文件中，如果没有这个文件请新建一个。


        它表示根据模块的别名信息，用 modprobe 命令加载对应的内核模块。为此，我们要给平台驱动一个别名，如 pltdrv.c 文件中代码的第 49 行。pdev 要和驱动中用于匹配平台设备的名字保持一致。


        添加了这一条规则后，加载 pltdev 模块就可以自动加载平台 pltdrv 驱动
#IsmodI grep plt

# modprobe pltdev

#lsmod I grep plt
pltdrvpltdev

但是我的ubuntu的modprobe不能用，并且开发板还不支持udev所以后面再说。

六、使用平台设备的LED 驱动


        前面我们说过，之前的驱动最大的问题就是没有把设备和驱动分离开，这使得驱动的通用性很差。只要硬件有任何改动(比如换一个管脚，增加或删除 LED 灯)，都会导致驱动代码的修改。有了 Linux 设备模型以及平台总线后，我们可以把设备的信息用平台设备来实现，这就大大提高了驱动的通用性。接下来的任务就是把前面的 LED 驱动改造成基于平台总线的设备和驱动。首先是平台设备，代码如下


         由上可知，我们分别定义了 4 个平台设备，每一个平台设备代表一个LED 灯，之所以要这样做，是因为可以任意增加或删除一个 LED 灯。4 个平台设备都有一个IORESOURCE_MEM资源，用来描述2个寄存器所占用的内存空间;名字都为 fsled，用来和平台驱动匹配;id 分别为 2、3、4、5，用来区别不同的设备。还给每个平台设备的platform_data成员赋了值，platform_data 的类型是 void*，用来向驱动传递更多的信息，在这里传递的是每个LED 灯使用的管脚号，因为只有I/O内存是不能够控制一个具体的管脚的。这些平台设备放在 fsled_devices 数组中，在模块初始化函数中使用platform_add_devices 一次注册到平台总线上。在模块的清除函数中，则使用 platform_device_unregister 来注销。
        再来看看平台驱动。

fsled.c

fsled.h


        代码第 152 行至第 159 行定义了一个平台驱动 fsled_drv，名字叫 fsled，和平台设备匹配。代码第 161 行是平台驱动注册和注销的简化宏。
        在 fsled_probe 函数中，代码第 86 行首先通过 platform_data 取了管脚号。代码第88 行以平台设备中的 id 为次设备号。代码第 93 行动态分配了 struct fsled_dev 结构对象代码第 105行使用 platform_get_resource 获取了I/O内存的资源，这样要操作 GPIO管脚的两个信息就都获得了，一个是管脚号，一个是 I/O 内存地址。代码第 122 行使用platform set_drvdata 将动态分配得到的 fsled 保存到了平台设备中，便于之后的代码能从平台设备中获取 struct fsled_dev 结构对象的地址，是经常会使用到的一种技巧，也是个驱动支持多个设备的关键。
        函数 fsled_remove 中使用了 platform_get_drvdata 得到了对应的 struct fsled_dev 结构对象的地址，其他操作则是函数 fsled_probe 的反操作。
        函数fsled_open 也使用了 container_of宏得到了对应的struct fsled_dev 结构对象的地址，并保存在 filp->private_data 中，这也是我前面谈到的一个驱动支持多个设备的技巧。
        函数 fsled_ioctl 相比于以前则要简单一些，因为只控制一个对应的LED灯。
        测试的应用代码则是分别打开了 4个 LED 设备文件，然后再分别控制，代码比较简单，这里就不再赘述。测试方法和前面基本一致，只是要创建 4 个设备文件，用到 4个不同的次设备号 2、3、4、5。

七、自动创建设备节点


        前面谈到，内核中设备的添加、删除或修改都会向应用层发送热插拔事件，应用程序可以捕获这些事件来自动完成某些操作，如自动加载驱动、自动创建设备节点等。接下来以mdev为例，来说明如何自动创建设备节点。
        mdev 创建设备节点有两种方法，一种是运行 mdev -s 命令，一种是实时捕获热插拔事件。mdev-s 命令通常在根文件系统挂载完成后运行一次，它将递归扫描/sys/block 目录和/sys/class 目录下的文件，根据文件的内容来调用 make device 自动创建设备文件，这在busybox中的 mdev 源码中展现得非常清楚。


        另外一种情况则是当内核发生了热插拔事件后，mdev会自动被调用，这体现在根文件系统中的/etc/init.d/reS 初始化脚本文件中。


        内核有一种在发生热插拔事件后调用应用程序的方式，那就是执行/proc/sys/kernel/hotplug 文件中的程序，因为这种方式比较简单，所以常用在嵌入式系统之中。而之前说的udev 使用的则是 netlink 机制。发生热插拔事件时，调用 mdev 程序会将热插拔信息放在环境变量和参数当中，mdev 程序利用这些信息就可以自动创建设备节点，在 mdev 的源码中也有清晰的体现。


        上面的代码的总体思路是根据 ACTION 键的值来决定 op 是增加还是移除操作,最终调用 make_device 来自动创建或删除设备节点。
    
        了解了应用层自动创建设备节点的方式后，接下来就需要讨论在驱动中如何实现了.既然自动设备节点的创建要依靠热插拔事件和 sysfs 文件系统，那这和我们之前讨论的kobjet 就是分不开的，mdev 扫描/sys/class 目录暗示我们要创建类，并且在类下面应该有具体的设备。为此，内核提供了相应的 API。


        class_create: 创建类，owner 是所属的模块对象指针，name 是类的名字，返回 struct
class 对象指针，返回值通过IS_ERR 宏来判断是否失败,通过 PTR_ERR 宏来获得错误码。
        class_destroy:销毁cls 类。
        device_create:在类class 下创建设备，parent 是父设备，没有则为 NULL。devt 是设备的主次设备号，drvdata 是驱动数据，没有则为 NULL。fmt 是格式化字符串，使用方法类似于printk。
        device_destroy:销毁 class 类下面主次设备号为 devt 的设备。返回值的检查方式同class_create。
        添加了自动创建设备的驱动的主要代码如下

        代码第177行使用class_create 创建了名叫 fsled的类。代码第127行使用device_create在 fsled 类下面创建了 led%d 的设备，%d 用平台设备的id 来替代。在创建过程中，内核会发送热插拔事件给 mdev，mdev 利用这些信息就可以创建设备节点，因为设备的名字和设备号都传递给了 device_create，而内核又会利用这些参数生成热插拔信息。
    
        使用上面的驱动且驱动加载成功后，设备节点就自动被创建了，不需要再手动创建.整个测试过程和前面的例子类似，这里就不再重复了     

   







































































































































测试程序是个流水灯不多说了。

---------------------------------------------------------------------------------------------------------------------------------

        这周感觉更累了，已经没有太多的精力继续学习驱动了，但是周末我们软件部门聚餐时听着那些四五十的大佬说着人生经历讲着做人道理时我幡然醒悟。一时的强弱代表不了什么态度才是最重要的。只要你有终身学习的态度不会成为不了强者的，在公司做工作也是一种学习，即便有时做起来不是很愉快，但往往向着难受的方向学习，才能发展的更加全面。现在来公司已经三周了，我刚刚敢叫大家的名字，因为大家都是英文花名，我是农村的从小英语就不好，一直不敢张口叫大家的名字，只能尴尬的这个同学那个同学，后来发现没人在意你的，大概意思对就行了。
    
        以前在学校听说能画四层板的就能找到工作能画六层板就是大佬，偶然和硬件部的大佬交流了一下，喵的我们公司底板28层，我丢啊，玩个锤子。晚上吃饭的时候，听着大家都是各大名牌大学的研究生。其中不乏浙大这种顶尖学府的人才。顿时一个二本还没毕业的大三学生的我自卑感油然而生。突然萌生了考研的念头。可是真的很讨厌英语。如果以后有机会一定要试试另一种方式读研。去国外读研只需要一封介绍信。但是需要你是某个领域的顶尖人才。我们公司有个华三挖来的大佬。什么都会，整个FPGA都是他做的，这么多年问题不超过7个，或许大家绝对7个很多，但是真正工作时你就知道这个含金量了，我们软件的问题单貌似有70多个还是10多个人哦。重要的是他还精通python、通信、uboot。其它的我就不了解了，一个人可以全方位都牛，成为一个架构师我想这是每个专心搞技术的人的最高成就了吧。
    
        我们组有个很阳光的大哥，人巨好，我们老大太严厉了有时我都不敢问，但是这个邻家哥哥一样的同事每次问他东西都给我耐心解决。这周刚好赶上版本验证，第一次经历这种大规模代码发布新版本前的验证工作。挺有意思的，因为我是实习生可能活少吧，大半天就完事了，他们几个忙的都见不到人了，过了巨无聊的一天，第二天他们还在验证，我就自己去解决一些新的问题单。其实看着那些署了自己名字的代码进入公司的版本成为其中的一部分，还是很有成就感的，以后可以吹牛说你用的手机芯片是我写的程序验证出来的啦哈哈。我的老大之前有点不理解他，后来吃饭才知道他原来已经结婚了，怪不得赚那么多，还每天那么节俭，在领导面前被迫改变自己的性格。结婚后要学会的第一件事或许就是责任吧。
    
        我还发现了一种名叫领导力和人格魅力的东西。曾经在学校时我在一个大我两届的学长身上见到过。如今在这家公司我又见到了。一个长者，大概是公司的二号人物。真的很有人格魅力。有种即便做错了也想跟着他的感觉。
    
        吃完饭去唱歌时玩游戏输了，不得不喝了两口酒，我根本就不能喝酒，吃饭时领导敬酒我都是喝水的，有点不好意思哈哈。但是没办法输了就要接受惩罚。有个也是东北的姐姐问到我为什么会来杭州。我楞了一下，回了两个字，舔狗。是啊，北京一个月实习期能拿一万多的不去，深圳一个月5000供吃住，常州4500管住都没去，来了杭州一个月也就4000块还不管吃住。最后呢，人家还不是很愿意搭理你，不是舔狗又是什么呢。
    
        她并不是很惊艳的那种美丽，也没有很好的身材。但是就有一种奇特的魔力吸引我，或许是种别样的人格魅力吧。智慧型吸引？又或许是因为曾在我最需要帮助时帮了我。呼，累。但是说出来舒服了很多。喵的在CSDN写日常不会被和谐吧哈哈。后面技术更扎实了解决问题速度提高后就开始写写小说，现在已经看完两千多本了，感觉能看下去的很少了，所以以后自己写哈哈。就到这里咯，以后尽量保证每周更新一篇博客，学习些新东西，顺便记录一下一周的故事，就当是日记了。以后也有可以翻一翻的东西。
————————————————
版权声明：本文为CSDN博主「宇努力学习」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_52479948/article/details/131949898

## 2. Linux 内核模块的加载卸载

insmod

rmmod

modper

depmod







## 3. Linux 字符设备驱动模板

一、字符设备驱动简介

        字符设备是 Linux 驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、 IIC、 SPI，LCD 等等都是字符设备，这些设备的驱动就叫做字符设备驱动。
    
        在详细的学习字符设备驱动架构之前，我们先来简单的了解一下 Linux 下的应用程序是如何调用驱动程序的， Linux 应用程序对驱动程序的调用流程如下图所示：
    
        在 Linux 中一切皆为文件，驱动加载成功以后会在“/dev”目录下生成一个相应的文件，应用程序通过对这个名为“/dev/xxx” (xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。
    
        比如现在有个叫做/dev/led 的驱动文件，此文件是 led 灯的驱动文件。应用程序使用 open 函数来打开文件/dev/led，使用完成以后使用 close 函数关闭/dev/led 这个文件。 open和 close 就是打开和关闭 led 驱动的函数，如果要点亮或关闭 led，那么就使用 write 函数来操作，也就是向此驱动写入数据，这个数据就是要关闭还是要打开 led 的控制参数。如果要获取led 灯的状态，就用 read 函数从驱动中读取相应的状态。
    
        应用程序运行在用户空间，而 Linux 驱动属于内核的一部分，因此驱动运行于内核空间。当我们在用户空间想要实现对内核的操作，比如使用 open 函数打开/dev/led 这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入” 到内核空间，这样才能实现对底层驱动的操作。
    
        open、 close、 write 和 read 等这些函数是由 C 库提供的，在 Linux 系统中，系统调用作为 C 库的一部分。当我们调用 open 函数的时候流程如下图所示：
    
        其中关于 C 库以及如何通过系统调用“陷入” 到内核空间这个我们不用去管，我们重点关注的是应用程序和具体的驱动，应用程序使用到的函数在具体驱动程序中都有与之对应的函数，比如应用程序中调用了 open 这个函数，那么在驱动程序中也得有一个名为 open 的函数。每一个系统调用，在驱动中都有与之对应的一个驱动函数，在 Linux 内核文件 include/linux/fs.h 中有个叫做 file_operations 的结构体，此结构体就是 Linux 内核驱动操作函数集合，内容如下所示：
    
    /* file_operations 结构体 */
    struct file_operations {
        struct module *owner;
        loff_t (*llseek) (struct file *, loff_t, int);
        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
        ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
        ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
        int (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *,
                unsigned int flags);
        int (*iterate) (struct file *, struct dir_context *);
        int (*iterate_shared) (struct file *, struct dir_context *);
        __poll_t (*poll) (struct file *, struct poll_table_struct *);
        long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
        long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
        int (*mmap) (struct file *, struct vm_area_struct *);
        unsigned long mmap_supported_flags;
        int (*open) (struct inode *, struct file *);
        int (*flush) (struct file *, fl_owner_t id);
        int (*release) (struct inode *, struct file *);
        int (*fsync) (struct file *, loff_t, loff_t, int datasync);
        int (*fasync) (int, struct file *, int);
        int (*lock) (struct file *, int, struct file_lock *);
        ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
        unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
        int (*check_flags)(int);
        int (*flock) (struct file *, int, struct file_lock *);
        ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
        ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
        int (*setlease)(struct file *, long, struct file_lock **, void **);
        long (*fallocate)(struct file *file, int mode, loff_t offset,
                  loff_t len);
        void (*show_fdinfo)(struct seq_file *m, struct file *f);
    #ifndef CONFIG_MMU
        unsigned (*mmap_capabilities)(struct file *);
    #endif
        ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
                loff_t, size_t, unsigned int);
        loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
                       struct file *file_out, loff_t pos_out,
                       loff_t len, unsigned int remap_flags);
        int (*fadvise)(struct file *, loff_t, loff_t, int);
        int (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags);
        int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *,
                    unsigned int poll_flags);
    }
    
        在字符设备驱动开发中最常用的就是上面这些函数，关于其他的函数大家可以查阅相关文档。我们在字符设备驱动开发中最主要的工作就是实现上面这些函数，不一定全部都要实现，但是像 open、 release、 write、 read 等都是需要实现的，当然了，具体需要实现哪些函数还是要看具体的驱动要求。
二、字符设备驱动开发步骤

下面是开发字符设备驱动的基本步骤：
1.确定设备号

    如果使用静态分配设备号，可以在代码中指定一个固定的设备号。
    
    如果使用动态分配设备号，可以调用 'alloc_chrdev_region' 函数在模块初始化时分配设备号。
    
    如果使用 'udev' 等工具进行设备号的动态分配和管理，则需要在驱动程序中声明一个 'dev_t' 类型的变量，并使用 'MKDEV' 宏将主设备号和次设备号合并为一个设备号。

2.定义 file_operations 结构体

    创建一个结构体，用于定义字符设备驱动程序对外提供的操作接口。常见的函数包括 'open'、'release'、'read'、'write'、'ioctl' 等。
    
    在驱动程序的初始化函数中，将这些操作函数与对应的函数指针关联起来。

3.实现操作函数

    实现字符设备驱动中定义的操作函数，根据设备的需求来进行相应的操作。
    
    在 'open' 函数中可以进行设备的初始化工作，例如分配内存、初始化设备状态等。
    
    在 'release' 函数中可以进行设备的清理工作，例如释放内存、关闭设备等。
    
    在 'read' 函数中可以从设备读取数据，并将数据传递给用户空间。
    
    在 'write' 函数中可以接收用户空间传递的数据，并将数据写入设备。
    
    在 'ioctl' 函数中可以处理设备的特殊控制命令。

4.注册和注销字符设备

    在驱动程序的初始化函数中，调用 'alloc_chrdev_region' 函数分配设备号。
    
    使用 'cdev_init' 初始化 'cdev' 结构体，并将 file_operations 结构体指针赋值给 'cdev' 的成员。
    
    使用 'cdev_add' 将设备添加到内核中，使其可用。
    
    在驱动程序的退出函数中，使用 'cdev_del' 和 'unregister_chrdev_region' 函数注销设备。

5.编译和加载模块

    将驱动程序的源代码编译为内核模块，生成对应的 .ko 文件。
    
    使用 'insmod' 命令加载模块到内核中。

6.用户空间交互：

    用户程序可以通过系统调用来访问字符设备，例如使用 'open'、'read'、'write'、'ioctl' 等函数来打开、读取和写入设备。
    
    用户程序可以使用文件描述符来标识打开的设备，通过文件描述符进行读写操作。
    
        以上是字符设备驱动开发的基本步骤。在实际开发中，还需要进行错误处理、设备管理、内存分配和释放等工作，具体的实现细节会根据设备的特性和需求而有所不同。为了开发出高质量的驱动程序，建议仔细阅读相关的文档、示例代码和最佳实践，并进行充分的测试和验证。
三、字符设备驱动示例模板

        字符驱动框架是一种在Linux内核中实现设备驱动程序的方法。它允许开发者编写基于字符设备的驱动程序，以便与用户空间中的字符设备进行通信。下面是一个简单的字符驱动框架模板，包括了必要的函数和数据结构。
    
    #include <linux/module.h>
    #include <linux/fs.h>
    #include <linux/cdev.h>
    #include <linux/uaccess.h>
     
    #define DEVICE_NAME "mydevice"
    #define BUF_SIZE 1024
     
    static dev_t dev;
    static struct cdev cdev;
    static char buffer[BUF_SIZE];
    static int buffer_len = 0;
     
    static int device_open(struct inode *inode, struct file *filp)
    {
        // 设备打开时的操作
        return 0;
    }
     
    static int device_release(struct inode *inode, struct file *filp)
    {
        // 设备关闭时的操作
        return 0;
    }
     
    static ssize_t device_read(struct file *filp, char *user_buf, size_t count, loff_t *f_pos)
    {
        // 从设备读取数据
        size_t to_copy = min(count, (size_t)buffer_len);
        if (copy_to_user(user_buf, buffer, to_copy) != 0)
            return -EFAULT;
     
        return to_copy;
    }
     
    static ssize_t device_write(struct file *filp, const char *user_buf, size_t count, loff_t *f_pos)
    {
        // 向设备写入数据
        size_t to_copy = min(count, (size_t)BUF_SIZE);
        if (copy_from_user(buffer, user_buf, to_copy) != 0)
            return -EFAULT;
     
        buffer_len = to_copy;
        return to_copy;
    }
     
    static struct file_operations fops = {
        .owner = THIS_MODULE,
        .open = device_open,
        .release = device_release,
        .read = device_read,
        .write = device_write,
    };
     
    static int __init chardev_init(void)
    {
        // 模块初始化函数
        if (alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME) < 0)
        {
            printk(KERN_ALERT "Failed to allocate character device region\n");
            return -1;
        }
     
        cdev_init(&cdev, &fops);
        if (cdev_add(&cdev, dev, 1) < 0)
        {
            unregister_chrdev_region(dev, 1);
            printk(KERN_ALERT "Failed to add character device\n");
            return -1;
        }
     
        printk(KERN_INFO "Character device registered: %s\n", DEVICE_NAME);
        return 0;
    }
     
    static void __exit chardev_exit(void)
    {
        // 模块退出函数
        cdev_del(&cdev);
        unregister_chrdev_region(dev, 1);
        printk(KERN_INFO "Character device unregistered\n");
    }
     
    module_init(chardev_init);
    module_exit(chardev_exit);
     
    MODULE_LICENSE("GPL");
    MODULE_AUTHOR("Your Name");
    MODULE_DESCRIPTION("Character Device Driver");
    
        这个模板定义了一个名为 'mydevice' 的字符设备驱动。驱动程序会将用户空间的数据写入到 'buffer' 中，并从 'buffer' 中读取数据返回给用户空间。其中，'device_open' 和 'device_release' 函数在设备打开和关闭时被调用，'device_read' 和 'device_write' 函数用于读取和写入设备数据。
    
        该模板使用 'alloc_chrdev_region' 函数为字符设备分配主次设备号，并使用 'cdev_init' 和 'cdev_add' 函数将设备添加到系统中。在模块退出时，使用 'cdev_del' 和 'unregister_chrdev_region' 函数来注销设备。
    
        请注意，这只是一个简单的字符驱动框架模板，仅用于演示目的。实际的字符驱动可能需要更多的功能和错误处理。在开发字符驱动程序时，请仔细参考Linux内核文档和示例代码，以确保正确性和稳定性。
四、字符设备驱动开发总结

        字符驱动是一种在操作系统内核中实现的设备驱动程序，用于与字符设备进行交互。字符设备是一种以字节为单位进行输入和输出的设备，例如终端、串口、打印机等。字符驱动框架提供了一组函数和数据结构，使得开发者可以编写自定义的字符设备驱动程序。

在Linux内核中，字符驱动的实现基于以下几个核心组件：

1.设备号：每个字符设备驱动在注册时都会被分配一个唯一的设备号。设备号包括主设备号和次设备号。主设备号标识设备驱动程序，次设备号标识具体的设备实例。

2.file_operations 结构体：这是一个函数指针结构体，定义了设备驱动程序对外提供的操作接口。常见的函数包括 'open'、'release'、'read'、'write'、'ioctl' 等。开发者需要实现这些函数来处理设备的打开、关闭、读取和写入等操作。

3.cdev 结构体：'cdev' 是字符设备驱动的核心结构体，它代表一个字符设备实例。它包含了对应的 file_operations 结构体指针以及设备号等信息。通过使用 'cdev' 结构体，开发者可以注册和管理字符设备。

4.字符设备注册和注销：在字符驱动的初始化阶段，需要使用 'alloc_chrdev_region' 函数为驱动程序分配设备号。然后使用 'cdev_init' 初始化 'cdev' 结构体，并使用 'cdev_add' 将设备添加到系统中。在驱动程序退出时，需要使用 'cdev_del' 和 'unregister_chrdev_region' 函数来注销设备。

5.用户空间交互：字符驱动允许用户空间程序通过系统调用来访问设备。用户程序可以打开设备、读取和写入设备数据，并通过 'ioctl' 等方式发送控制命令。
————————————————
版权声明：本文为CSDN博主「Sunshine-Linux」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Wang_XB_3434/article/details/131739858

## 4. Linux 驱动中的信号量与自旋锁

文章目录

    并发解决方法二（自旋锁）
    spin_lock
    spin_lock的变体
    自旋锁的使用
    读写自旋锁

设计自旋锁的最初目的是在多处理器系统中提供对共享数据的保护，其背后的核心思想是：设置一个在多处理器之间共享的全局变量锁v,并定义当V=I时为上锁状态，V=0为解锁状态·如果处理器A上的代码要进入临界区．它要先读取V的值，判断其是否为0，如果V不等于0表明有其他处理器上的代码正在对共享数据进行访问，此时处理器A进入忙等待即自旋状态，如果V=O表明当前没有其他处理器上的代码进入临界区，此时处理器A可以访问该资源，它先把V置1（自旋锁的上锁状态).然后进入临界区，访问完毕离开临界区时将V置0（自旋锁的解锁状态）。

上述自旋锁的设计思想在用具体代码实现时的关键之处在于，必须确保处理器A“读取v，判断v的值与更新”这一操作序列是个原子操作(atomic operation)•所谓原子操作，简单地说就是执行这个操作的指令序列在处理器上执行时等同于单条指令，也即该指令序列在执行时是不可分割的。
spin_lock

不同的处理器上有不同的指令用以实现上述的原子操作，所以spin_lock的相关代码在不同体系架构上有不同的实现，为了帮助读者对spin_lock这一机制建立具体的印象·下面以ARM处理器上的实现为例，仔细考察spin_lock的幕后行为·下面的讨论先以多处理器为主·然后再讨论spin_lock及其变体在单处理器上的演进。

在给出实际源码细节之前，先做个简短的说明，为了让读者更清楚地理解这里的代码，下面会对代码进行轻微调整，使之外在的表现形式更加紧凑而又不影响其内涵，同时也不会关注一些调试相关的数据成员，所以在摘录的代码中己将其移除。

下面是Linux源码中提供给设备驱动程序等内核模块使用的spin_lock接口函数的定义：

static inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&lock->rlock);
}

    1
    2
    3
    4

代码中的数据结构spinlock_t，就是前面提到的在多处理器之间共享的自旋锁在现实源码中的具体表现，透过层层的定义，会发现实际上它就是个volatile unsigned int型变量：

typedef struct spinlock {
	union {
		struct raw_spinlock rlock;

#ifdef CONFIG_DEBUG_LOCK_ALLOC
# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))
		struct {
			u8 __padding[LOCK_PADSIZE];
			struct lockdep_map dep_map;
		};
#endif
	};
} spinlock_t;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13

typedef struct raw_spinlock {
	arch_spinlock_t raw_lock;
#ifdef CONFIG_GENERIC_LOCKBREAK
	unsigned int break_lock;
#endif
#ifdef CONFIG_DEBUG_SPINLOCK
	unsigned int magic, owner_cpu;
	void *owner;
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	struct lockdep_map dep_map;
#endif
} raw_spinlock_t;

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13

typedef struct {
	volatile unsigned int slock;
} arch_spinlock_t;

    1
    2
    3

spin_lock函数中调用的raw_spin_lock是个宏·其实现是处理器相关的，对于ARM处理器而言，最终展开为

static inline void __raw_spin_lock(raw_spinlock_t *lock)
{
	preempt_disable();
	spin_acquire(&lock->dep_map, 0, 0, _RET_IP_);
	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);
}

    1
    2
    3
    4
    5
    6

函数首先调用preempt_disable宏，后者在定义了CONFIG_PREEMPT,也即在支持内核可抢占的调度系统中时，将关闭调度器的可抢占特性。在没有定义CONFIG_PREEMPT时，preempt_disable是个空定义，什么也不做。

真正的上锁操作发生在后面的do_raw_spin_lock函数中，不过在讨论该函数的实现细节前，先来看看为什么raw_spin_lock要先调用preempt_disable来关闭系统的可抢占性·在一个打开了CONFIG_PREEMPI•特性的Linux系统中，一个在内核态执行的路径也有可能被切换出处理器，典型地，比如当前进程正在内核态执行某一系统调用时，发生了一个外部中断·当中断处理函数返回时，因为内核的可抢占性，此时将会出现一个调度点，如果CPU的运行队列中出现了一个比当前被中断进程优先级更高的进程，那么被中断的进程将会被换出处理器，即便此时它正运行在内核态·单处理器上的这种因为内核的可抢占性所导致的两个不同进程并发执行的情形，非常类似于SMP系统上运行在不同处理器上的进程之间的并发，因此为了保护共享的资源不会受到破坏·必須在进入临界区前关闭内核的可抢占性·因为Linux内核源码试图统一自旋锁的接口代码，即不论是单处理器还是多处理器，不论内核是否配置了可抢占特性，提供给外部模块使用的相关自旋锁代码都只有一份，所以可以看到在上述的raw_spin_lock函数中加入了内核可抢占性相关的代码，即便是在没有配置内核可抢占的系统上．外部模块也都统一使用相同的spin_lock和spin_unlock接口函数。

函数接着调用do_raw_spin_lock开始真正的上锁操作

void do_raw_spin_lock(raw_spinlock_t *lock)
{
	debug_spin_lock_before(lock);
	if (unlikely(!arch_spin_trylock(&lock->raw_lock)))
		__spin_lock_debug(lock);
	debug_spin_lock_after(lock);
}

    1
    2
    3
    4
    5
    6
    7

与spin_lock相对的是spin_unlock，这是一个应该在离开临界区时调用的函数，用来释放此前获得的自旋锁·其外部接口定义如下

static inline void spin_unlock(spinlock_t *lock)
{
	raw_spin_unlock(&lock->rlock);
}

    1
    2
    3
    4
    5

最终调用

#define __UNLOCK(lock) \
  do { preempt_enable(); ___UNLOCK(lock); } while (0)

    1
    2

函数先调用面raw_spin_unlock做实际的解锁操作，然后调用preempt_enable函数打开内核可抢占性，对于没有定义CONFIG_PREEMPT的系统，该宏是个空定义·do_raw_spin_unlock函数在ARM处理器上的代码如下：

void do_raw_spin_unlock(raw_spinlock_t *lock)
{
	debug_spin_unlock(lock);
	arch_spin_unlock(&lock->raw_lock);
}

    1
    2
    3
    4
    5
    6

解锁操作比获得锁的操作要相对简单，只需史新锁变量为0即可，在ARM平台上利用单条指令嘶就可以完成该任务，所以代码非常简单，熹接用指令将自旋锁的状态更新为0，即解锁状态·针对spin_lock应该调用spin_unlock而不是其他形式的释放锁函数，驱动程序员必须确保这种获得锁和释放锁函数调用的一致性．
spin_lock的变体

在前面讨论spin_lock函数时，spin_lock对多处理器系统中这种进程间真正的并发执行引起的竞态问題解决得很好，但是考虑图1所示这样一个场景：
在这里插入图片描述
处理器上的当前进程A因为要对某一全局性的链表g-list进行操作，所以在操作前通过调用spin_lock来进入临界区（图中标号1所示),当它正处于临界区中时，进程A所在的处理器上发生了一个外部硬件中断，此时系统必须暫停当前进程A的执行转而去处理该中断（图中标号2所示假设该中断的处理例程中恰好也要操作g-list.因为这是一个共享的全局变量，所以在操作之前也要调用spinlock函数来对该共享变量进行保护（图中标号3所示），当中断处理例程中的spin-lock试图去获得自旋锁slock时，因为被它中断的进程A之前己经获得该锁，于是将导致中断处理例程进入自旋状态。**在中断处理例捍中出现一个自旋状态是非常致命的，因为中断处例程必须在尽可能短的时间内返回，而此时它却必须自旋。此时被它中断的进程A因中断处理函数不能返回而无行，也就不可能释放锁，所以将导致中断处理例程中的spin_lock一直下去，导致死锁。**出现这种特定情况的本质原因在于对锁的竞争发生在不能真正并发执行的两条路径上，如果可以并发执行，那么在上面的案例中，被中断的进程依然可以继续执行继而释放锁·对这种问题的解决导致了spin_lock函数其他变体的出现。

因处理外部的中断而引发spin_lock缺陷的例子，使得必须在这种情况下对spin_lock予以修正，于是出现了spin_lock_irq和spin_lock_irq_save函数·spin_lock_irq函数接口定义如下：

static inline void spin_lock_irq(spinlock_t *lock)
{
	raw_spin_lock_irq(&lock->rlock);
}

    1
    2
    3
    4

最终调用

#define __LOCK_IRQ(lock) \
  do { local_irq_disable(); __LOCK(lock); } while (0)

    1
    2

其中的raw_spin_lock_irq函数的实现，相对于raw_spin_lock只是在调用preempt_disable之前又调用了local_irq_disable,后者在本章前面部分己经讨论过，用来关闭本地处理器响应外部中断的能力，这样在获取一个锁时就可以确保不会发生中断，从而避免上面提到的死锁问題。local_irq_disable只能用来关闭本地处理器的中断，当一个通过调用spin_lock_irq拥有自旋锁V的进程在处理器A上执行时，虽然在处理器A上中断被关闭了，但是外部中断依然有机会发送到处理器B上，如果处理器B上的中断处理函数也试图去获得锁v,情况会怎样呢？因为此时处理器A上的进程可以继续执行，在它离开临界区时将释放锁，这样处理器B上的中断处理函数就可以结束此前的自旋状态·这从一个侧面说明通过自旋锁进入的临界区代码必须在尽可能短的时间内执行完毕，因为它执行的时间越长·别的处理器就越需要自旋以等待史长的时间（尤其是这种自旋发生在中断处理函数中).最糟糕的情况是进程在临界区中因为某种原因被换出处理器·所以作为使用自旋锁时一条确定的规则，任何拥有自旋锁的代码都必须是原子的，不能休眠。在实际的使用中，这条规则实践起来还远不像规则描述的那样直白，调用者需要仔细审视在拥有锁时的每个函数调用，因为睡眠有可能发生在这函数的内部，比如以GFP_KERNEL作为分配掩码通过kmalloc函数来分配一块内存时．系统中仝闲的内存不足以满足本次分配的情形虽然非常少见，但是毕竟存在这种可能性，一旦这种可能性被确定，kmalloc会阻塞从而会被切换出处理器，如果kmalloc的调用者在此之前拥有某个自旋锁·那么这种情形下将对系统的稳定性造成极大的威胁。

如此，当知道一个自旋锁在中断处理的上下文中有可能会被使用到时·应该使用
spin_lock_irq函数，而不是spin_lock•后者只有在能确定中断上下文中不会使用到自旋锁
的情形下才能使用。spin_lock_irq对应的释放锁函数为spin_unlock_irq，其接口定义为

static inline void spin_unlock_irq(spinlock_t *lock)
{
	raw_spin_unlock_irq(&lock->rlock);
}

    1
    2
    3
    4
    5

#define __UNLOCK_IRQ(lock) \
  do { local_irq_enable(); __UNLOCK(lock); } while (0)

    1
    2

可见，在raw_spin_unlock_irq函数中除了调用__UNLOCK做实际的解锁操作外，还会打开本地处理器上的中断，以及开启内核的可抢占性。

与spin_lock_irq类似的还有一个spin_lock_save宏，它与spin_lock_irq函数最大的区别
是，在关闭中断前会将处理器当前的FLAGS寄存器的值保存在一个变量中，当调用对应
的spin_unlock_trqrestore来释放锁时·会将spin_lock_irq_save中保存的FLAGS值重新写回
到寄存器中·对于spin_lock_irq_save和spin_unlock_irq_restore的使用场合，可参考前面关于local_irq_save和local_irq_estore的讨论。
自旋锁的使用

自旋锁（Spin Lock） 是一种典型的对临界资源进行互斥访问的手段， 其名称来源于它的工作方式。为了获得一个自旋锁， 在某CPU上运行的代码需先执行一个原子操作， 该操作测试并设置（Test-AndSet） 某个内存变量。 由于它是原子操作， 所以在该操作完成之前其他执行单元不可能访问这个内存变量。 如果测试结果表明锁已经空闲， 则程序获得这个自旋锁并继续执行； 如果测试结果表明锁仍被占用，程序将在一个小的循环内重复这个“测试并设置”操作， 即进行所谓的“自旋”， 通俗地说就是“在原地打转”， 如图7.7所示。 当自旋锁的持有者通过重置该变量释放这个自旋锁后， 某个等待的“测试并设置”操作
向其调用者报告锁已释放。
在这里插入图片描述

理解自旋锁最简单的方法是把它作为一个变量看待， 该变量把一个临界区标记为“我当前在运行， 请稍等一会”或者标记为“我当前不在运行， 可以被使用”。 如果A执行单元首先进入例程， 它将持有自旋锁；当B执行单元试图进入同一个例程时， 将获知自旋锁已被持有， 需等到A执行单元释放后才能进入。

在ARM体系结构下， 自旋锁的实现借用了ldrex指令、 strex指令、 ARM处理器内存屏障指令dmb和dsb、 wfe指令和sev指令， 这类似于代码清单7.1的逻辑。 可以说既要保证排他性， 也要处理好内存屏障。

Linux中与自旋锁相关的操作主要有以下4种。

    定义自旋锁

spinlock_t lock;

    1
    
    初始化自旋锁

spin_lock_init(lock);

    1

该宏用于动态初始化自旋锁lock。

    获得自旋锁

spin_lock(lock);

    1

该宏用于获得自旋锁lock， 如果能够立即获得锁， 它就马上返回， 否则， 它将在那里自旋， 直到该自旋锁的保持者释放。

spin_trylock(lock);

    1

该宏尝试获得自旋锁lock， 如果能立即获得锁， 它获得锁并返回true， 否则立即返回false， 实际上不再“在原地打转”。

    释放自旋锁

spin_unlock(lock);

    1

该宏释放自旋锁lock， 它与spin_trylock或spin_lock配对使用。

自旋锁一般这样写

/* 定义一个自旋锁*/
spinlock_t lock;
spin_lock_init(&lock);
spin_lock (&lock) ; /* 获取自旋锁， 保护临界区 */
. . ./* 临界区*/
spin_unlock (&lock) ;

    1
    2
    3
    4
    5
    6

自旋锁主要针对SMP或单CPU但内核可抢占的情况， 对于单CPU和内核不支持抢占的系统， 自旋锁退化为空操作。 在单CPU和内核可抢占的系统中， 自旋锁持有期间中内核的抢占将被禁止。 由于内核可抢占的单CPU系统的行为实际上很类似于SMP系统， 因此， 在这样的单CPU系统中使用自旋锁仍十分必要。 另外， 在多核SMP的情况下， 任何一个核拿到了自旋锁， 该核上的抢占调度也暂时禁止了， 但是没有禁止另外一个核的抢占调度。

尽管用了自旋锁可以保证临界区不受别的CPU和本CPU内的抢占进程打扰， 但是得到锁的代码路径在执行临界区的时候， 还可能受到中断和底半部（BH， 稍后的章节会介绍） 的影响。 为了防止这种影响，就需要用到自旋锁的衍生。 spin_lock（） /spin_unlock（） 是自旋锁机制的基础， 它们和关中断local_irq_disable（） /开中断local_irq_enable（） 、 关底半部local_bh_disable（） /开底半部local_bh_enable（） 、 关中断并保存状态字local_irq_save（） /开中断并恢复状态字local_irq_restore（） 结合就形成了整套自旋锁机制， 关系如下

spin_lock_irq() = spin_lock() + local_irq_disable()
spin_unlock_irq() = spin_unlock() + local_irq_enable()
spin_lock_irqsave() = spin_lock() + local_irq_save()
spin_unlock_irqrestore() = spin_unlock() + local_irq_restore()
spin_lock_bh() = spin_lock() + local_bh_disable()spin_unlock_bh() = spin_unlock() + local_bh_enable()

    1
    2
    3
    4
    5

spin_lock_irq（ ） 、 spin_lock_irqsave（ ） 、 spin_lock_bh（ ） 类似函数会为自旋锁的使用系好“安全带”以避免突如其来的中断驶入对系统造成的伤害。

在多核编程的时候， 如果进程和中断可能访问同一片临界资源， 我们一般需要在进程上下文中调用spin_lock_irqsave（ ） /spin_unlock_irqrestore（ ） ， 在中断上下文中调用spin_lock（ ） /spin_unlock（ ） ， 如图7.8所示。 这样， 在CPU0上， 无论是进程上下文， 还是中断上下文获得了自旋锁， 此后， 如果CPU1无论是进程上下文， 还是中断上下文， 想获得同一自旋锁， 都必须忙等待， 这避免一切核间并发的可能性。同时， 由于每个核的进程上下文持有锁的时候用的是spin_lock_irqsave（ ） ， 所以该核上的中断是不可能进入的， 这避免了核内并发的可能性。

驱动工程师应谨慎使用自旋锁， 而且在使用中还要特别注意如下几个问题。

1） 自旋锁实际上是忙等锁， 当锁不可用时， CPU一直循环执行“测试并设置”该锁直到可用而取得该锁， CPU在等待自旋锁时不做任何有用的工作， 仅仅是等待。 因此， 只有在占用锁的时间极短的情况下，使用自旋锁才是合理的。 当临界区很大， 或有共享设备的时候， 需要较长时间占用锁， 使用自旋锁会降低系统的性能。

2） 自旋锁可能导致系统死锁。 引发这个问题最常见的情况是递归使用一个自旋锁， 即如果一个已经拥有某个自旋锁的CPU想第二次获得这个自旋锁， 则该CPU将死锁。图7.8 自
在这里插入图片描述

3） 在自旋锁锁定期间不能调用可能引起进程调度的函数。 如果进程获得自旋锁之后再阻塞， 如调用copy_from_user（ ） 、 copy_to_user（ ） 、 kmalloc（ ） 和msleep（ ） 等函数， 则可能导致内核的崩溃。

4） 在单核情况下编程的时候， 也应该认为自己的CPU是多核的， 驱动特别强调跨平台的概念。 比如， 在单CPU的情况下， 若中断和进程可能访问同一临界区， 进程里调用spin_lock_irqsave（ ） 是安全的， 在中断里其实不调用spin_lock（ ） 也没有问题， 因为spin_lock_irqsave（ ） 可以保证这个CPU的中断服务程序不可能执行。 但是， 若CPU变成多核， spin_lock_irqsave（） 不能屏蔽另外一个核的中断， 所以另外一个核就可能造成并发问题。 因此， 无论如何， 我们在中断服务程序里也应该调用spin_lock（） 。

使用自旋锁使设备只能被一个进程打开
读写自旋锁

自旋锁不关心锁定的临界区究竟在进行什么操作， 不管是读还是写， 它都一视同仁。 即便多个执行单元同时读取临界资源也会被锁住。 实际上， 对共享资源并发访问时， 多个执行单元同时读取它是不会有问题的， 自旋锁的衍生锁读写自旋锁（rwlock） 可允许读的并发。 读写自旋锁是一种比自旋锁粒度更小的锁机制， 它保留了“自旋”的概念， 但是在写操作方面， 只能最多有1个写进程， 在读操作方面， 同时可以有多个读执行单元。 当然， 读和写也不能同时进行。

    定义和初始化读写自旋锁

rwlock_t my_rwlock;
rwlock_init(&my_rwlock); /* 动态初始化 */

    1
    2
    
    读锁定

void read_lock(rwlock_t *lock);
void read_lock_irqsave(rwlock_t *lock, unsigned long flags);
void read_lock_irq(rwlock_t *lock);
void read_lock_bh(rwlock_t *lock);

    1
    2
    3
    4
    
    读解锁

void read_unlock(rwlock_t *lock);
void read_unlock_irqrestore(rwlock_t *lock, unsigned long flags);
void read_unlock_irq(rwlock_t *lock);
void read_unlock_bh(rwlock_t *lock);

    1
    2
    3
    4

在对共享资源进行读取之前， 应该先调用读锁定函数， 完成之后应调用读解锁函数。

read_lock_irqsave（） 、 read_lock_irq（） 和read_lock_bh（） 也分别是read_lock（） 分别与local_irq_save（） 、 local_irq_disable（） 和local_bh_disable（） 的组合， 读解锁函数read_unlock_irqrestore（） 、 read_unlock_irq（） 、 read_unlock_bh（） 的情况与此类似

    写锁定

void write_lock(rwlock_t *lock);
void write_lock_irqsave(rwlock_t *lock, unsigned long flags);
void write_lock_irq(rwlock_t *lock);
void write_lock_bh(rwlock_t *lock);
int write_trylock(rwlock_t *lock);

    1
    2
    3
    4
    5
    
    写解锁

void write_unlock(rwlock_t *lock);
void write_unlock_irqrestore(rwlock_t *lock, unsigned long flags);void write_unlock_irq(rwlock_t *lock);
void write_unlock_bh(rwlock_t *lock);

    1
    2
    3

write_lock_irqsave（ ） 、 write_lock_irq（ ） 、 write_lock_bh（ ） 分别是write_lock（ ） 与local_irq_save（ ） 、 local_irq_disable（ ） 和local_bh_disable（ ） 的组合， 写解锁函数write_unlock_irqrestore（ ） 、 write_unlock_irq（ ） 、 write_unlock_bh（ ） 的情况与此类似。

在对共享资源进行写之前， 应该先调用写锁定函数， 完成之后应调用写解锁函数。 和spin_trylock（ ）一样， write_trylock（ ） 也只是尝试获取读写自旋锁， 不管成功失败， 都会立即返回。

读写自旋锁一般这样被使用

rwlock_t lock; /* 定义rwlock */
rwlock_init(&lock); /* 初始化rwlock */
/* 读时获取锁*/
read_lock(&lock);
... /* 临界资源 */
read_unlock(&lock);
/* 写时获取锁*/
write_lock_irqsave(&lock, flags);
... /* 临界资源 */
write_unlock_irqrestore(&lock, flags);

————————————————
版权声明：本文为CSDN博主「Paranoid-up」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_52849254/article/details/128935253

## 5. Linux 驱动中断的常用函数及作用

中断函数
中断号

中断号用来区分不同的中断，Linux内核使用一个int变量表示中断号。中断号也称为中断线。
中断API函数
request_irq

Linux内核使用中断需要申请，request_irq用于申请中断。request_irq会导致睡眠，不能再中断上下文或禁止睡眠的代码中使用。request_irq会使能中断。

    int request_irq(unsigned int  irq,
                    irq_handler_t handler,
                    unsigned long flags,
                    const char    *name,
                    void          *dev);
    
    irq：申请中断的中断号。
    handler：中断处理函数，中断发生后执行中断处理函数。
    flags：中断标志。
    name：中断名，设置完成后在/proc/interrupts中查看中断名。
    dev：设备结构体，如果将flags设置为IRQF_SHARED共享中断，dev用于区分不同的中断，dev设备结构体传递给中断处理函数的第二个参数。
    返回值：0，中断申请成功；负值，中断申请失败，-EBUSY表示中断已经被申请。

中断标志flags 标志	描述
IRQF_SHARED	多个设备共享一个中断号，共享的所有中断都必须指定IRQF_SHARED标志
IRQF_ONESHOT	中断执行一次就结束
IRQF_TRIGGER_NONE	无触发
IRQF_TRIGGER_RISING	上升沿触发
IRQF_TRIGGER_FALLING	下降沿触发
IRQF_TRIGGER_HIGH	高电平触发
IRQF_TRIGGER_LOW	低电平触发
free_irq

 中断使用完后释放相应的中断，如果中断不是共享中断，free_irq会删除中断处理函数并禁止中断。

    void free_irq(unsigned int irq,
                  void         *dev);
    
    irq：释放的中断号。
    dev：区分不同的共享中断，共享中断只有在释放最后中断处理函数时才会被禁止。
    返回值：无。

中断处理函数

 第一个参数：中断号。

第二个参数：指向void的指针，与request_irq函数的dev参数保持一直，用于区分共享中断的不同设备。

返回值：irqreturn_t类型，共有三种返回值，一般使用IRQ_HANDLED。

    /* 中断处理函数 */
    irqreturn_t(*irq_handler_t)(int, void *)
     
    /* 返回值irqreturn_t类型定义 */
    enum irqreturn {
        IRQ_NONE        = (0 << 0);
        IRQ_HANDLED     = (1 << 0);
        IRQ_WAKE_THREAD = (1 << 1);
    };
     
    typedef enum irqreturn irqreturn_t

中断使能/禁止函数 

disable_irq函数需要等到当前正在执行的中断处理函数执行完才返回，需要保证不会产生新的中断，并且所有已经开始执行的中断程序已经全部退出。 

    /* 中断使能 */
    void enable_irq(unsigned int irq);
    /* 中断禁止 */
    void disable_irq(unsigned int irq);
    
    irq：中断号。 

 disable_irq_nosync函数调用后立即返回，不会等待当前中断处理程序执行完毕。

void disable_irq_nosync(unsigned int irq);

 使能全局中断和禁止全局中断

    local_irq_enable();
    local_irq_disable();

local_irq_save禁止中断，把中断状态保存在flags；local_irq_restore恢复中断，恢复至flags状态。

    local_irq_save(flags);
    local_irq_restore(flags);

中断上半部和下半部

上半部：中断处理函数，对时间敏感、处理速度较快、不会占用很长时间的操作放在上半部进行。

下半部：中断处理过程中比较耗时的程序放在下半部进行，Linux内核提供多种下半部机制。

Linux内核将中断分为上半部和下半部的主要目的：实现中断处理函数的快进快出。

上半部和下半部举例：上半部将数据拷贝到内存，下半部对数据进行处理。

需要根据实际情况判断哪些代码属于上半部还是下半部，可参考如下情况进行判断：

    要处理的内容不希望被其他中断打断，放在上半部。
    要处理的任务对时间敏感，放在上半部。
    要处理的任务和硬件有关，放在上半部。
    其余的任务，放在下半部。

中断下半部常用处理方法
软中断（不推荐使用）

Linux内核定义softirq_action结构体表示软中断。

    struct softirq_action {
        void (*action)(struct softirq_action *);
    ?;

在kernel/softirq.c中定义了10个软中断。softirq_action结构体中的action成员变量是软中断的服务函数。

    static struct softirq_action softirq_vec[NR_SOFTRQS];
     
    enum {
        HI_SOFTIRQ=0,    /* 高优先级软中断 */
        TIMER_SOFTIRQ,   /* 定时器软中断 */
        NET_TX_SOFTIRQ,  /* 网络数据发送软中断 */
        NET_RX_SOFTIRQ,  /* 网络数据接收软中断 */
        BLOCK_SOFTIRQ,
        BLOCK_IOPOLL_SOFTIRQ,
        TASKLET_SOFTIRQ, /* tasklet 软中断 */
        SCHED_SOFTIRQ,   /* 调度软中断 */
        HRTIMER_SOFTIRQ, /* 高精度定时器软中断 */
        RCU_SOFTIRQ,     /* RCU 软中断 */
        NR_SOFTIRQS
    };

注册软中断处理函数

void open_softirq(int nr, void (*action)(struct softirq_action *));

    nr：要开起的软中断，从10个软中断中选择。
    action：软中断对应的处理函数。
    返回值：无。 

 触发中断

void raise_softirq(unsigned int nr);

    nr：要开起的软中断，从10个软中断中选择。
    返回值：无。

软中断必须哎编译的时候静态注册。
tasklet（建议使用）

Linux内核定义tasklet_struct结构体表示tasklet。

    struct tasklet_struct {
        struct tasklet_struct *next; /* 下一个 tasklet */
        unsigned long state;         /* tasklet 状态 */
        atomic_t count;              /* 计数器，记录对 tasklet 的引用数 */
        void (*func)(unsigned long); /* tasklet 执行的函数 */
        unsigned long data;          /* 函数 func 的参数 */
    };

 先定义一个tasklet，然后使用tasklet_init初始化。

    void tasklet_init(struct tasklet_struct *t,
                      void (*func)(unsigned long), 
                      unsigned long data);
    
     t：要初始化的tasklet。
    func：tasklet 的处理函数。
    data：要传递给func函数的参数
    返回值：无。

使用宏DECLARE_TASKLET一次性完成tasklet的定义和初始化。

DECLARE_TASKLET(name, func, data);

    name：tasklet的名字。
    func：tasklet的处理函数。
    data：传递给func的参数。

tasklet也要用到上半部，只是上半部的中断处理函数重点是调度tasklet_schedule使tasklet在合适的时间运行。

void tasklet_schedule(struct tasklet_struct *t);

    t：要调用的tasklet，也是宏DECLARE_TASKLET里面的name。
    返回值：无。 

tasklet例程

    // 定义tasklet
    struct tasklet_struct test_tasklet;
     
    // tasklet处理函数
    void test_tasklet_func(unsigned long data) {
        // tasklet的具体处理代码
    }
     
    // 中断处理函数
    irqreturn_t test_handler(int irq, void *dev_id) {
        
        //调度tasklet
        tasklet_schedule(&test_tasklet);
     
    }
     
    // 驱动入口函数
    static int __init xxx_init(void) {
        // 初始化tasklet
        tasklet_init(&test_tasklet, test_tasklet_func, data);
        // 注册中断处理函数
        request_irq(xxx_irq, test_handler, 0, "xxx", &xxx_dev);
    }

工作队列（需要睡眠的工作中使用）

工作队列在进程上下文执行，将要推后的工作交给一个内核线程去执行，允许睡眠或重新调度。

Linux内核定义work_struct结构体表示一个工作。

    struct work_struct {
        atomic_long_t data;
        struct list_head entry;
        work_func_t func;    // 工作队列处理函数
    };

 许多工作组成工作队列，定义workqueue_struct结构体表示工作队列。

    struct workqueue_struct {
        struct list_head pwqs;
        struct list_head list;
        struct mutex mutex;
        int work_color;
        int flush_color;
        atomic_t nr_pwqs_to_flush;
        struct wq_flusher *first_flusher;
        struct list_head flusher_queue;
        struct list_head flusher_overflow;
        struct list_head maydays;
        struct worker *rescuer;
        int nr_drainers;
        int saved_max_active;
        struct workqueue_attrs *unbound_attrs;
        struct pool_workqueue *dfl_pwq;
        char name[WQ_NAME_LEN];
        struct rcu_head rcu;
        unsigned int flags ____cacheline_aligned;
        struct pool_workqueue __percpu *cpu_pwqs;
        struct pool_workqueue __rcu *numa_pwq_tbl[];
    };

 Linux内核使用工作者线程worker thread处理工作队列中的各个工作，Linux内核定义worker结构体表示工作者线程。

    struct worker {
        union {
            struct list_head entry;
            struct hlist_node hentry;
        };
        struct work_struct *current_work;
        work_func_t current_func;
        struct pool_workqueue *current_pwq;
        bool desc_valid;
        struct list_head scheduled;
        struct task_struct *task;
        struct worker_pool *pool;
        struct list_head node;
        unsigned long last_active;
        unsigned int flags;
        int id;
        char desc[WORKER_DESC_LEN];
        struct workqueue_struct *rescue_wq;
    };

Linux驱动开发，只需要定义工作work_struct即可。定义work_struct结构体变量，然后INIT_WORK初始化。

#define INIT_WORK(_work, _func)

    _work：要初始化的工作。
    _func：工作处理函数 。

也可以使用宏DECLARE_WORK一次性完成工作的创建和初始化。

#define DECLARE_WORK(n, f)

    n：定义的工作。
    f：工作处理函数。 

工作的调度函数schedule_work

bool schedule_work(struct work_struct *work);

    work：要调度的工作。
    返回值：0，成功；其他值，失败。 

工作队列例程

    // 定义工作
    struct work_struct test_work;
     
    // 工作处理函数
    void test_work_func_t(struct work_struct *work) {
        
    }
     
    // 中断处理函数
    irqreturn_t test_handler(int irq, void *dev_id) {
        
        // 调度工作work
        schedule_work(&test_work);
        
    }
     
    // 驱动入口函数
    static int __init xxx_init(void) {
        // 初始化工作
        INIT_WORK(&test_work, test_work_func_t);
        // 注册中断处理函数
        request_irq(xxx_irq, test_handler, 0, "xxx", &xxx_dev);
    }

设备树设置中断信息

    interrupt-controller，表示当前节点为中断控制器。
    #interrupt-cells，指定interrupts属性的cells大小。
    interrupts，指定中断号、触发方式。
    interrupt-parent，指定父中断，即中断控制器。

Linux内核通过读取设备树中的中断属性信息配置中断。imx6ull.dtsi文件中intc节点表示如下：

    intc: interrupt-controller@00a01000 {
        compatible = "arm, cortex-a7-gic";
        #interrupt-cells = <3>;
        interrupt-controller;
        reg = <0x00a01000 0x1000>,
              <0x00a02000 0x100>;
    };

#interrupt-cells描述interrupt属性的cells大小，对于ARM处理器的GIC中断控制器，共有3个cells。

    第一个cells表示中断类型，0，SPI中断；1，PPI中断。
    第二个cells表示中断号，SPI中断的中断号范围0-987，PPI中断的中断号范围0-15。
    第三个cells表示标志，bit[3:0]表示中端触发类型，1，上升沿触发；2，下降沿触发；4，高电平触发；8，低电平触发。bit[15:8]表示PPI中断的CPU掩码。

interrupt-controller节点为空表示当前节点是中断控制器。

gpio节点也可作为中断控制器，imx6ull.dtsi文件中gpio5节点表示如下：

    gpio5: gpio@0x0ac000 {
        compatible = "fsl, imx6ul-gpio", "fsl, imx35-gpio";
        reg = <0x020ac000 0x4000>;
        interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,
                     <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
        gpio-controller;
        #gpio-cells = <2>;
        interrupt-controller;
        #interrupt-cells = <2>;
    };

interrupts描述中断源信息，中断类型都是SPI，触发电平是高电平，查看芯片手册gpio5的中断号一个是74，对应GPIO5_IO00~GPIO5_IO15低16位IO，一个是75，对应GPIO5_IO16~GPIO5_IO31高16位IO。 

Linux内核include/linux/irq.h文件中定义了中断号（线）的状态：

    /*
     * IRQ line status.
     *
     * Bits 0-7 are the same as the IRQF_* bits in linux/interrupt.h
     *
     * IRQ_TYPE_NONE		- default, unspecified type
     * IRQ_TYPE_EDGE_RISING		- rising edge triggered
     * IRQ_TYPE_EDGE_FALLING	- falling edge triggered
     * IRQ_TYPE_EDGE_BOTH		- rising and falling edge triggered
     * IRQ_TYPE_LEVEL_HIGH		- high level triggered
     * IRQ_TYPE_LEVEL_LOW		- low level triggered
     * IRQ_TYPE_LEVEL_MASK		- Mask to filter out the level bits
     * IRQ_TYPE_SENSE_MASK		- Mask for all the above bits
     * IRQ_TYPE_DEFAULT		- For use by some PICs to ask irq_set_type
     *				  to setup the HW to a sane default (used
     *                                by irqdomain map() callbacks to synchronize
     *                                the HW state and SW flags for a newly
     *                                allocated descriptor).
     *
     * IRQ_TYPE_PROBE		- Special flag for probing in progress
     *
     * Bits which can be modified via irq_set/clear/modify_status_flags()
     * IRQ_LEVEL			- Interrupt is level type. Will be also
     *				  updated in the code when the above trigger
     *				  bits are modified via irq_set_irq_type()
     * IRQ_PER_CPU			- Mark an interrupt PER_CPU. Will protect
     *				  it from affinity setting
     * IRQ_NOPROBE			- Interrupt cannot be probed by autoprobing
     * IRQ_NOREQUEST		- Interrupt cannot be requested via
     *				  request_irq()
     * IRQ_NOTHREAD			- Interrupt cannot be threaded
     * IRQ_NOAUTOEN			- Interrupt is not automatically enabled in
     *				  request/setup_irq()
     * IRQ_NO_BALANCING		- Interrupt cannot be balanced (affinity set)
     * IRQ_MOVE_PCNTXT		- Interrupt can be migrated from process context
     * IRQ_NESTED_TRHEAD		- Interrupt nests into another thread
     * IRQ_PER_CPU_DEVID		- Dev_id is a per-cpu variable
     * IRQ_IS_POLLED		- Always polled by another interrupt. Exclude
     *				  it from the spurious interrupt detection
     *				  mechanism and from core side polling.
     */
    enum {
    	IRQ_TYPE_NONE		= 0x00000000,
    	IRQ_TYPE_EDGE_RISING	= 0x00000001,
    	IRQ_TYPE_EDGE_FALLING	= 0x00000002,
    	IRQ_TYPE_EDGE_BOTH	= (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING),
    	IRQ_TYPE_LEVEL_HIGH	= 0x00000004,
    	IRQ_TYPE_LEVEL_LOW	= 0x00000008,
    	IRQ_TYPE_LEVEL_MASK	= (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH),
    	IRQ_TYPE_SENSE_MASK	= 0x0000000f,
    	IRQ_TYPE_DEFAULT	= IRQ_TYPE_SENSE_MASK,
     
    	IRQ_TYPE_PROBE		= 0x00000010,
     
    	IRQ_LEVEL		= (1 <<  8),
    	IRQ_PER_CPU		= (1 <<  9),
    	IRQ_NOPROBE		= (1 << 10),
    	IRQ_NOREQUEST		= (1 << 11),
    	IRQ_NOAUTOEN		= (1 << 12),
    	IRQ_NO_BALANCING	= (1 << 13),
    	IRQ_MOVE_PCNTXT		= (1 << 14),
    	IRQ_NESTED_THREAD	= (1 << 15),
    	IRQ_NOTHREAD		= (1 << 16),
    	IRQ_PER_CPU_DEVID	= (1 << 17),
    	IRQ_IS_POLLED		= (1 << 18),
    };

具体开发板中fxls8471磁力计的中断属性信息示例如下：

    fxls8471@1e {
        compatible = "fsl, fxls8471";
        reg = <0x1e>;
        position = <0>;
     
        interrupt-parent = <&gpio5>;
        interrupts = <0 8>;
    };

 具体开发板的设备树一般只需要添加两行：

    interrupt-parent属性设置gpio5为中断控制器 。
    interrupts设置中断信息，0，表示GPIO5_IO00，8表示低电平触发。

获取中断号
 irq_of_parse_and_map

    unsigned int irq_of_parse_and_map(struct device_node *dev,
                                      int index);
    
    dev：设备节点。
    index：interrupts属性可能包含多条中断信息，index指定要获取的信息。
    返回值：中断号。

gpio_to_irq

获取gpio对应的中断号

inT gpio_to_irq(unsigned int gpio);

    gpio:GPIO编号。
    返回值：GPIO对应的中断号。

————————————————
版权声明：本文为CSDN博主「奶油芝士汉堡包」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_41276397/article/details/124284739

## 6. Linux 驱动 platform 虚拟总线

1、为什么需要platform总线

        举一个例子，对于同一个主机来说，他可以支持很多I2C设备，对于同一个I2C设备来说，他也可以给很多主机来用，如果每个主机对应每个设备都需要一段驱动代码的话，会非常的冗余，根据高内聚低耦合的原则，这样是非常不好的。所以就需要这么一个统一的接口，将二者分离开来，设备端只负责设备，驱动端只负责驱动。于是提出platform这个虚拟总线，相应的就有 platform_driver 和 platform_device。当设备或者驱动加载时，就会去对面查看是否有匹配的内容。

2、设备端：platform_device
2.1 platform_device结构体

    struct platform_device {
    	const char	*name;  //用于匹配的名字
    	int		id;         //总线号 PLATFORM_DEVID_AUTO
    	//bool		id_auto; //TRUE
    	struct device	dev; //父类
    	u32		num_resources;     //资源的个数
    	struct resource	*resource; //设备信息结构体
        char *driver_override; 
    }
    struct device{
       void	(*release)(struct device *dev); //释放资源的函数
    };
     
    struct resource { //设备信息结构体
    	resource_size_t start; //资源的起始值 
    	resource_size_t end;   //资源的结束值 
    	unsigned long flags;   //资源的类型
    					IORESOURCE_IO		//GPIO类型的资源
    					IORESOURCE_MEM		//内存类型的资源
    					IORESOURCE_IRQ	    //中断类型的资源
    					IORESOURCE_DMA	    //DMA类型的资源
    };

2.2 注册

int platform_device_register(struct platform_device *);

2.3 注销

void platform_device_unregister(struct platform_device *);

3、驱动端：platform_driver
3.1 platform_driver结构体

    struct platform_driver {
    	int (*probe)(struct platform_device *);     //匹配成功执行的函数
    	int (*remove)(struct platform_device *);    //分离的时候执行的函数
    	struct device_driver driver;                //父类
    	const struct platform_device_id *id_table;	
    };
     
    struct device_driver {
    	const char		*name;                       
    	const struct of_device_id	*of_match_table; 
    }； 

3.2 注册

int platform_driver_register (struct platform_driver *);

3.3 注销

void platform_driver_unregister(struct platform_driver *);

4、总线
4.1 bus_type 

Linux 内核用 bus_type 结构体来表示总线，我们所用的 I2C、SPI、USB 都是用这个结构体来定义的。该结构体如下：

    struct bus_type {
    	const char		*name;
    	const char		*dev_name;
    	struct device		*dev_root;
    	struct device_attribute	*dev_attrs;	/* use dev_groups instead */
    	const struct attribute_group **bus_groups;
    	const struct attribute_group **dev_groups;
    	const struct attribute_group **drv_groups;
     
    	int (*match)(struct device *dev, struct device_driver *drv);
    	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
    	int (*probe)(struct device *dev);
    	int (*remove)(struct device *dev);
    	void (*shutdown)(struct device *dev);
     
    	int (*online)(struct device *dev);
    	int (*offline)(struct device *dev);
     
    	int (*suspend)(struct device *dev, pm_message_t state);
    	int (*resume)(struct device *dev);
     
    	const struct dev_pm_ops *pm;
     
    	const struct iommu_ops *iommu_ops;
     
    	struct subsys_private *p;
    	struct lock_class_key lock_key;
    };

4.2 platform_bus_type

platform总线是 bus_type的一个具体实例，定义如下：

    struct bus_type platform_bus_type = {
    	.name		= "platform",
    	.dev_groups	= platform_dev_groups,
    	.match		= platform_match,
    	.uevent		= platform_uevent,
    	.pm		= &platform_dev_pm_ops,
    };

5、匹配
5.1 匹配规则，platform_match

在platform_bus_type中，match函数就是用来匹配的，platform_match函数实现如下：

    static int platform_match(struct device *dev, struct device_driver *drv)
    {
    	struct platform_device *pdev = to_platform_device(dev);
    	struct platform_driver *pdrv = to_platform_driver(drv);
     
    	/* When driver_override is set, only bind to the matching driver */
    	if (pdev->driver_override)
    		return !strcmp(pdev->driver_override, drv->name);
     
    	/* Attempt an OF style match first */
    	if (of_driver_match_device(dev, drv))
    		return 1;
     
    	/* Then try ACPI style match */
    	if (acpi_driver_match_device(dev, drv))
    		return 1;
     
    	/* Then try to match against the id table */
    	if (pdrv->id_table)
    		return platform_match_id(pdrv->id_table, pdev) != NULL;
     
    	/* fall-back to driver name match */
    	return (strcmp(pdev->name, drv->name) == 0);
    }
     
    static inline int of_driver_match_device(struct device *dev,
    					 const struct device_driver *drv)
    {
    	return of_match_device(drv->of_match_table, dev) != NULL;
    }
    
    1、platform_device.driver_override 和 platform_driver.driver.name
    
    2、设备树中的compatible  和 platform_driver.driver.of_match_table 的 compatible
    
    3、platform_device.name                和 platform_driver.id_table[i].name
    
    4、platform_device.name                和 platform_driver.driver.name

5.2 platform_device匹配流程

    platform_device_register(&pdev){
        return platform_device_add(pdev)
    }
    ->
    pdev->dev.bus = &platform_bus_type
    device_add(&pdev->dev)
    ->
    bus_add_device(dev)  //放入链表
    bus_probe_device(dev)
    ->
    device_initial_probe(dev)
    ->
    __device_attach(dev, true)
    ->
    bus_for_each_drv(dev->bus, NULL, &data, __device_attach_driver)
    ->
    __device_attach_driver
    ->
    driver_match_device(drv, dev)  //是否匹配
    return driver_probe_device(drv, dev)  //调用 probe 函数

5.3 platform_driver匹配流程

    #define platform_driver_register(drv)
    ->
    __platform_driver_register(drv, THIS_MODULE)
    ->
    drv->driver.bus = &platform_bus_type; //指定为platform bus
    driver_register(&drv->driver)
    ->
    bus_add_driver(drv)  //放入链表
    ->
    driver_attach(drv)
    ->
    bus_for_each_dev(drv->bus, NULL, drv, __driver_attach)
    ->
    __driver_attach
    ->
    driver_match_device(drv, dev)
    ->
    drv->bus->match(dev, drv) //是否匹配

6、在没有设备树时，使用name进行匹配
6.1 设备端程序

    struct resource res[] = {
    	[0] = {
    		.start = 0x12345678,
    		.end = 0x12345678+49,
    		.flags = IORESOURCE_MEM,				 
    	},
    	[1] = {
    		.start = 71,
    		.end = 71,
    		.flags = IORESOURCE_IRQ,
    	}
    };
     
    void pdev_release(struct device *dev)
    {
     
    }
     
    struct platform_device pdev = {
    	.name = "aabbccdd",
    	.id = PLATFORM_DEVID_AUTO, //自动分配
    	.dev = {
    		.release =  pdev_release,
    	},
    	.resource = res,
    	.num_resources = ARRAY_SIZE(res),
    };
     
    static int __init pdev_init(void)
    {
    	return platform_device_register(&pdev);
    }
     
    static void __exit pdev_exit(void) 
    {
    	platform_device_unregister(&pdev);
    }

6.2 驱动端程序

    int pdrv_probe(struct platform_device*pdev)
    {
        return 0;
    }
     
    int pdrv_remove(struct platform_device*pdev)
    {
        return 0;
    }
     
    struct platform_driver pdrv = {
        .probe = pdrv_probe,
        .remove = pdrv_remove,
        .driver = {
            .name = "aabbccdd",
        },
    };
     
    static int __init pdrv_init(void)
    {
        return platform_driver_register(&pdrv);
    }
     
    static void __exit pdrv_exit(void)
    {
        platform_driver_unregister(&pdrv);
    }

7、在没有设备树时，使用 idtable 进行匹配
7.1 设备端程序

与 6.1 设备端不一样的地方

    struct platform_device pdev = {
    	.name = "hello1",
    	.id = PLATFORM_DEVID_AUTO, //自动分配
    	.dev = {
    		.release =  pdev_release,
    	},
    	.resource = res,
    	.num_resources = ARRAY_SIZE(res),
    };

7.2 驱动端程序

与 6.2 驱动端不一样的地方

    struct platform_device_id idtable[] = {
    	{"hello1",0},
    	{"hello2",1},
    	{"hello3",2},
    	{/*end*/}
    };
     
    struct platform_driver pdrv = {
    	.probe = pdrv_probe,
    	.remove = pdrv_remove,
    	.driver = {
    		.name = "aabbccdd", //这个name一定要填，因为要以这个名字创建文件夹 
    	},
    	.id_table = idtable,
    };

8、获取设备信息
8.1 获取设备信息的API
8.1.1 platform_get_resource

    struct resource *platform_get_resource(struct platform_device *dev,
    				       unsigned int type, unsigned int index)
    /*
    功能：在驱动中获取设备信息
    参数：
        @dev :platform_device的结构体指针
    	@type:资源的类型
    	@index:同类型资源的索引号
    返回值：成功返回resource的结构体指针，失败返回NULL
    */

8.1.2 platform_get_irq

    int platform_get_irq(struct platform_device *dev, unsigned int index)
    /*
    功能：获取中断类型的资源
    参数：
        @dev :platform_device的结构体指针
        @index:中断类型资源的索引号    
    返回值：成功返回中断号，失败返回错误码
    */

8.1.3 根据device_node获取设备信息

    Linux驱动开发：设备树节点与属性_凛冬将至__的博客-CSDN博客的7与8两节

8.2 驱动程序

完整的驱动程序就不再重写了，在 6.2 驱动程序中 probe 函数中得到设备信息

    struct resource *res;
    int pdrv_probe(struct platform_device*pdev)
    {
        res = platform_get_resource(pdev,IORESOURCE_MEM,0);
     
        irqno = platform_get_irq(pdev,0);
     
        printk("addr = %#llx,irqno = %d\n",res->start,irqno);
     
        return 0;
    }

9、module_platform_driver：一键注册platform

    //在linux/platform_device.h中
    #define module_platform_driver(__platform_driver) 
    	module_driver(__platform_driver, platform_driver_register, 
    			platform_driver_unregister)
     
    //##代表字符串的拼接
    #define module_driver(__driver, __register, __unregister, ...) 
    static int __init __driver##_init(void) 
    { 
    	return __register(&(__driver) , ##__VA_ARGS__); 
    } 
    module_init(__driver##_init); 
    static void __exit __driver##_exit(void) 
    { 
    	__unregister(&(__driver) , ##__VA_ARGS__); 
    } 
    module_exit(__driver##_exit);

使用该宏： module_platform_driver(pdrv)，即被转化为：

    #define module_platform_driver(pdrv) 
    	module_driver(pdrv, platform_driver_register, platform_driver_unregister)
     
    #define module_driver(pdrv, platform_driver_register, platform_driver_unregister) 
     
    static int __init pdrv_init(void) 
    { 
    	return platform_driver_register(&pdrv); 
    } 
     
    static void __exit pdrv_exit(void) 
    { 
    	platform_driver_unregister(&pdrv); 
    } 
    module_init(pdrv_init); 
    module_exit(pdrv_exit);

10、MODULE_DEVICE_TABLE：实现热插拔
10.1 定义以及使用方法

    //定义在linux/module.h中
    #define MODULE_DEVICE_TABLE(type, name)					
    extern const typeof(name) __mod_##type##__##name##_device_table		
      __attribute__ ((unused, alias(__stringify(name))))

使用时，参数如下：

    MODULE_DEVICE_TABLE（of，match_table）
    of：总线类型
    match_table：idtable数组首地址

10.2 如何实现热插拔的功能

    1.先将 pdev.ko 和 pdrv.ko 放到下面的目录中
    /lib/modules/5.4.0-148-generic/kernel/drivers/platform
    2.执行depmod -a命令，让内核重新检索文件的位置
    3.安装 pdev.ko , pdrv.ko 会被自动安装

11、 platform设备树匹配
11.1 修改设备树以及驱动程序的compatible属性
11.1.1 驱动端

在 5.1 中我们已经看过了匹配的流程，其中第二种方式就是用设备树匹配：设备树中的compatible  和 platform_driver.driver.of_match_table 的 compatible进行匹配

    struct of_device_id oftable[] = {
        {.compatible = "aaa,aaa",},
        {.compatible = "bbb,bbb",},
        {.compatible = "ccc,ccc",},
        {/*end*/} //一定要有一个空的在
    };
     
    struct platform_driver {
        .driver = {
            .of_match_table = oftable,
        },
    };
     
    struct device_driver driver {
        struct device_driver driver;
    }
     
    struct device_driver {
        const struct of_device_id	*of_match_table;
    }
     
    struct of_device_id {
    	char	name[32];
    	char	type[32];
    	char	compatible[128];  //通过本选项和设备树完成匹配
    	const void *data;
    };

11.1.2 设备树

节点下需要有个 compatible 属性，并且该属性需要与 oftable 中的 compatible 名字相同，例如：

    myplatform{
        compatible = "aaa,aaa";
    };  

11.2 驱动程序：获取设备树中的中断以及GPIO资源

    有关GPIO部分请看:
    
    Linux驱动开发：gpio子系统_凛冬将至__的博客-CSDN博客
    
    有关中断部分请看：
    
    Linux驱动开发：中断子系统_凛冬将至__的博客-CSDN博客
    
    有关阻塞部分请看：
    
    Linux驱动开发 IO模型：阻塞IO_linux阻塞io_凛冬将至__的博客-CSDN博客

11.2.1 修改设备树

在根节点下添加自己的节点

    myplatform{
        compatible = "aaa,aaa";
        interrupt-parent = <&gpiof>;
        interrupts = <9 0>;
        reg = <0x12345678 0x40>;
        led1 = <&gpioe 10 0>;
    };

11.2.2 驱动程序

    #define IRQNAME "key_irq"
    int irqno, major;
    struct gpio_desc* desc;
    struct class* cls;
    struct device* dev;
    wait_queue_head_t wq;
    int condition=0;
    int status=0;
    irqreturn_t key_irq_handle(int irq, void* dev)
    {
        //1.设置status和led1
        status = gpiod_get_value(desc);
        status = !status;
        gpiod_set_value(desc,status);
     
        //2唤醒
        condition=1;
        wake_up_interruptible(&wq);
     
        return IRQ_HANDLED;
    }
    int pdrv_open(struct inode* inode, struct file* file)
    {
        return 0;
    }
     
    ssize_t pdrv_read(struct file*file,
         char __user*ubuf, size_t size, loff_t*offs)
    {
        int ret;
        if(file->f_flags & O_NONBLOCK){
            return -EINVAL;
        }else{
            ret = wait_event_interruptible(wq,condition);
        }
     
        ret = copy_to_user(ubuf,&status,size);
     
        condition = 0;
     
        return size;
    }
    int pdrv_close(struct inode* inode, struct file* file)
    {
        return 0;
    }
    struct file_operations fops = {
        .open = pdrv_open,
        .read = pdrv_read,
        .release = pdrv_close,
    };
    int pdrv_probe(struct platform_device* pdev)
    {
        int ret;
        // 1.获取设备树中的设备信息
        irqno = platform_get_irq(pdev, 0);
        desc = gpiod_get_from_of_node(pdev->dev.of_node, "led1", 0, GPIOD_OUT_LOW, NULL);
     
        // 2.注册中断
        ret = request_irq(irqno, key_irq_handle, IRQF_TRIGGER_FALLING, IRQNAME, NULL);
     
        // 3.注册字符设备驱动
        major = register_chrdev(0, IRQNAME, &fops);
        cls = class_create(THIS_MODULE, IRQNAME);
        dev = device_create(cls, NULL, MKDEV(major, 0), NULL, IRQNAME);
     
        //4.初始化等待队列头
        init_waitqueue_head(&wq);
        return 0;
    }
    int pdrv_remove(struct platform_device* pdev)
    {
        device_destroy(cls, MKDEV(major, 0));
        class_destroy(cls);
        unregister_chrdev(major, IRQNAME);
        free_irq(irqno, NULL);
        gpiod_put(desc);
        return 0;
    }
    const struct of_device_id oftable[] = {
        {
            .compatible = "aaa,aaa",
        },
        { /*end*/ }
    };
    struct platform_driver pdrv = {
        .probe = pdrv_probe,
        .remove = pdrv_remove,
        .driver = {
            .name = "bbb", //虽然用不到，但是一定要写
            .of_match_table = oftable,
        },
     
    };
    //一键注册
    module_platform_driver(pdrv);

11.3 应用程序

    int main(int argc,const char * argv[])
    {
        int fd,status;
        if((fd = open("/dev/key_irq",O_RDWR))==-1)
            PRINT_ERR("open error");
     
        while(1){
            read(fd,&status,sizeof(status));
            printf("status = %d\n",status);
        }
     
        close(fd);
        return 0;
    }
————————————————
版权声明：本文为CSDN博主「凛冬将至__」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/W__winter/article/details/130517484





## 7. IPCC 通信框架

由于MP157 是一款多核异构的芯片，其中既包含的高性能的A7 核及实时性强的M4 内核，那么这两种处理器在工作时，怎么互相协调配合呢？这就涉及到了核间通信的概念了。

IPCC (inter-processor communication controller) 用于处理器间的数据交换的通知。它提供了一种非阻塞的信号机制，并提供原子的方式进行信号发布和信息检索。注意，核间通信的共享内存缓冲区是在MCU 的SRAM 中分配的，它不是IPCC 外设的一部分。
外设简述

IPCC 外设提供了硬件支持，来管理两个处理器实例之间的处理器间通信。每个处理器拥有特定的寄存器区域和中断。有点像硬件信号量的功能。

IPCC 提供了六个双向通道信号。每个通道分为两个子通道，每个子通道提供从“发送方”处理器到“接收方”处理器的单向信号:

    P1_TO_P2 子通道（从P1 发到P2）
    P2_TO_P1 子通道（从P2 发到P1）

子通道中包括如下功能：

    一个标志位，用于标识通道正在被占用和空闲的两种状态，这个标志被“发送方”处理器设置为被占用，并被“接收方”处理器清除。
    两个相关的中断（所有通道都共享）:
    – RXO: RX 通道被占用，连接到“接收器”处理器。
    – TXF: TX 通道空闲，连接到“发送”处理器。
    带多路复用的中断掩码功能。

IPCC 支持以下信道的操作模式：
- 单工通信方式：
  – 仅使用一个子信道。
  – 单向消息：“发送者”处理器将通信数据发布到内存中后，它将通道状态标志设置为已占用。当消息被处理时，“接收者”处理器清除该标志。

    半双工通讯方式：
    – 仅使用一个子信道。
    – 双向消息：“发送者”处理器将通信数据发布到内存中后，它将通道状态标志设置为已占用。当消息被处理并且响应在共享内存中可用时，“接收器”处理器将清除该标志。
    全双工通讯方式：
    – 子通道用于异步模式。
    – 通过将子通道状态标志设置为占用，任何处理器都可以异步发布消息。当消息被处理时，“接收者”处理器清除该标志。可以将这种模式视为给定通道上两个单工模式的组合。

核间通信的模型如下：

在这里插入图片描述
框架简述

IPCC 作为核间通信的桥梁，它仅承担着通知的角色，负责消息的分发、中断的处理等。

实际上，IPCC 外设这个角色只是多核异构核间通信中的一块，在我们使用多核异构核间通信时，往往不仅希望使用到核间的消息通知，还希望能在不同的核心中进行数据的交互（比如M4 核进行实时的AD 数据采集处理，完成后，M4 核可通过异构的框架将数据呈递给A7 核，A7 核再进行更复杂的应用）。那么在这个需求的驱动下，就出现了一些框架相互配合使用的情况了，下面我们就给大家介绍这些内核框架。
RemoteProc framework

远程处理器框架（RPROC、RemoteProc）允许不同的平台/体系结构控制（打开电源，加载固件，关闭电源）远程处理器，同时抽象出硬件差异。此外，它还提供监视和调试远程协处理器的服务。

以MP157 为例，其RemoteProc 可分为两块，分别是A7 核端、M4 核端：

remoteproc：这是远程处理器框架的通用部分（在MP157 中为A7 核端）。

它的作用是：

－ 将ELF 固件加载到远程处理器内存中。
－ 解析固件资源表以设置关联的资源（例如IPC，内存分割和跟踪）。
－ 控制远程处理器的执行（启动，停止⋯）。
－ 提供监视和调试远程固件的服务。

stm32_rproc：这是远程处理器平台驱动程序（在MP157 中为M4 核端）。

它的作用是：

－ 将stm32 特定的功能（回调）注册到RPROC 框架。
－ 处理与远程处理器关联的平台资源（例如寄存器，看门狗，复位，时钟和存储器）。
－ 通过邮箱框架将通知（通知）转发到远程处理器。

ST 官方参考资料：
https://wiki.stmicroelectronics.cn/stm32mpu/wiki/Linux_RPMsg_framework_overview
RPMsg framework

此小节为大家简述有关Linux RPMsg 框架的内容。RPMsg 框架是一个基于virtio 的消息总线，它允许本地处理器与系统上可用的远程处理器通信。

此框架在多核异构中承担的角色如下图：

在这里插入图片描述

Linux RPMsg 框架是在virtio 框架顶层上实现的消息传送框架，其用于主机和远程处理器进行通信。它基于virtio vring，可通过共享内存向远程CPU 发送消息或从远程CPU 接收消息。

这些vring 是单向的，一个vring 专用于发送到远程处理器的消息，另一个vring 用于从远程处理器接收的消息。此外，共享缓冲区需要在两个处理器都可见的内存空间中创建。

当新消息在共享缓冲区中等待时，会使用到另一个框架Linux Mailbox framework ，该框架将用于通知对应的Core。

依靠这些框架，RPMsg 框架实现了基于不同通道的通信。通道可被文本名称标识，并有一个本地(“源”) 的RPMsg 地址和一个远程(“目的”) 的RPMsg 地址。

在远程处理器端（MP157 则为M4 核），也必须使用RPMSG 框架。RPMSG 框架的实现存在几种解决方案，ST 建议使用OpenAMP 方案，并在SDK 中给出了示例。

Github OpenAMP 框架.

简单来说，MP157 的A7 核与M4 核，通过一个标准的RPMsg 框架来建立起联系，完成数据传递。

在这里插入图片描述

具体原理可以参考：

RPMsg-Messaging-Protocol .
RPMsg-Communication-Flow .

Linux 内核源码目录给出的rpmsg client 的示例代码位置如下：

samples/rpmsg/rpmsg_client_sample.c

rpmsg 框架Linux 内核驱动源码位于：

drivers/rpmsg

ST 官方参考资料：

https://wiki.stmicroelectronics.cn/stm32mpu/wiki/Linux_remoteproc_framework_overview
Mailbox framework

此小节为大家简述有关Linux 邮箱框架的内容。邮箱框架涉及异构多核系统的处理器间通信。

此框架的结构如下图：

在这里插入图片描述

邮箱框架被用于内核间进行消息或信号的交换，常用于主机和协处理器间。邮箱由以下模块组成：

    一个邮箱控制器(mailbox controller)，依赖于硬件平台实现，比如MP157 的IPCC 外设：
    – 它负责配置和处理来自IPCC 外围设备的IRQ。
    – 它为邮箱客户端提供了通用API。
    
    一个邮箱客户端(mailbox client)，负责发送或接收消息。

关于此框架的权威描述，在内核文档中的如下目录：

Documentation/mailbox.txt

一般而言mailbox controller 和client 都由芯片厂商来负责实现，因为这依赖于外设。我们更常关注的，则是mailbox client 的创建和使用。

ST 实现的mailbox client 代码位置如下：

drivers/remoteproc/stm32_rproc.c

在内核中还给出了一份mailbox client 的示例驱动代码，代码通过debugfs 子系统，将mailbox 的操作暴露给了用户空间，用户可以直接通过debugfs 来使用mailbox，进行消息在不同内核中的传递。

mailbox 框架的设备树描述可参考内核源码文档：

Documentation/devicetree/bindings/mailbox/mailbox.txt

一个简单的mailbox client 设备树节点，可以参考内核源码目录：

Documentation/devicetree/bindings/mailbox/sti-mailbox.txt

内核源码目录给出的mailbox client 的示例代码位置如下：

drivers/mailbox/mailbox-test.c

ST 官方参考资料：

https://wiki.stmicroelectronics.cn/stm32mpu/wiki/Linux_Mailbox_framework_overview
框架小结

前面介绍了三个框架，它们并不是独立工作的，而是相互协调的，彼此关联。我们可以通过两张图来查看它们之间的关系。

以RemoteProc 框架为主视角出发：

在这里插入图片描述

可以理清三个框架的关系，RemoteProc 可以说是骨架，关联到了RPMsg 框架、Mailbox 框架。
设备树插件描述
IPCC 设备树节点

设备树节点位于arch/arm/boot/dts/stm32mp157c.dtsi

列表1: IPCC 设备树节点

ipcc: mailbox@4c001000 {
	compatible = "st,stm32mp1-ipcc";
	#mbox-cells = <1>;
	reg = <0x4c001000 0x400>;
	st,proc-id = <0>;
	interrupts-extended =
		<&intc GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>,
		<&intc GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
		<&exti 61 1>;
	interrupt-names = "rx", "tx", "wakeup";
	clocks = <&rcc IPCC>;
	wakeup-source;
	power-domains = <&pd_core>;
	status = "disabled";
};

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15

使用节点位于arch/arm/boot/dts/stm32mp157a-basic.dts

列表2: 使用IPCC 设备树节点

&ipcc {
	status = "okay";
};

    1
    2
    3

设备树中的compatible =“st,stm32mp1-ipcc”属性，会匹配到drivers/mailbox/stm32-ipcc.c 驱动程序，驱动程序中会创建一个mbox controller。
A7<–>M4 rproc 设备树节点

设备树节点位于arch/arm/boot/dts/stm32mp157c.dtsi

列表3: rproc 设备树节点

m4_rproc: m4@0 {
	compatible = "st,stm32mp1-rproc";
	#address-cells = <1>;
	#size-cells = <1>;

	ranges = <0x00000000 0x38000000 0x10000>,
			<0x30000000 0x30000000 0x60000>,
			<0x10000000 0x10000000 0x60000>;
	resets = <&rcc MCU_R>;
	reset-names = "mcu_rst";
	st,syscfg-pdds = <&pwr 0x014 0x1>;
	st,syscfg-holdboot = <&rcc 0x10C 0x1>;
	st,syscfg-tz = <&rcc 0x000 0x1>;
	st,syscfg-rsc-tbl = <&tamp 0x144 0xFFFFFFFF>;
	status = "disabled";
	
	m4_system_resources {
		compatible = "rproc-srm-core";
		status = "disabled";
	};
};

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21

使用节点位于arch/arm/boot/dts/stm32mp157a-basic.dts

列表4: 使用rproc 设备树节点

&m4_rproc {
	memory-region = <&retram>, <&mcuram>, <&mcuram2>, <&vdev0vring0>,
				<&vdev0vring1>, <&vdev0buffer>;
	mboxes = <&ipcc 0>, <&ipcc 1>, <&ipcc 2>;
	mbox-names = "vq0", "vq1", "shutdown";
	interrupt-parent = <&exti>;
	interrupts = <68 1>;
	interrupt-names = "wdg";
	wakeup-source;
	recovery;
	status = "okay";
};

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12

设备树中的compatible = “st,stm32mp1-rproc” 属性， 会匹配到drivers/remoteproc/stm32_rproc.c 驱动程序，驱动程序中会创建一个mbox client，并基于RemoteProc、RPMsg框架与mbox client 进行关联。
实验代码简述

这里我们就简单讲解一下M4 核端的代码和一些概念，更详细的内容则需大家自己研究了。

rpmsg 框架下有通信端点的概念，数据在两个端点间传输。端点间的数据传输是rpmsg 框架下数据传输最原始的形式，我们可以在原始的数据传输形式上再做一层封装，抽象出一些特定类型的设备。

每个端点注册的底层实现，就是一个内核设备的注册（使用的是平台总线模型），故注册的端点设备，可以利用到驱动的Probe 功能（具体实现详见drivers/rpmsg/rpmsg_core.c 300 行后内容）。

在M4 端，通过调用openamp 库中的OPENAMP_create_endpoint 函数，并在调用时指定参数name（即为设备名称），即可在内核中注册一个对应的rpmsg 框架平台设备，该设备最终可以通过name（设备名称）来匹配到相应的A7 端内核驱动：

在这里插入图片描述

所以Linux rpmsg 框架下使用平台总线模型与端点通讯的方式结合，给一些需要有特殊操作的自定设备，提供了支持的可能。比如异构间的通讯，可以封装成串口通讯模型。

在我们提供的M4 内核固件的代码中，注册了两种Linux 内核自带的rpmsg 框架下，原生支持的设备模型，这两种设备类型是rpmsg-tty-channel、rpmsg-client-sample：

    rpmsg-tty-channel：tty 终端设备，对应内核驱动源码drivers/rpmsg/rpmsg_tty.c，此
    驱动模块默认被编译进内核。
    rpmsg-client-sample：框架原生的通讯方式测试设备（放在内核里作为演示该框架的Demo提供的），对应内核驱动源码samples/rpmsg/rpmsg_client_sample.c，此驱动默认被编译成模块，并放置在文件系统/lib/modules/4.19.94-stm-r1/kernel/samples/rpmsg/rpmsg_client_sample.ko 中，当设备与驱动发生匹配时，系统会
    自动insmod 该驱动模块。
    还有一种字符设备模型，rpmsg_chrdev，源码位于drivers/rpmsg/rpmsg_char.c ，我
    们的代码中未实验，可自行研究。

在M4 核的代码中，还初始化了usart3 作为M4 内核的Log 输出串口，我们可以通过串口模块接入开发板上的usart3，来查看M4 内核输出的Log。最终工程代码会被用于生成ELF 固件，ELF固件即为程序，会运行在MP157 的M4 内核上。

综上，通过原生的rpmsg 框架设备、/dev/ttyRPMSGx 节点以及M4 内核使用的usart3 资源，我们就可以进行简单的实验了。本实验的代码也比较简单，这里就讲解这么多。
实验准备

由于多核异构的框架是与处理器的架构紧密联系在一起的，所以一般这些框架驱动会由芯片厂商为我们提供好。野火MP157 开发板默认开启了这些驱动支持，并且开启了对应的设备树，我们直接进行使用就可以了。

在前面我们提到了，M4 内核要与A7 内核通讯需要共用一个框架，那么M4 内核的运行的程序里，就需要有对应的框架代码，这个为大家提供的工程中已经包含。最终我们将代码生成的ELF固件，通过A7 内核的remoteproc 子系统加载到M4 内核上，即可做好前期的准备工作。

生成ELF 固件的工程代码位于\linux_driver\framework_ipcc\STM32Cube_FW_MP1_V1.2.0\Projects\STM32MP157C-EV1\Applications\OpenAMP\OpenAMP_raw 目录下，感兴趣可自行研究，工程可用MDK 或CubeIDE 打开（在工程目录中由对应文件夹）。

重要: 在M4 核的代码中，还初始化了usart3，实验前请务必将usart3 的设备树插件关闭。
实验操作

M4 核的固件我们已经成功编译并放在了/linux_driver/framework_ipcc 目录下，我们将M4 核的固件OpenAMP_raw_CM4.elf 上传至Linux 文件系统的/lib/firmware/ 目录。此目录存放着Linux 系统中会使用到的各种固件。

执行如下命令指定M4 内核加载的固件，默认在root 用户下操作：

# 进入remoteproc 子系统目录
cd /sys/class/remoteproc/remoteproc0
# 导入M4 内核固件名称
echo OpenAMP_raw_CM4.elf > firmware

    1
    2
    3
    4

在同一目录下，执行如下命令可启动停止M4 内核：

# 启动M4 内核
echo start > state
# 停止M4 内核
echo stop > state

    1
    2
    3
    4

启动M4 内核后信息如下：

在这里插入图片描述

M4 内核加载固件并启动后，在串口终端中打印出了一些信息，我们通过串口模块接入usart3引脚，再打开串口调试助手设置波特率为115200，可以看到M4 固件初始化的usart3 作为串口printf 出来的信息，为[INFO ]M4 send to A7 : hello world! ，并且A7 端的驱动也打印出了rpmsg_client_sample virtio0.rpmsg-client-sample.-1.0: incomingmsg 1 (src: 0x0) 说明M4 核及A7 核驱动正常工作了。

此外， 输入lsmod， 我们还可以看到演示设备创建后， 对应被动态加载的驱动模块，rpmsg_client_sample ：

在这里插入图片描述

下面，我们进行第二个设备测试，通过前面现象中的LOG，我们可以看到被枚举出的tty 设备节点/dev/ttyRPMSG0 节点，我们就通过该节点测试tty 设备的功能，输入如下命令：

echo "hello M4 core , i'm A7!" > /dev/ttyRPMSG0

    1

实验现象如下所示：

在这里插入图片描述

上图为A7 通过虚拟的tty 终端设备，转发到M4 内核的消息内容，最终通过M4 核固件的串口Log 功能打印出来对应信息。

自此，所有实验结束。
————————————————
版权声明：本文为CSDN博主「PicassoCao」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/picassocao/article/details/129097784







## 8. OpenAMP

通常在AMP（非对称多处理）配置中，会采用在不同的处理核上运行不同的软件环境并执行各自的代码程序，各核心之间通力合作实现处理器性能的提升。在AMP系统中，所谓的主处理器通常是指最先启动且主要负责管理其他CPU以及这些CPU上软件环境的CPU处理器。而远程处理器简单的讲就是指被主核所支配的CPU。主软件环境通常需要进行远程核心的管理以及任务调度，在需要进行计算任务分配时，将选择性地驱动远程内核上的远程软件环境，并交代任务信息。

OpenAMP软件框架为开发AMP系统提供了必要的API函数。OpenAMP 是Mentor Graphics  与赛灵思公司为了使在AMP系统的设计中开发出的RTOS和裸机程序能够与开源Linux社区提供的接口进行互通讯，而共同通过的一个标准化的嵌入式多核框架。的全称是 ,即开源的非对称多处理框架。OpenAMP框架提供了非对称多处理系统软件开发所需的软件组件。OpenAMP框架是一种软件框架，这种软件框架能够为非对称多处理(AMP)系统开发人员提供三大重要组件：

l 该组件是RPMsg组件的实现基础，在使用Remoteproc和RPMsg进行核间通信时使用到了这个概念。在后面会讲解Virtio的实现原理。

l :该组件用于主机上，实现对远程处理器及其相关软件环境进行生命周期管理(LCM)，说白了就是能够对远程处理器实现启动和关闭、加载远程处理器运用程序到内存适合位置，并完成virtio和RPMSG设备的注册等。

l ：实现多核处理器IPC通信的通道，基于virtio组件实现。

软件框架为开发人员提的标准化接口使得在AMP结构中设计和管理软硬件变得更为简单。和基础架构最初是由德州仪器设计开发的，并专门用在内核。使用该基础架构可以实现在主软件环境下对远程软件环境进行生命周期管理并进行核心间的通讯。但是，所提供的这些基础架构在一定程度上存在着局限性。首先，基础架构通常都是默认将作为其主操作系统，然而并不支持把作为非对称多处理结构配置中的远程软件环境。另外，和API只能从系统的内核空间中获得，由于缺乏相应的等效API或库，这些组件并没能用在其他的一些操作系统上，这造成了适用范围上的局限性。

软件框架很好的解决了以上的问题。该框架是和赛灵思共同通过地一个开源项目，其源代码可以在GitHub（https://github.com/OpenAMP/open-amp）上获得或从该文档相同目录下src文件夹中获得（open-amp-openamp_zynq_kernel_3.17）。

框架能够被很好地使用在实时操作系统或者裸机软件环境中，使得在这些软件环境下能够使用与Linux系统具有相同功能的和，且之间在使用上具有很好的兼容性。框架中的和基础架构使用VirtIO作为传输抽象层。下图显示了框架支持的各种软件环境及配置，由图所示，该框架可以被用在、或者裸机环境下，通过和组件实现不同软件环境之间的通讯。

嵌入式多核框架同样可以作为独立库使用。允许主处理器RTOS或者裸机软件环境中的程序对远程处理器进行生命周期管理并且使用与远程处理器进行通信。

 ![img](https://images2018.cnblogs.com/blog/786473/201807/786473-20180714210443401-1837692253.png)

 该系列主要基于Linux master/FreeRTOS  remote配置，讲解如何使用OpenAMP框架实现多核处理器核间通信，包括开发环境的搭建、工程的建立和编译等，并在需要的时候介绍所涉及的Virtio、RPMsg组件的工作原理。在开始设计开发之前，首先需要搭建相应的开发环境。

https://www.cnblogs.com/jiandahao/p/9310978.html



# 符录



# 参考文献



# 索引





操作系统宏内核和微内核区别 https://www.bilibili.com/read/cv23329414/

4岁小女孩修改一个字符获网友狂点赞https://www.linuxprobe.com/four-years-linux.html

操作系统的四个基本特征是什么:[https://www.php.cn/faq/495187.html](https://www.php.cn/faq/495187.html)

实时性操作系统和非实时性操作系统的概念及区别https://blog.csdn.net/Dinh_ding/article/details/125780067

车载实时操作系统与非实时操作系统https://zhuanlan.zhihu.com/p/84148986

Linux 中有哪些不同类型的 Shell？https://zhuanlan.zhihu.com/p/614551538


 LINUX过时了 https://www.cnblogs.com/coder-dreamer/archive/2013/01/11/2856642.html

Linux——用户、用户组管理和文件权限（8）https://zhuanlan.zhihu.com/p/424584330

嵌入式保姆级教程-一文讲解出Linux的文件目录结构 https://zhuanlan.zhihu.com/p/624152435

Linux发展史 https://www.cnblogs.com/haojinfei/articles/13652634.html

The UNIX Time-Sharing System https://chsasank.com/classic_papers/unix-time-sharing-system.html

GDB 简介 调试 使用实例 https://zhuanlan.zhihu.com/p/265099138

多线程编程指南:https://docs.oracle.com/cd/E19253-01/819-7051/index.html

![](https://pic1.zhimg.com/v2-f00d3ae2560808dd173d9205d5943b20_r.jpg)















