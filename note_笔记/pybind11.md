py::tuple args = py::make_tuple(1234, "hello", some_instance);

py::dict kwargs = py::dict("number"_a=1234, "say"_a="hello", "to"_a=some_instance);

Available types include handle, object, bool_, int_, float_, str, bytes, tuple, list, dict, slice, none, capsule, iterable, iterator, function, buffer, array, and array_t.



| More ActionsReturn value policy          | Description                                                  |
| ---------------------------------------- | ------------------------------------------------------------ |
| return_value_policy::take_ownership      | Reference an existing object (i.e. do not create a new copy) and take ownership. Python will call the destructor and delete operator when the object’s reference count reaches zero. Undefined behavior ensues when the C++ side does the same, or when the data was not dynamically allocated.  引用一个已经存在的对象(例如，不要创建一个新的副本)并获得所有权。当对象的引用计数为零时，Python将调用析构函数和delete操作符。当c++端做同样的事情，或者当数据没有被动态分配时，未定义的行为就会发生。 |
| return_value_policy::copy                | Create a new copy of the returned object, which will be owned by Python. This policy is comparably safe because the lifetimes of the two instances are decoupled.创建返回对象的新副本，该副本将归Python所有。此策略相对安全，因为两个实例的生存期是解耦的。 |
| return_value_policy::move                | Use std::move to move the return value contents into a new instance that will be owned by Python. This policy is comparably safe because the lifetimes of the two instances (move source and destination) are decoupled. 使用std::move将返回值内容移动到一个新实例中，该实例将归Python所有。此策略相对安全，因为两个实例(移动源和目标)的生存期是解耦的。 |
| return_value_policy::reference           | Reference an existing object, but do not take ownership. The C++ side is responsible for managing the object’s lifetime and deallocating it when it is no longer used. Warning: undefined behavior will ensue when the C++ side deletes an object that is still referenced and used by Python. 引用一个已存在的对象，但不获取所有权。c++端负责管理对象的生命周期，并在不再使用它时释放它。警告:当c++端删除一个仍被Python引用和使用的对象时，将会发生未定义的行为。 |
| return_value_policy::reference_internal  | Indicates that the lifetime of the return value is tied to the lifetime of a parent object, namely the implicit this, or self argument of the called method or property. Internally, this policy works just like return_value_policy::reference but additionally applies a keep_alive<0, 1> call policy (described in the next section) that prevents the parent object from being garbage collected as long as the return value is referenced by Python. This is the default policy for property getters created via def_property, def_readwrite, etc.指示返回值的生命周期绑定到父对象的生命周期，即被调用方法或属性的隐式this或self参数。在内部，该策略的工作原理类似于return_value_policy::reference，但另外应用了keep_alive< 0,1 >调用策略(下一节将描述)，防止父对象被垃圾回收，只要返回值被Python引用。这是通过def_property、def_readwrite等创建的属性getter的默认策略。 |
| return_value_policy::automatic           | This policy falls back to the policy return_value_policy::take_ownership when the return value is a pointer. Otherwise, it uses return_value_policy::move or return_value_policy::copy for rvalue and lvalue references, respectively. See above for a description of what all of these different policies do. This is the default policy for py::class_-wrapped types. 当返回值是指针时，该策略将退回到策略return_value_policy::take_ownership。否则，对于右引用和左引用分别使用return_value_policy::move或return_value_policy::copy。请参阅上面对所有这些不同政策的作用的描述。这是py:: class_wrapped类型的默认策略。 |
| return_value_policy::automatic_reference | As above, but use policy return_value_policy::reference when the return value is a pointer. This is the default conversion policy for function arguments when calling Python functions manually from C++ code (i.e. via handle::operator()) and the casters in pybind11/stl.h. You probably won’t need to use this explicitly. 如上所述，但是当返回值是指针时，使用策略return_value_policy::reference。当从c++代码(即通过句柄::operator())和pybind11/stl.h中的赋值函数手动调用Python函数时，这是函数参数的默认转换策略。您可能不需要显式地使用这个。 |

